{"version":3,"sources":["../src/utils/parseJsonLogic/index.ts","../src/defaults.ts","../src/utils/misc.ts","../src/utils/isRuleGroup.ts","../src/utils/convertQuery.ts","../src/utils/objectUtils.ts","../src/utils/toFullOption.ts","../src/utils/uniq.ts","../src/utils/optGroupUtils.ts","../src/utils/filterFieldsByComparator.ts","../src/utils/getValueSourcesUtil.ts","../src/utils/parserUtils.ts","../src/utils/parseJsonLogic/utils.ts","../src/utils/parseJsonLogic/parseJsonLogic.ts"],"sourcesContent":["export * from './parseJsonLogic';\n","import type {\n  Classnames,\n  DefaultCombinator,\n  DefaultCombinatorExtended,\n  DefaultOperator,\n  DefaultOperatorName,\n  TranslationsFull,\n} from './types/index.noReact';\n\n// DO NOT ALTER OR REMOVE REGION NAMES. Some of them are used\n// to generate code snippets in the documentation.\n\nconst placeholderName = '~';\nconst placeholderLabel = '------';\n/**\n * Default `name` for placeholder option in the `fields` array.\n */\nexport const defaultPlaceholderFieldName = placeholderName;\n/**\n * Default `label` for placeholder option in the `fields` array.\n */\nexport const defaultPlaceholderFieldLabel = placeholderLabel;\n/**\n * Default `label` for placeholder option group in the `fields` array.\n */\nexport const defaultPlaceholderFieldGroupLabel = placeholderLabel;\n/**\n * Default `name` for placeholder option in the `operators` array.\n */\nexport const defaultPlaceholderOperatorName = placeholderName;\n/**\n * Default `label` for placeholder option in the `operators` array.\n */\nexport const defaultPlaceholderOperatorLabel = placeholderLabel;\n/**\n * Default `label` for placeholder option group in the `operators` array.\n */\nexport const defaultPlaceholderOperatorGroupLabel = placeholderLabel;\n\n/**\n * Default character used to `.join` and `.split` arrays.\n */\nexport const defaultJoinChar = ',';\n\n/**\n * Default configuration of translatable strings.\n */\n// #region docs-translations\nexport const defaultTranslations = {\n  fields: {\n    title: 'Fields',\n    placeholderName: defaultPlaceholderFieldName,\n    placeholderLabel: defaultPlaceholderFieldLabel,\n    placeholderGroupLabel: defaultPlaceholderFieldGroupLabel,\n  } as const,\n  operators: {\n    title: 'Operators',\n    placeholderName: defaultPlaceholderOperatorName,\n    placeholderLabel: defaultPlaceholderOperatorLabel,\n    placeholderGroupLabel: defaultPlaceholderOperatorGroupLabel,\n  } as const,\n  value: {\n    title: 'Value',\n  } as const,\n  removeRule: {\n    label: '‚®Ø',\n    title: 'Remove rule',\n  } as const,\n  removeGroup: {\n    label: '‚®Ø',\n    title: 'Remove group',\n  } as const,\n  addRule: {\n    label: '+ Rule',\n    title: 'Add rule',\n  } as const,\n  addGroup: {\n    label: '+ Group',\n    title: 'Add group',\n  } as const,\n  combinators: {\n    title: 'Combinators',\n  } as const,\n  notToggle: {\n    label: 'Not',\n    title: 'Invert this group',\n  } as const,\n  cloneRule: {\n    label: '‚ßâ',\n    title: 'Clone rule',\n  } as const,\n  cloneRuleGroup: {\n    label: '‚ßâ',\n    title: 'Clone group',\n  } as const,\n  shiftActionUp: {\n    label: 'ÀÑ',\n    title: 'Shift up',\n  } as const,\n  shiftActionDown: {\n    label: 'ÀÖ',\n    title: 'Shift down',\n  } as const,\n  dragHandle: {\n    label: '‚Åû‚Åû',\n    title: 'Drag handle',\n  } as const,\n  lockRule: {\n    label: 'üîì',\n    title: 'Lock rule',\n  } as const,\n  lockGroup: {\n    label: 'üîì',\n    title: 'Lock group',\n  } as const,\n  lockRuleDisabled: {\n    label: 'üîí',\n    title: 'Unlock rule',\n  } as const,\n  lockGroupDisabled: {\n    label: 'üîí',\n    title: 'Unlock group',\n  } as const,\n  valueSourceSelector: {\n    title: 'Value source',\n  } as const,\n} satisfies TranslationsFull;\n// #endregion\n\n/**\n * Default operator list.\n */\n// #region docs-operators\nexport const defaultOperators = [\n  { name: '=', value: '=', label: '=' } as const,\n  { name: '!=', value: '!=', label: '!=' } as const,\n  { name: '<', value: '<', label: '<' } as const,\n  { name: '>', value: '>', label: '>' } as const,\n  { name: '<=', value: '<=', label: '<=' } as const,\n  { name: '>=', value: '>=', label: '>=' } as const,\n  { name: 'contains', value: 'contains', label: 'contains' } as const,\n  { name: 'beginsWith', value: 'beginsWith', label: 'begins with' } as const,\n  { name: 'endsWith', value: 'endsWith', label: 'ends with' } as const,\n  { name: 'doesNotContain', value: 'doesNotContain', label: 'does not contain' } as const,\n  { name: 'doesNotBeginWith', value: 'doesNotBeginWith', label: 'does not begin with' } as const,\n  { name: 'doesNotEndWith', value: 'doesNotEndWith', label: 'does not end with' } as const,\n  { name: 'null', value: 'null', label: 'is null' } as const,\n  { name: 'notNull', value: 'notNull', label: 'is not null' } as const,\n  { name: 'in', value: 'in', label: 'in' } as const,\n  { name: 'notIn', value: 'notIn', label: 'not in' } as const,\n  { name: 'between', value: 'between', label: 'between' } as const,\n  { name: 'notBetween', value: 'notBetween', label: 'not between' } as const,\n] satisfies DefaultOperator[];\n// #endregion\n\n/**\n * Map of default operators to their respective opposite/negating operators.\n */\nexport const defaultOperatorNegationMap = {\n  '=': '!=',\n  '!=': '=',\n  '<': '>=',\n  '<=': '>',\n  '>': '<=',\n  '>=': '<',\n  beginsWith: 'doesNotBeginWith',\n  doesNotBeginWith: 'beginsWith',\n  endsWith: 'doesNotEndWith',\n  doesNotEndWith: 'endsWith',\n  contains: 'doesNotContain',\n  doesNotContain: 'contains',\n  between: 'notBetween',\n  notBetween: 'between',\n  in: 'notIn',\n  notIn: 'in',\n  notNull: 'null',\n  null: 'notNull',\n} satisfies Record<DefaultOperatorName, DefaultOperatorName>;\n\n/**\n * Default combinator list.\n */\n// #region docs-combinators\nexport const defaultCombinators = [\n  { name: 'and', value: 'and', label: 'AND' } as const,\n  { name: 'or', value: 'or', label: 'OR' } as const,\n] satisfies DefaultCombinator[];\n// #endregion\n\n/**\n * Default combinator list, with `XOR` added.\n */\nexport const defaultCombinatorsExtended = [\n  ...defaultCombinators,\n  { name: 'xor', value: 'xor', label: 'XOR' } as const,\n] satisfies DefaultCombinatorExtended[];\n\n/**\n * Standard classnames applied to each component.\n */\n// #region docs-standardclassnames\nexport const standardClassnames = {\n  queryBuilder: 'queryBuilder',\n  ruleGroup: 'ruleGroup',\n  header: 'ruleGroup-header',\n  body: 'ruleGroup-body',\n  combinators: 'ruleGroup-combinators',\n  addRule: 'ruleGroup-addRule',\n  addGroup: 'ruleGroup-addGroup',\n  cloneRule: 'rule-cloneRule',\n  cloneGroup: 'ruleGroup-cloneGroup',\n  removeGroup: 'ruleGroup-remove',\n  notToggle: 'ruleGroup-notToggle',\n  rule: 'rule',\n  fields: 'rule-fields',\n  operators: 'rule-operators',\n  value: 'rule-value',\n  removeRule: 'rule-remove',\n  betweenRules: 'betweenRules',\n  valid: 'queryBuilder-valid',\n  invalid: 'queryBuilder-invalid',\n  shiftActions: 'shiftActions',\n  dndDragging: 'dndDragging',\n  dndOver: 'dndOver',\n  dndCopy: 'dndCopy',\n  dragHandle: 'queryBuilder-dragHandle',\n  disabled: 'queryBuilder-disabled',\n  lockRule: 'rule-lock',\n  lockGroup: 'ruleGroup-lock',\n  valueSource: 'rule-valueSource',\n  valueListItem: 'rule-value-list-item',\n  branches: 'queryBuilder-branches',\n} as const;\n// #endregion\n\n/**\n * Default classnames for each component.\n */\nexport const defaultControlClassnames = {\n  queryBuilder: '',\n  ruleGroup: '',\n  header: '',\n  body: '',\n  combinators: '',\n  addRule: '',\n  addGroup: '',\n  cloneRule: '',\n  cloneGroup: '',\n  removeGroup: '',\n  notToggle: '',\n  rule: '',\n  fields: '',\n  operators: '',\n  value: '',\n  removeRule: '',\n  shiftActions: '',\n  dragHandle: '',\n  lockRule: '',\n  lockGroup: '',\n  valueSource: '',\n  actionElement: '',\n  valueSelector: '',\n} satisfies Classnames;\n\n/**\n * Default reason codes for a group being invalid.\n */\nexport const groupInvalidReasons = {\n  empty: 'empty',\n  invalidCombinator: 'invalid combinator',\n  invalidIndependentCombinators: 'invalid independent combinators',\n} as const;\n\n/**\n * Component identifiers for testing.\n */\nexport const TestID = {\n  rule: 'rule',\n  ruleGroup: 'rule-group',\n  inlineCombinator: 'inline-combinator',\n  addGroup: 'add-group',\n  removeGroup: 'remove-group',\n  cloneGroup: 'clone-group',\n  cloneRule: 'clone-rule',\n  addRule: 'add-rule',\n  removeRule: 'remove-rule',\n  combinators: 'combinators',\n  fields: 'fields',\n  operators: 'operators',\n  valueEditor: 'value-editor',\n  notToggle: 'not-toggle',\n  shiftActions: 'shift-actions',\n  dragHandle: 'drag-handle',\n  lockRule: 'lock-rule',\n  lockGroup: 'lock-group',\n  valueSourceSelector: 'value-source-selector',\n} as const;\n\nexport const LogType = {\n  parentPathDisabled: 'action aborted: parent path disabled',\n  pathDisabled: 'action aborted: path is disabled',\n  queryUpdate: 'query updated',\n  onAddRuleFalse: 'onAddRule callback returned false',\n  onAddGroupFalse: 'onAddGroup callback returned false',\n  onRemoveFalse: 'onRemove callback returned false',\n  add: 'rule or group added',\n  remove: 'rule or group removed',\n  update: 'rule or group updated',\n  move: 'rule or group moved',\n} as const;\n","import { numericRegex as numericQuantityRegex } from 'numeric-quantity';\n\n/**\n * Regex matching numeric strings. Passes for positive/negative integers, decimals,\n * and E notation, with optional surrounding whitespace.\n */\nexport const numericRegex = new RegExp(\n  numericQuantityRegex.source.replace(/^\\^/, '^\\\\s*').replace(/\\$$/, '\\\\s*$')\n);\n\n/**\n * Determines if a variable is a plain old JavaScript object, aka POJO.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isPojo = (obj: any): obj is Record<string, any> =>\n  obj === null || typeof obj !== 'object' ? false : Object.getPrototypeOf(obj) === Object.prototype;\n","import type { RuleGroupType, RuleGroupTypeAny, RuleGroupTypeIC } from '../types/index.noReact';\nimport { isPojo } from './misc';\n\n/**\n * Determines if an object is a {@link RuleGroupType} or {@link RuleGroupTypeIC}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isRuleGroup = (rg: any): rg is RuleGroupTypeAny =>\n  isPojo(rg) && 'rules' in rg && Array.isArray(rg.rules);\n\n/**\n * Determines if an object is a {@link RuleGroupType}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isRuleGroupType = (rg: any): rg is RuleGroupType =>\n  isRuleGroup(rg) && typeof rg.combinator === 'string';\n\n/**\n * Determines if an object is a {@link RuleGroupTypeIC}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isRuleGroupTypeIC = (rg: any): rg is RuleGroupTypeIC =>\n  isRuleGroup(rg) && typeof rg.combinator === 'undefined';\n","import type {\n  RuleGroupArray,\n  RuleGroupICArray,\n  RuleGroupType,\n  RuleGroupTypeIC,\n  RuleType,\n} from '../types/index.noReact';\nimport { isRuleGroup, isRuleGroupType, isRuleGroupTypeIC } from './isRuleGroup';\n\nconst processRuleOrStringOrRuleGroupIC = (r: string | RuleType | RuleGroupTypeIC) =>\n  isRuleGroup(r) ? generateRuleGroupICWithConsistentCombinators(r) : r;\n\nconst generateRuleGroupICWithConsistentCombinators = (rg: RuleGroupTypeIC): RuleGroupTypeIC => {\n  const returnArray: RuleGroupICArray = [];\n  const push = (r: string | RuleType | RuleGroupTypeIC) =>\n    returnArray.push(processRuleOrStringOrRuleGroupIC(r) as RuleType | RuleGroupTypeIC);\n  let startIndex = 0;\n  for (let i = 0; i < rg.rules.length; i += 2) {\n    if (rg.rules.length === 1) {\n      push(rg.rules[0]);\n    } else if (rg.rules[i + 1] === 'and') {\n      startIndex = i;\n      let j = 1;\n      while (rg.rules[startIndex + j] === 'and') {\n        i += 2;\n        j += 2;\n      }\n      returnArray.push({\n        // @ts-expect-error Too complicated to keep track of odd/even indexes in TS\n        rules: rg.rules.slice(startIndex, i + 1).map(processRuleOrStringOrRuleGroupIC),\n      });\n      i -= 2;\n    } else if (rg.rules[i + 1] === 'or') {\n      if (i === 0 || i === rg.rules.length - 3) {\n        if (i === 0 || rg.rules[i - 1] === 'or') {\n          push(rg.rules[i]);\n        }\n        push(rg.rules[i + 1]);\n        if (i === rg.rules.length - 3) {\n          push(rg.rules[i + 2]);\n        }\n      } else {\n        if (rg.rules[i - 1] === 'and') {\n          push(rg.rules[i + 1]);\n        } else {\n          push(rg.rules[i]);\n          push(rg.rules[i + 1]);\n        }\n      }\n    }\n  }\n  if (\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-expect-error TS still thinks returnArray has length 0\n    returnArray.length === 1 &&\n    typeof returnArray[0] === 'object' &&\n    isRuleGroup(returnArray[0])\n  ) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-expect-error TS still thinks returnArray has length 0\n    return { ...rg, ...returnArray[0] };\n  }\n  return { ...rg, rules: returnArray };\n};\n\n/**\n * Converts a {@link RuleGroupTypeIC} to {@link RuleGroupType}.\n *\n * This function is idempotent: {@link RuleGroupType} queries will be\n * returned as-is.\n */\nexport const convertFromIC = <RG extends RuleGroupType = RuleGroupType>(\n  rg: RuleGroupTypeIC\n): RG => {\n  if (isRuleGroupType(rg)) {\n    return rg;\n  }\n  const processedRG = generateRuleGroupICWithConsistentCombinators(rg);\n  const rulesAsMixedList = processedRG.rules.map(r =>\n    typeof r === 'string' || !isRuleGroup(r) ? r : convertFromIC(r)\n  );\n  const combinator = rulesAsMixedList.length < 2 ? 'and' : (rulesAsMixedList[1] as string);\n  const rules = rulesAsMixedList.filter(r => typeof r !== 'string') as RuleGroupArray;\n  return { ...processedRG, combinator, rules } as RG;\n};\n\n/**\n * Converts a {@link RuleGroupType} to {@link RuleGroupTypeIC}.\n *\n * This function is idempotent: {@link RuleGroupTypeIC} queries will be\n * returned as-is.\n */\nexport const convertToIC = <RGIC extends RuleGroupTypeIC = RuleGroupTypeIC>(\n  rg: RuleGroupType\n): RGIC => {\n  if (isRuleGroupTypeIC(rg)) {\n    return rg;\n  }\n  const { combinator, ...queryWithoutCombinator } = rg;\n  const rules: (RuleGroupTypeIC | RuleType | string)[] = [];\n  const { length } = rg.rules;\n  rg.rules.forEach((r, idx) => {\n    if (isRuleGroup(r)) {\n      rules.push(convertToIC(r));\n    } else {\n      rules.push(r);\n    }\n    if (combinator && idx < length - 1) {\n      rules.push(combinator);\n    }\n  });\n  return { ...queryWithoutCombinator, rules } as RGIC;\n};\n\n/**\n * Converts a {@link RuleGroupType} to {@link RuleGroupTypeIC}. For a more explicit\n * operation, use {@link convertToIC}.\n */\nfunction convertQuery(query: RuleGroupType): RuleGroupTypeIC;\n/**\n * Converts a {@link RuleGroupTypeIC} to {@link RuleGroupType}. For a more explicit\n * operation, use {@link convertFromIC}.\n */\nfunction convertQuery(query: RuleGroupTypeIC): RuleGroupType;\nfunction convertQuery(query: RuleGroupType | RuleGroupTypeIC): RuleGroupType | RuleGroupTypeIC {\n  return isRuleGroupTypeIC(query) ? convertFromIC(query) : convertToIC(query);\n}\n\nexport { convertQuery };\n","// All code in this file is adapted from:\n// npm: https://www.npmjs.com/package/ts-extras\n// src: https://github.com/sindresorhus/ts-extras\n\n/**\n * Original looked like this (not sure why template string is used):\n * ```\n * type ObjectKeys<T extends object> = `${Exclude<keyof T, symbol>}`;\n * ```\n */\ntype ObjectKeys<T extends object> = Exclude<keyof T, symbol>;\n\n/**\n * A strongly-typed version of `Object.keys()`.\n *\n * [Original source](https://github.com/sindresorhus/ts-extras/blob/44f57392c5f027268330771996c4fdf9260b22d6/source/object-keys.ts)\n */\nexport const objectKeys = Object.keys as <Type extends object>(\n  value: Type\n) => Array<ObjectKeys<Type>>;\n\n/**\n * A strongly-typed version of `Object.entries()`.\n *\n * [Original source](https://github.com/sindresorhus/ts-extras/blob/44f57392c5f027268330771996c4fdf9260b22d6/source/object-entries.ts)\n */\nexport const objectEntries = Object.entries as <Type extends Record<PropertyKey, unknown>>(\n  value: Type\n) => Array<[ObjectKeys<Type>, Type[ObjectKeys<Type>]]>;\n","import { produce } from 'immer';\nimport type {\n  BaseOption,\n  BaseOptionMap,\n  FlexibleOption,\n  FlexibleOptionList,\n  FullOptionList,\n  Option,\n  ToFullOption,\n  ValueOption,\n} from '../types';\nimport { isPojo } from './misc';\nimport { isFlexibleOptionGroupArray } from './optGroupUtils';\n\nconst isOptionWithName = (opt: BaseOption): opt is Option =>\n  isPojo(opt) && 'name' in opt && typeof opt.name === 'string';\nconst isOptionWithValue = (opt: BaseOption): opt is ValueOption =>\n  isPojo(opt) && 'value' in opt && typeof opt.value === 'string';\n\n/**\n * Converts an {@link Option} or {@link ValueOption} (i.e., {@link BaseOption})\n * into a {@link FullOption}. Full options are left unchanged.\n */\nfunction toFullOption<Opt extends BaseOption>(\n  opt: Opt,\n  baseProperties?: Record<string, unknown>\n): ToFullOption<Opt> {\n  const recipe: (o: Opt) => ToFullOption<Opt> = produce(draft => {\n    const idObj: { name?: string; value?: string } = {};\n    let needsUpdating = !!baseProperties;\n\n    if (isOptionWithName(draft) && !isOptionWithValue(draft)) {\n      idObj.value = draft.name;\n      needsUpdating = true;\n    } else if (!isOptionWithName(draft) && isOptionWithValue(draft)) {\n      idObj.name = draft.value;\n      needsUpdating = true;\n    }\n\n    if (needsUpdating) {\n      return Object.assign({}, baseProperties, draft, idObj);\n    }\n  });\n  return recipe(opt);\n}\n\n/**\n * Converts an {@link OptionList} or {@link FlexibleOptionList} into a {@link FullOptionList}.\n * Lists of full options are left unchanged.\n */\nfunction toFullOptionList<Opt extends BaseOption, OptList extends FlexibleOptionList<Opt>>(\n  optList: OptList,\n  baseProperties?: Record<string, unknown>\n): FullOptionList<Opt> {\n  if (!Array.isArray(optList)) {\n    return [] as unknown as FullOptionList<Opt>;\n  }\n\n  const recipe: (ol: FlexibleOptionList<Opt>) => FullOptionList<Opt> = produce(draft => {\n    if (isFlexibleOptionGroupArray(draft)) {\n      for (const optGroup of draft) {\n        optGroup.options.forEach(\n          (opt, idx) => (optGroup.options[idx] = toFullOption(opt, baseProperties))\n        );\n      }\n    } else {\n      (draft as Opt[]).forEach((opt, idx) => (draft[idx] = toFullOption(opt, baseProperties)));\n    }\n  });\n\n  return recipe(optList);\n}\n\n/**\n * Converts a {@link FlexibleOptionList} into a {@link FullOptionList}.\n * Lists of full options are left unchanged.\n */\nfunction toFullOptionMap<OptMap extends BaseOptionMap>(\n  optMap: OptMap,\n  baseProperties?: Record<string, unknown>\n): OptMap extends BaseOptionMap<infer V, infer K> ? Partial<Record<K, ToFullOption<V>>> : never {\n  type FullOptMapType =\n    OptMap extends BaseOptionMap<infer VT, infer KT>\n      ? Partial<Record<KT, ToFullOption<VT>>>\n      : never;\n\n  return Object.fromEntries(\n    (Object.entries(optMap) as [string, FlexibleOption][]).map(([k, v]) => [\n      k,\n      toFullOption(v, baseProperties),\n    ])\n  ) as FullOptMapType;\n}\n\nexport { toFullOption, toFullOptionList, toFullOptionMap };\n","import type { RequireAtLeastOne } from 'type-fest';\nimport type {\n  BaseOption,\n  FlexibleOptionGroup,\n  FlexibleOptionList,\n  OptionGroup,\n  ToFullOption,\n  WithUnknownIndex,\n} from '../types/index.noReact';\nimport { isFlexibleOptionGroupArray } from './optGroupUtils';\nimport { toFullOption } from './toFullOption';\n\n/**\n * @deprecated Renamed to {@link uniqByIdentifier}.\n */\nexport const uniqByName = <\n  T extends { name: string; value?: string } | { name?: string; value: string },\n>(\n  originalArray: T[]\n): T[] => uniqByIdentifier(originalArray);\n\n/**\n * Generates a new array of objects with duplicates removed based\n * on the identifying property (`value` or `name`)\n */\nexport const uniqByIdentifier = <\n  T extends RequireAtLeastOne<{ name: string; value: string }, 'name' | 'value'>,\n>(\n  originalArray: T[]\n): T[] => {\n  const names = new Set<string>();\n  const newArray: T[] = [];\n  originalArray.forEach(el => {\n    if (!names.has((el.value ?? el.name)!)) {\n      names.add((el.value ?? el.name)!);\n      newArray.push(el);\n    }\n  });\n  return originalArray.length === newArray.length ? originalArray : newArray;\n};\n\n/**\n * Generates a new {@link OptionGroup} array with duplicates\n * removed based on the identifying property (`value` or `name`).\n */\nexport const uniqOptGroups = <T extends BaseOption>(\n  originalArray: FlexibleOptionGroup<T>[]\n): OptionGroup<ToFullOption<T>>[] => {\n  type K = T extends BaseOption<infer KT> ? KT : never;\n  const labels = new Set<string>();\n  const names = new Set<K>();\n  const newArray: OptionGroup<ToFullOption<T>>[] = [];\n  originalArray.forEach(el => {\n    if (!labels.has(el.label)) {\n      labels.add(el.label);\n      const optionsForThisGroup: WithUnknownIndex<ToFullOption<T>>[] = [];\n      el.options.forEach(opt => {\n        if (!names.has((opt.value ?? opt.name) as K)) {\n          names.add((opt.value ?? opt.name) as K);\n          optionsForThisGroup.push(toFullOption(opt) as WithUnknownIndex<ToFullOption<T>>);\n        }\n      });\n      newArray.push({ ...el, options: optionsForThisGroup });\n    }\n  });\n  return newArray;\n};\n\n/**\n * Generates a new {@link Option} or {@link OptionGroup} array with duplicates\n * removed based on the identifier property (`value` or `name`).\n */\nexport const uniqOptList = <T extends BaseOption>(originalArray: FlexibleOptionList<T>) => {\n  if (isFlexibleOptionGroupArray(originalArray)) {\n    return uniqOptGroups(originalArray) as OptionGroup<ToFullOption<T>>[];\n  }\n  return uniqByIdentifier((originalArray as BaseOption[]).map(o => toFullOption(o)));\n};\n","import type {\n  BaseOption,\n  FlexibleOptionGroup,\n  FullOption,\n  FullOptionList,\n  GetOptionIdentifierType,\n  Option,\n  OptionGroup,\n  OptionList,\n} from '../types/index.noReact';\nimport { isPojo } from './misc';\nimport { uniqByIdentifier } from './uniq';\n\n/**\n * Determines if an {@link OptionList} is an {@link OptionGroup} array.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isOptionGroupArray = (arr: any): arr is OptionGroup<BaseOption>[] =>\n  Array.isArray(arr) && arr.length > 0 && isPojo(arr[0]) && 'options' in arr[0];\n\n/**\n * Determines if a {@link FlexibleOptionList} is a {@link FlexibleOptionGroup} array.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isFlexibleOptionGroupArray = (arr: any): arr is FlexibleOptionGroup[] =>\n  Array.isArray(arr) &&\n  arr.length > 0 &&\n  isPojo(arr[0]) &&\n  'options' in arr[0] &&\n  isPojo(arr[0].options[0]) &&\n  ('name' in arr[0].options[0] || 'value' in arr[0].options[0]);\n\n/**\n * Determines if a {@link FlexibleOptionList} is a {@link OptionGroup} array of\n * {@link FullOption}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isFullOptionGroupArray = (arr: any): arr is OptionGroup<FullOption>[] =>\n  Array.isArray(arr) &&\n  arr.length > 0 &&\n  isPojo(arr[0]) &&\n  'options' in arr[0] &&\n  isPojo(arr[0].options[0]) &&\n  'name' in arr[0].options[0] &&\n  isPojo(arr[0].options[0]) &&\n  'value' in arr[0].options[0];\n\n/**\n * Gets the option from an {@link OptionList} with the given `name`. Handles\n * {@link Option} arrays as well as {@link OptionGroup} arrays.\n */\nexport const getOption = <OptType extends Option = Option>(\n  arr: OptionList<OptType>,\n  name: string\n): OptType | undefined =>\n  (isOptionGroupArray(arr) ? arr.flatMap(og => og.options) : arr).find(op => op.name === name);\n\n/**\n * Gets the first option from an {@link OptionList}.\n */\nexport const getFirstOption = <Opt extends BaseOption>(arr?: FlexibleOptionGroup<Opt>[] | Opt[]) =>\n  (!Array.isArray(arr) || arr.length === 0\n    ? null\n    : isFlexibleOptionGroupArray(arr)\n      ? arr[0].options[0].value ?? arr[0].options[0].name\n      : arr[0].value ?? arr[0].name) as GetOptionIdentifierType<Opt>;\n\n/**\n * Flattens {@link FlexibleOptionGroup} arrays into {@link BaseOption} arrays.\n * If the array is already flat, it is returned as is.\n */\nexport const toFlatOptionArray = <T extends FullOption, OL extends FullOptionList<T>>(arr: OL) =>\n  uniqByIdentifier(isOptionGroupArray(arr) ? arr.flatMap(og => og.options) : arr) as T[];\n","import type { FullField, OptionList } from '../types/index.noReact';\nimport { isFlexibleOptionGroupArray } from './optGroupUtils';\nimport { toFullOption } from './toFullOption';\n\nconst filterByComparator = (field: FullField, operator: string, fieldToCompare: FullField) => {\n  const fullField = toFullOption(field);\n  const fullFieldToCompare = toFullOption(fieldToCompare);\n  if (fullField.value === fullFieldToCompare.value) {\n    return false;\n  }\n  if (typeof fullField.comparator === 'string') {\n    return fullField[fullField.comparator] === fullFieldToCompare[fullField.comparator];\n  }\n  return fullField.comparator?.(fullFieldToCompare, operator) ?? /* istanbul ignore next */ false;\n};\n\n/**\n * For a given {@link FullField}, returns the `fields` list filtered for\n * other fields that match by `comparator`. Only fields *other than the\n * one in question* will ever be included, even if `comparator` is `null`\n * or `undefined`. If `comparator` is a string, fields with the same value\n * for that property will be included. If `comparator` is a function, each\n * field will be passed to the function along with the `operator` and fields\n * for which the function returns `true` will be included.\n */\nexport const filterFieldsByComparator = (\n  /** The field in question. */\n  field: FullField,\n  /** The full {@link FullField} list to be filtered. */\n  fields: OptionList<FullField>,\n  operator: string\n) => {\n  if (!field.comparator) {\n    const filterOutSameField = (f: FullField) =>\n      (f.value ?? /* istanbul ignore next */ f.name) !==\n      (field.value ?? /* istanbul ignore next */ field.name);\n    if (isFlexibleOptionGroupArray(fields)) {\n      return fields.map(og => ({\n        ...og,\n        options: og.options.filter(filterOutSameField),\n      }));\n    }\n    return fields.filter(filterOutSameField);\n  }\n\n  if (isFlexibleOptionGroupArray(fields)) {\n    return fields\n      .map(og => ({\n        ...og,\n        options: og.options.filter(f => filterByComparator(field, operator, f)),\n      }))\n      .filter(og => og.options.length > 0);\n  }\n\n  return fields.filter(f => filterByComparator(field, operator, f));\n};\n","import type { FullField, GetOptionIdentifierType, ValueSources } from '../types/index.noReact';\nimport { toFullOption } from './toFullOption';\n\nconst defaultValueSourcesArray: ValueSources = ['value'];\n\nconst dummyFD = {\n  name: 'name',\n  value: 'name',\n  valueSources: null,\n  label: 'label',\n};\n\n/**\n * Utility function to get the value sources array for the given\n * field and operator. If the field definition does not define a\n * `valueSources` property, the `getValueSources` prop is used.\n * Returns `[\"value\"]` by default.\n */\nexport const getValueSourcesUtil = <F extends FullField, O extends string>(\n  fieldData: F,\n  operator: string,\n  getValueSources?: (\n    field: GetOptionIdentifierType<F>,\n    operator: O,\n    misc: { fieldData: F }\n  ) => ValueSources\n): ValueSources => {\n  // TypeScript doesn't allow it directly, but in practice\n  // `fieldData` can end up being undefined or null. The nullish\n  // coalescing assignment below avoids errors like\n  // \"TypeError: Cannot read properties of undefined (reading 'name')\"\n  const fd = fieldData ? toFullOption(fieldData) : /* istanbul ignore else */ dummyFD;\n\n  if (fd.valueSources) {\n    if (typeof fd.valueSources === 'function') {\n      return fd.valueSources(operator as O);\n    }\n    return fd.valueSources;\n  }\n  if (getValueSources) {\n    const vals = getValueSources(fd.value as GetOptionIdentifierType<F>, operator as O, {\n      fieldData: toFullOption(fd) as F,\n    });\n    /* istanbul ignore else */\n    if (vals) return vals;\n  }\n\n  return defaultValueSourcesArray;\n};\n","import type {\n  DefaultOperatorName,\n  FullField,\n  OptionList,\n  ValueSources,\n} from '../types/index.noReact';\nimport { filterFieldsByComparator } from './filterFieldsByComparator';\nimport { getValueSourcesUtil } from './getValueSourcesUtil';\nimport { toFlatOptionArray } from './optGroupUtils';\nimport { toFullOption } from './toFullOption';\n\nexport const getFieldsArray = (fields?: OptionList<FullField> | Record<string, FullField>) => {\n  const fieldsArray = !fields\n    ? []\n    : Array.isArray(fields)\n      ? fields\n      : Object.keys(fields)\n          .map(fld => ({ ...fields[fld], name: fld }))\n          .sort((a, b) => a.label.localeCompare(b.label));\n  return toFlatOptionArray(fieldsArray);\n};\n\nexport function fieldIsValidUtil(params: {\n  fieldsFlat: FullField[];\n  getValueSources?: (field: string, operator: string) => ValueSources;\n  fieldName: string;\n  operator: DefaultOperatorName;\n  subordinateFieldName?: string;\n}) {\n  const { fieldsFlat, fieldName, operator, subordinateFieldName, getValueSources } = params;\n\n  // If fields option was an empty array or undefined, then all identifiers\n  // are considered valid.\n  if (fieldsFlat.length === 0) return true;\n\n  let valid = false;\n\n  const primaryField = toFullOption(fieldsFlat.find(ff => ff.name === fieldName)!);\n  if (primaryField) {\n    if (\n      !subordinateFieldName &&\n      operator !== 'notNull' &&\n      operator !== 'null' &&\n      !getValueSourcesUtil(primaryField, operator, getValueSources).some(vs => vs === 'value')\n    ) {\n      valid = false;\n    } else {\n      valid = true;\n    }\n\n    if (valid && !!subordinateFieldName) {\n      if (\n        getValueSourcesUtil(primaryField, operator, getValueSources).some(vs => vs === 'field') &&\n        fieldName !== subordinateFieldName\n      ) {\n        const validSubordinateFields = filterFieldsByComparator(\n          primaryField,\n          fieldsFlat,\n          operator\n        ) as FullField[];\n        if (!validSubordinateFields.find(vsf => vsf.name === subordinateFieldName)) {\n          valid = false;\n        }\n      } else {\n        valid = false;\n      }\n    }\n  }\n\n  return valid;\n}\n","import type {\n  JsonLogicAnd,\n  JsonLogicDoubleNegation,\n  JsonLogicEqual,\n  JsonLogicGreaterThan,\n  JsonLogicGreaterThanOrEqual,\n  JsonLogicInArray,\n  JsonLogicInString,\n  JsonLogicLessThan,\n  JsonLogicLessThanOrEqual,\n  JsonLogicNegation,\n  JsonLogicNotEqual,\n  JsonLogicOr,\n  JsonLogicStrictEqual,\n  JsonLogicStrictNotEqual,\n  JsonLogicVar,\n  RQBJsonLogic,\n  RQBJsonLogicEndsWith,\n  RQBJsonLogicStartsWith,\n  RQBJsonLogicVar,\n} from '../../types/index.noReact';\nimport { isPojo } from '../misc';\nimport type { JsonLogicBetweenExclusive, JsonLogicBetweenInclusive } from './types';\n\n// Standard JsonLogic operations\nexport const isJsonLogicVar = (\n  logic: RQBJsonLogic\n): logic is JsonLogicVar<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n  isPojo(logic) && 'var' in logic;\nexport const isRQBJsonLogicVar = (logic: RQBJsonLogic): logic is RQBJsonLogicVar =>\n  isJsonLogicVar(logic) && typeof logic.var === 'string';\nexport const isJsonLogicEqual = (logic: RQBJsonLogic): logic is JsonLogicEqual =>\n  isPojo(logic) && '==' in logic;\nexport const isJsonLogicStrictEqual = (logic: RQBJsonLogic): logic is JsonLogicStrictEqual =>\n  isPojo(logic) && '===' in logic;\nexport const isJsonLogicNotEqual = (logic: RQBJsonLogic): logic is JsonLogicNotEqual =>\n  isPojo(logic) && '!=' in logic;\nexport const isJsonLogicStrictNotEqual = (logic: RQBJsonLogic): logic is JsonLogicStrictNotEqual =>\n  isPojo(logic) && '!==' in logic;\nexport const isJsonLogicNegation = (logic: RQBJsonLogic): logic is JsonLogicNegation =>\n  isPojo(logic) && '!' in logic;\nexport const isJsonLogicDoubleNegation = (logic: RQBJsonLogic): logic is JsonLogicDoubleNegation =>\n  isPojo(logic) && '!!' in logic;\nexport const isJsonLogicOr = (\n  logic: RQBJsonLogic\n): logic is JsonLogicOr<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n  isPojo(logic) && 'or' in logic;\nexport const isJsonLogicAnd = (\n  logic: RQBJsonLogic\n): logic is JsonLogicAnd<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n  isPojo(logic) && 'and' in logic;\nexport const isJsonLogicGreaterThan = (\n  logic: RQBJsonLogic\n): logic is JsonLogicGreaterThan<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n  isPojo(logic) && '>' in logic;\nexport const isJsonLogicGreaterThanOrEqual = (\n  logic: RQBJsonLogic\n): logic is JsonLogicGreaterThanOrEqual<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n  isPojo(logic) && '>=' in logic;\nexport const isJsonLogicLessThan = (\n  logic: RQBJsonLogic\n): logic is JsonLogicLessThan<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n  isPojo(logic) && '<' in logic && logic['<'].length === 2;\nexport const isJsonLogicLessThanOrEqual = (\n  logic: RQBJsonLogic\n): logic is JsonLogicLessThanOrEqual<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n  isPojo(logic) && '<=' in logic && logic['<='].length === 2;\nexport const isJsonLogicInArray = (\n  logic: RQBJsonLogic\n): logic is JsonLogicInArray<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n  isPojo(logic) && 'in' in logic && Array.isArray(logic.in[1]);\nexport const isJsonLogicInString = (\n  logic: RQBJsonLogic\n): logic is JsonLogicInString<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n  isPojo(logic) && 'in' in logic && !Array.isArray(logic.in[1]);\n\n// \"Between\" operations are special cases of '<' and '<='\nexport const isJsonLogicBetweenExclusive = (\n  logic: RQBJsonLogic\n): logic is JsonLogicBetweenExclusive =>\n  isPojo(logic) && '<' in logic && Array.isArray(logic['<']) && logic['<'].length === 3;\nexport const isJsonLogicBetweenInclusive = (\n  logic: RQBJsonLogic\n): logic is JsonLogicBetweenInclusive =>\n  isPojo(logic) && '<=' in logic && Array.isArray(logic['<=']) && logic['<='].length === 3;\n\n// RQB extensions\nexport const isRQBJsonLogicStartsWith = (logic: RQBJsonLogic): logic is RQBJsonLogicStartsWith =>\n  isPojo(logic) && 'startsWith' in logic;\nexport const isRQBJsonLogicEndsWith = (logic: RQBJsonLogic): logic is RQBJsonLogicEndsWith =>\n  isPojo(logic) && 'endsWith' in logic;\n\n// Type guards for unused JsonLogic operations\n\n// import type {\n//   JsonLogicAll,\n//   JsonLogicCat,\n//   JsonLogicDifference,\n//   JsonLogicFilter,\n//   JsonLogicIf,\n//   JsonLogicLog,\n//   JsonLogicMap,\n//   JsonLogicMax,\n//   JsonLogicMerge,\n//   JsonLogicMin,\n//   JsonLogicMissing,\n//   JsonLogicMissingSome,\n//   JsonLogicNone,\n//   JsonLogicProduct,\n//   JsonLogicQuotient,\n//   JsonLogicReduce,\n//   JsonLogicRemainder,\n//   JsonLogicSome,\n//   JsonLogicSubstr,\n//   JsonLogicSum,\n// } from '../../types/index.noReact';\n//\n// export const isJsonLogicMissing = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicMissing<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && 'missing' in logic;\n// export const isJsonLogicMissingSome = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicMissingSome<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && 'missing_some' in logic;\n// export const isJsonLogicIf = (logic: RQBJsonLogic): logic is JsonLogicIf =>\n//   isPojo(logic) && 'if' in logic;\n// export const isJsonLogicMax = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicMax<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && 'max' in logic;\n// export const isJsonLogicMin = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicMin<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && 'min' in logic;\n// export const isJsonLogicSum = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicSum<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && '+' in logic;\n// export const isJsonLogicDifference = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicDifference<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && '-' in logic;\n// export const isJsonLogicProduct = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicProduct<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && '*' in logic;\n// export const isJsonLogicQuotient = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicQuotient<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && '/' in logic;\n// export const isJsonLogicRemainder = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicRemainder<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && '%' in logic;\n// export const isJsonLogicMap = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicMap<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && 'map' in logic;\n// export const isJsonLogicFilter = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicFilter<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && 'filter' in logic;\n// export const isJsonLogicReduce = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicReduce<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && 'reduce' in logic;\n// export const isJsonLogicAll = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicAll<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && 'all' in logic;\n// export const isJsonLogicNone = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicNone<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && 'none' in logic;\n// export const isJsonLogicSome = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicSome<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && 'some' in logic;\n// export const isJsonLogicMerge = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicMerge<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && 'merge' in logic;\n// export const isJsonLogicCat = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicCat<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && 'cat' in logic;\n// export const isJsonLogicSubstr = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicSubstr<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && 'substr' in logic;\n// export const isJsonLogicLog = (\n//   logic: RQBJsonLogic\n// ): logic is JsonLogicLog<RQBJsonLogicStartsWith | RQBJsonLogicEndsWith> =>\n//   isPojo(logic) && 'log' in logic;\n","import { defaultOperatorNegationMap } from '../../defaults';\nimport type {\n  DefaultOperatorName,\n  DefaultRuleGroupType,\n  DefaultRuleGroupTypeAny,\n  DefaultRuleGroupTypeIC,\n  DefaultRuleType,\n  JsonLogicReservedOperations,\n  ParseJsonLogicOptions,\n  RQBJsonLogic,\n  RQBJsonLogicVar,\n  ValueSource,\n} from '../../types/index.noReact';\nimport { convertToIC } from '../convertQuery';\nimport { isRuleGroupType } from '../isRuleGroup';\nimport { isPojo } from '../misc';\nimport { objectKeys } from '../objectUtils';\nimport { fieldIsValidUtil, getFieldsArray } from '../parserUtils';\nimport {\n  isJsonLogicAnd,\n  isJsonLogicBetweenExclusive,\n  isJsonLogicBetweenInclusive,\n  isJsonLogicDoubleNegation,\n  isJsonLogicEqual,\n  isJsonLogicGreaterThan,\n  isJsonLogicGreaterThanOrEqual,\n  isJsonLogicInArray,\n  isJsonLogicInString,\n  isJsonLogicLessThan,\n  isJsonLogicLessThanOrEqual,\n  isJsonLogicNegation,\n  isJsonLogicNotEqual,\n  isJsonLogicOr,\n  isJsonLogicStrictEqual,\n  isJsonLogicStrictNotEqual,\n  isRQBJsonLogicEndsWith,\n  isRQBJsonLogicStartsWith,\n  isRQBJsonLogicVar,\n} from './utils';\n\nconst emptyRuleGroup: DefaultRuleGroupType = { combinator: 'and', rules: [] };\n\n/**\n * Converts a JsonLogic object into a query suitable for the\n * {@link QueryBuilder} component's `query` or `defaultQuery` props\n * ({@link DefaultRuleGroupType}).\n */\nfunction parseJsonLogic(rqbJsonLogic: string | RQBJsonLogic): DefaultRuleGroupType;\n/**\n * Converts a JsonLogic object into a query suitable for the\n * {@link QueryBuilder} component's `query` or `defaultQuery` props\n * ({@link DefaultRuleGroupType}).\n */\nfunction parseJsonLogic(\n  rqbJsonLogic: string | RQBJsonLogic,\n  options: Omit<ParseJsonLogicOptions, 'independentCombinators'> & {\n    independentCombinators?: false;\n  }\n): DefaultRuleGroupType;\n/**\n * Converts a JsonLogic object into a query suitable for the\n * {@link QueryBuilder} component's `query` or `defaultQuery` props\n * ({@link DefaultRuleGroupTypeIC}).\n */\nfunction parseJsonLogic(\n  rqbJsonLogic: string | RQBJsonLogic,\n  options: Omit<ParseJsonLogicOptions, 'independentCombinators'> & {\n    independentCombinators: true;\n  }\n): DefaultRuleGroupTypeIC;\nfunction parseJsonLogic(\n  rqbJsonLogic: string | RQBJsonLogic,\n  options: ParseJsonLogicOptions = {}\n): DefaultRuleGroupTypeAny {\n  const fieldsFlat = getFieldsArray(options.fields);\n  const { getValueSources, listsAsArrays, jsonLogicOperations } = options;\n\n  const fieldIsValid = (\n    fieldName: string,\n    operator: DefaultOperatorName,\n    subordinateFieldName?: string\n  ) =>\n    fieldIsValidUtil({\n      fieldName,\n      fieldsFlat,\n      operator,\n      subordinateFieldName,\n      getValueSources,\n    });\n\n  // Overload 1: Always return a rule group or false for the outermost logic object\n  function processLogic(logic: RQBJsonLogic, outermost: true): DefaultRuleGroupType | false;\n  // Overload 2: If not the outermost object, return value could also be a rule\n  function processLogic(\n    logic: RQBJsonLogic,\n    outermost?: false\n  ): DefaultRuleGroupType | DefaultRuleType | false;\n  // Implementation\n  function processLogic(\n    logic: RQBJsonLogic,\n    outermost?: boolean\n  ): DefaultRuleGroupType | DefaultRuleType | false {\n    // Bail if the outermost logic is not a plain object\n    if (outermost && !isPojo(logic)) {\n      return false;\n    }\n    const key = Object.keys(logic)[0] as JsonLogicReservedOperations;\n    // @ts-expect-error `key in logic` is always true, but TS doesn't know that\n    const keyValue = logic[key];\n    // Rule groups\n    if (isJsonLogicAnd(logic)) {\n      return {\n        combinator: 'and',\n        rules: logic.and.map(l => processLogic(l)).filter(Boolean) as (\n          | DefaultRuleType\n          | DefaultRuleGroupType\n        )[],\n      };\n    } else if (isJsonLogicOr(logic)) {\n      return {\n        combinator: 'or',\n        rules: logic.or.map(l => processLogic(l)).filter(Boolean) as (\n          | DefaultRuleType\n          | DefaultRuleGroupType\n        )[],\n      };\n    } else if (isJsonLogicNegation(logic)) {\n      const rule = processLogic(logic['!']);\n      if (rule) {\n        if (\n          !isRuleGroupType(rule) &&\n          (rule.operator === 'between' ||\n            rule.operator === 'in' ||\n            rule.operator === 'contains' ||\n            rule.operator === 'beginsWith' ||\n            rule.operator === 'endsWith')\n        ) {\n          const newRule = { ...rule, operator: defaultOperatorNegationMap[rule.operator] };\n          if (outermost) {\n            return { combinator: 'and', rules: [newRule] };\n          }\n          return newRule;\n        } else if (isJsonLogicBetweenExclusive(logic['!']) || isRuleGroupType(rule)) {\n          return { ...rule, not: true };\n        }\n        return { combinator: 'and', rules: [rule], not: true };\n      }\n      return false;\n    } else if (isJsonLogicDoubleNegation(logic)) {\n      const rule = processLogic(logic['!!']);\n      return rule || false;\n    }\n\n    // All other keys represent rules\n    let rule: DefaultRuleType | false = false;\n    let field = '';\n    let operator: DefaultOperatorName = '=';\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let value: any = '';\n    let valueSource: ValueSource | undefined = undefined;\n\n    if (jsonLogicOperations && objectKeys(jsonLogicOperations).includes(key)) {\n      // Custom operations\n      rule = jsonLogicOperations[key](keyValue) as DefaultRuleType;\n    } else if (\n      // Basic boolean operations\n      isJsonLogicEqual(logic) ||\n      isJsonLogicStrictEqual(logic) ||\n      isJsonLogicNotEqual(logic) ||\n      isJsonLogicStrictNotEqual(logic) ||\n      isJsonLogicGreaterThan(logic) ||\n      isJsonLogicGreaterThanOrEqual(logic) ||\n      isJsonLogicLessThan(logic) ||\n      isJsonLogicLessThanOrEqual(logic) ||\n      isJsonLogicInString(logic) ||\n      isRQBJsonLogicStartsWith(logic) ||\n      isRQBJsonLogicEndsWith(logic)\n    ) {\n      const [first, second] = keyValue;\n      if (isRQBJsonLogicVar(first) && !isPojo(second)) {\n        field = first.var;\n        value = second;\n      } else if (!isPojo(first) && isRQBJsonLogicVar(second)) {\n        field = second.var;\n        value = first;\n      } else if (isRQBJsonLogicVar(first) && isRQBJsonLogicVar(second)) {\n        field = first.var;\n        value = second.var;\n        valueSource = 'field';\n      } else {\n        return false;\n      }\n\n      // Translate operator if necessary\n      if (isJsonLogicEqual(logic) || isJsonLogicStrictEqual(logic)) {\n        operator = value === null ? 'null' : '=';\n      } else if (isJsonLogicNotEqual(logic) || isJsonLogicStrictNotEqual(logic)) {\n        operator = value === null ? 'notNull' : '!=';\n      } else if (isJsonLogicInString(logic)) {\n        operator = 'contains';\n      } else if (isRQBJsonLogicStartsWith(logic)) {\n        operator = 'beginsWith';\n      } else if (isRQBJsonLogicEndsWith(logic)) {\n        operator = 'endsWith';\n      } else {\n        operator = key as DefaultOperatorName;\n      }\n\n      if (fieldIsValid(field, operator, valueSource === 'field' ? value : undefined)) {\n        rule = { field, operator, value, valueSource };\n      }\n    } else if (isJsonLogicBetweenExclusive(logic) && isRQBJsonLogicVar(logic['<'][1])) {\n      field = logic['<'][1].var;\n      const values = [logic['<'][0], logic['<'][2]];\n      // istanbul ignore else\n      if (\n        values.every(isRQBJsonLogicVar) ||\n        values.every(el => typeof el === 'string') ||\n        values.every(el => typeof el === 'number') ||\n        values.every(el => typeof el === 'boolean')\n      ) {\n        return (\n          processLogic({\n            and: [{ '>': [{ var: field }, values[0]] }, { '<': [{ var: field }, values[1]] }],\n          }) || /* istanbul ignore next */ false\n        );\n      }\n    } else if (isJsonLogicBetweenInclusive(logic) && isRQBJsonLogicVar(logic['<='][1])) {\n      field = logic['<='][1].var;\n      operator = 'between';\n      const values = [logic['<='][0], logic['<='][2]];\n      if (logic['<='].every(isRQBJsonLogicVar)) {\n        const vars = values as RQBJsonLogicVar[];\n        valueSource = 'field';\n        const fieldList = vars.map(el => el.var).filter(sf => fieldIsValid(field, operator, sf));\n        value = listsAsArrays ? fieldList : fieldList.join(',');\n      } else {\n        // istanbul ignore else\n        if (\n          values.every(el => typeof el === 'string') ||\n          values.every(el => typeof el === 'number') ||\n          values.every(el => typeof el === 'boolean')\n        ) {\n          value = listsAsArrays ? values : values.map(el => `${el}`).join(',');\n        }\n      }\n\n      if (fieldIsValid(field, operator) && value.length >= 2) {\n        rule = { field, operator, value, valueSource };\n      }\n    } else if (isJsonLogicInArray(logic) && isRQBJsonLogicVar(keyValue[0])) {\n      field = keyValue[0].var;\n      operator = 'in';\n      if (logic.in[1].every(isRQBJsonLogicVar)) {\n        valueSource = 'field';\n        const fieldList = logic.in[1]\n          .map(el => el.var as string)\n          .filter(sf => fieldIsValid(field, operator, sf));\n        value = listsAsArrays ? fieldList : fieldList.join(',');\n      } else {\n        // istanbul ignore else\n        if (\n          logic.in[1].every(el => typeof el === 'string') ||\n          logic.in[1].every(el => typeof el === 'number') ||\n          logic.in[1].every(el => typeof el === 'boolean')\n        ) {\n          value = listsAsArrays ? logic.in[1] : logic.in[1].map(el => `${el}`).join(',');\n        }\n      }\n\n      // istanbul ignore else\n      if (value.length > 0) {\n        rule = { field, operator, value, valueSource };\n      }\n    }\n\n    return !rule ? false : outermost ? { combinator: 'and', rules: [rule] } : rule;\n  }\n\n  let logicRoot = rqbJsonLogic;\n  if (typeof rqbJsonLogic === 'string') {\n    try {\n      logicRoot = JSON.parse(rqbJsonLogic);\n    } catch (err) {\n      return emptyRuleGroup;\n    }\n  }\n\n  const result = processLogic(logicRoot, true);\n  const finalQuery: DefaultRuleGroupType = !result ? emptyRuleGroup : result;\n  return options.independentCombinators\n    ? convertToIC<DefaultRuleGroupTypeIC>(finalQuery)\n    : finalQuery;\n}\n\nexport { parseJsonLogic };\n"],"mappings":"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","names":["numericQuantityRegex","rule"]}