{"version":3,"sources":["../../../node_modules/jsonata/jsonata.js","../src/utils/parseJSONata/index.ts","../src/utils/parseJSONata/parseJSONata.ts","../src/utils/misc.ts","../src/utils/isRuleGroup.ts","../src/utils/toFullOption.ts","../src/utils/uniq.ts","../src/utils/optGroupUtils.ts","../src/utils/filterFieldsByComparator.ts","../src/utils/getValueSourcesUtil.ts","../src/utils/parserUtils.ts","../src/utils/parseJSONata/utils.ts"],"sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.jsonata = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n * Â© Copyright IBM Corp. 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nconst utils = require('./utils');\n\n/**\n * DateTime formatting and parsing functions\n * Implements the xpath-functions format-date-time specification\n * @type {{formatInteger, formatDateTime, parseInteger, parseDateTime}}\n */\nconst dateTime = (function () {\n    'use strict';\n\n    const stringToArray = utils.stringToArray;\n\n    const few = ['Zero', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten',\n        'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen'];\n    const ordinals = ['Zeroth', 'First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth', 'Seventh', 'Eighth', 'Ninth', 'Tenth',\n        'Eleventh', 'Twelfth', 'Thirteenth', 'Fourteenth', 'Fifteenth', 'Sixteenth', 'Seventeenth', 'Eighteenth', 'Nineteenth'];\n    const decades = ['Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety', 'Hundred'];\n    const magnitudes = ['Thousand', 'Million', 'Billion', 'Trillion'];\n\n    /**\n     * converts a number into english words\n     * @param {string} value - the value to format\n     * @param {boolean} ordinal - ordinal or cardinal form\n     * @returns {string} - representation in words\n     */\n    function numberToWords(value, ordinal) {\n        var lookup = function (num, prev, ord) {\n            var words = '';\n            if (num <= 19) {\n                words = (prev ? ' and ' : '') + (ord ? ordinals[num] : few[num]);\n            } else if (num < 100) {\n                const tens = Math.floor(num / 10);\n                const remainder = num % 10;\n                words = (prev ? ' and ' : '') + decades[tens - 2];\n                if (remainder > 0) {\n                    words += '-' + lookup(remainder, false, ord);\n                } else if (ord) {\n                    words = words.substring(0, words.length - 1) + 'ieth';\n                }\n            } else if (num < 1000) {\n                const hundreds = Math.floor(num / 100);\n                const remainder = num % 100;\n                words = (prev ? ', ' : '') + few[hundreds] + ' Hundred';\n                if (remainder > 0) {\n                    words += lookup(remainder, true, ord);\n                } else if (ord) {\n                    words += 'th';\n                }\n            } else {\n                var mag = Math.floor(Math.log10(num) / 3);\n                if (mag > magnitudes.length) {\n                    mag = magnitudes.length; // the largest word\n                }\n                const factor = Math.pow(10, mag * 3);\n                const mant = Math.floor(num / factor);\n                const remainder = num - mant * factor;\n                words = (prev ? ', ' : '') + lookup(mant, false, false) + ' ' + magnitudes[mag - 1];\n                if (remainder > 0) {\n                    words += lookup(remainder, true, ord);\n                } else if (ord) {\n                    words += 'th';\n                }\n            }\n            return words;\n        };\n\n        var words = lookup(value, false, ordinal);\n        return words;\n    }\n\n    const wordValues = {};\n    few.forEach(function (word, index) {\n        wordValues[word.toLowerCase()] = index;\n    });\n    ordinals.forEach(function (word, index) {\n        wordValues[word.toLowerCase()] = index;\n    });\n    decades.forEach(function (word, index) {\n        const lword = word.toLowerCase();\n        wordValues[lword] = (index + 2) * 10;\n        wordValues[lword.substring(0, word.length - 1) + 'ieth'] = wordValues[lword];\n    });\n    wordValues.hundredth = 100;\n    magnitudes.forEach(function (word, index) {\n        const lword = word.toLowerCase();\n        const val = Math.pow(10, (index + 1) * 3);\n        wordValues[lword] = val;\n        wordValues[lword + 'th'] = val;\n    });\n\n    /**\n     * Converts a number in english words to numeric value\n     * @param {string} text - the number in words\n     * @returns {number} - the numeric value\n     */\n    function wordsToNumber(text) {\n        const parts = text.split(/,\\s|\\sand\\s|[\\s\\\\-]/);\n        const values = parts.map(part => wordValues[part]);\n        let segs = [0];\n        values.forEach(value => {\n            if (value < 100) {\n                let top = segs.pop();\n                if (top >= 1000) {\n                    segs.push(top);\n                    top = 0;\n                }\n                segs.push(top + value);\n            } else {\n                segs.push(segs.pop() * value);\n            }\n        });\n        const result = segs.reduce((a, b) => a + b, 0);\n        return result;\n    }\n\n    const romanNumerals = [\n        [1000, 'm'],\n        [900, 'cm'],\n        [500, 'd'],\n        [400, 'cd'],\n        [100, 'c'],\n        [90, 'xc'],\n        [50, 'l'],\n        [40, 'xl'],\n        [10, 'x'],\n        [9, 'ix'],\n        [5, 'v'],\n        [4, 'iv'],\n        [1, 'i']\n    ];\n\n    const romanValues = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1};\n\n    /**\n     * converts a number to roman numerals\n     * @param {number} value - the number\n     * @returns {string} - the number in roman numerals\n     */\n    function decimalToRoman(value) {\n        for (var index = 0; index < romanNumerals.length; index++) {\n            const numeral = romanNumerals[index];\n            if (value >= numeral[0]) {\n                return numeral[1] + decimalToRoman(value - numeral[0]);\n            }\n        }\n        return '';\n    }\n\n    /**\n     * converts roman numerals to a number\n     * @param {string} roman - roman number\n     * @returns {number} - the numeric value\n     */\n    function romanToDecimal(roman) {\n        var decimal = 0;\n        var max = 1;\n        for (var i = roman.length - 1; i >= 0; i--) {\n            const digit = roman[i];\n            const value = romanValues[digit];\n            if (value < max) {\n                decimal -= value;\n            } else {\n                max = value;\n                decimal += value;\n            }\n        }\n        return decimal;\n    }\n\n    /**\n     * converts a number to spreadsheet style letters\n     * @param {number} value - the number\n     * @param {string} aChar - the character representing the start of the sequence, e.g. 'A'\n     * @returns {string} - the letters\n     */\n    function decimalToLetters(value, aChar) {\n        var letters = [];\n        var aCode = aChar.charCodeAt(0);\n        while (value > 0) {\n            letters.unshift(String.fromCharCode((value - 1) % 26 + aCode));\n            value = Math.floor((value - 1) / 26);\n        }\n        return letters.join('');\n    }\n\n    /**\n     * converts spreadsheet style letters to a number\n     * @param {string} letters - the letters\n     * @param {string} aChar - the character representing the start of the sequence, e.g. 'A'\n     * @returns {number} - the numeric value\n     */\n    function lettersToDecimal(letters, aChar) {\n        var aCode = aChar.charCodeAt(0);\n        var decimal = 0;\n        for (var i = 0; i < letters.length; i++) {\n            decimal += (letters.charCodeAt(letters.length - i - 1) - aCode + 1) * Math.pow(26, i);\n        }\n        return decimal;\n    }\n\n    /**\n     * Formats an integer as specified by the XPath fn:format-integer function\n     * See https://www.w3.org/TR/xpath-functions-31/#func-format-integer\n     * @param {number} value - the number to be formatted\n     * @param {string} picture - the picture string that specifies the format\n     * @returns {string} - the formatted number\n     */\n    function formatInteger(value, picture) {\n        if (typeof value === 'undefined') {\n            return undefined;\n        }\n\n        value = Math.floor(value);\n\n        const format = analyseIntegerPicture(picture);\n        return _formatInteger(value, format);\n    }\n\n    const formats = {\n        DECIMAL: 'decimal',\n        LETTERS: 'letters',\n        ROMAN: 'roman',\n        WORDS: 'words',\n        SEQUENCE: 'sequence'\n    };\n\n    const tcase = {\n        UPPER: 'upper',\n        LOWER: 'lower',\n        TITLE: 'title'\n    };\n\n    /**\n     * formats an integer using a preprocessed representation of the picture string\n     * @param {number} value - the number to be formatted\n     * @param {object} format - the preprocessed representation of the pucture string\n     * @returns {string} - the formatted number\n     * @private\n     */\n    function _formatInteger(value, format) {\n        let formattedInteger;\n        const negative = value < 0;\n        value = Math.abs(value);\n        switch (format.primary) {\n            case formats.LETTERS:\n                formattedInteger = decimalToLetters(value, format.case === tcase.UPPER ? 'A' : 'a');\n                break;\n            case formats.ROMAN:\n                formattedInteger = decimalToRoman(value);\n                if (format.case === tcase.UPPER) {\n                    formattedInteger = formattedInteger.toUpperCase();\n                }\n                break;\n            case formats.WORDS:\n                formattedInteger = numberToWords(value, format.ordinal);\n                if (format.case === tcase.UPPER) {\n                    formattedInteger = formattedInteger.toUpperCase();\n                } else if (format.case === tcase.LOWER) {\n                    formattedInteger = formattedInteger.toLowerCase();\n                }\n                break;\n            case formats.DECIMAL:\n                formattedInteger = '' + value;\n                // TODO use functionPad\n                var padLength = format.mandatoryDigits - formattedInteger.length;\n                if (padLength > 0) {\n                    var padding = (new Array(padLength + 1)).join('0');\n                    formattedInteger = padding + formattedInteger;\n                }\n                if (format.zeroCode !== 0x30) {\n                    formattedInteger = stringToArray(formattedInteger).map(code => {\n                        return String.fromCodePoint(code.codePointAt(0) + format.zeroCode - 0x30);\n                    }).join('');\n                }\n                // insert the grouping-separator-signs, if any\n                if (format.regular) {\n                    const n = Math.floor((formattedInteger.length - 1) / format.groupingSeparators.position);\n                    for (let ii = n; ii > 0; ii--) {\n                        const pos = formattedInteger.length - ii * format.groupingSeparators.position;\n                        formattedInteger = formattedInteger.substr(0, pos) + format.groupingSeparators.character + formattedInteger.substr(pos);\n                    }\n                } else {\n                    format.groupingSeparators.reverse().forEach(separator => {\n                        const pos = formattedInteger.length - separator.position;\n                        formattedInteger = formattedInteger.substr(0, pos) + separator.character + formattedInteger.substr(pos);\n                    });\n                }\n\n                if (format.ordinal) {\n                    var suffix123 = {'1': 'st', '2': 'nd', '3': 'rd'};\n                    var lastDigit = formattedInteger[formattedInteger.length - 1];\n                    var suffix = suffix123[lastDigit];\n                    if (!suffix || (formattedInteger.length > 1 && formattedInteger[formattedInteger.length - 2] === '1')) {\n                        suffix = 'th';\n                    }\n                    formattedInteger = formattedInteger + suffix;\n                }\n                break;\n            case formats.SEQUENCE:\n                throw {\n                    code: 'D3130',\n                    value: format.token\n                };\n        }\n        if (negative) {\n            formattedInteger = '-' + formattedInteger;\n        }\n\n        return formattedInteger;\n    }\n\n    //TODO what about decimal groups in the unicode supplementary planes (surrogate pairs) ???\n    const decimalGroups = [0x30, 0x0660, 0x06F0, 0x07C0, 0x0966, 0x09E6, 0x0A66, 0x0AE6, 0x0B66, 0x0BE6, 0x0C66, 0x0CE6, 0x0D66, 0x0DE6, 0x0E50, 0x0ED0, 0x0F20, 0x1040, 0x1090, 0x17E0, 0x1810, 0x1946, 0x19D0, 0x1A80, 0x1A90, 0x1B50, 0x1BB0, 0x1C40, 0x1C50, 0xA620, 0xA8D0, 0xA900, 0xA9D0, 0xA9F0, 0xAA50, 0xABF0, 0xFF10];\n\n    /**\n     * preprocesses the picture string\n     * @param {string} picture - picture string\n     * @returns {{type: string, primary: string, case: string, ordinal: boolean}} - analysed picture\n     */\n    function analyseIntegerPicture(picture) {\n        const format = {\n            type: 'integer',\n            primary: formats.DECIMAL,\n            case: tcase.LOWER,\n            ordinal: false\n        };\n\n        let primaryFormat, formatModifier;\n        const semicolon = picture.lastIndexOf(';');\n        if (semicolon === -1) {\n            primaryFormat = picture;\n        } else {\n            primaryFormat = picture.substring(0, semicolon);\n            formatModifier = picture.substring(semicolon + 1);\n            if (formatModifier[0] === 'o') {\n                format.ordinal = true;\n            }\n        }\n\n        /* eslnt-disable-next no-fallthrough */\n        switch (primaryFormat) {\n            case 'A':\n                format.case = tcase.UPPER;\n            /* eslnt-disable-next-line no-fallthrough */\n            case 'a':\n                format.primary = formats.LETTERS;\n                break;\n            case 'I':\n                format.case = tcase.UPPER;\n            /* eslnt-disable-next-line no-fallthrough */\n            case 'i':\n                format.primary = formats.ROMAN;\n                break;\n            case 'W':\n                format.case = tcase.UPPER;\n                format.primary = formats.WORDS;\n                break;\n            case 'Ww':\n                format.case = tcase.TITLE;\n                format.primary = formats.WORDS;\n                break;\n            case 'w':\n                format.primary = formats.WORDS;\n                break;\n            default: {\n                // this is a decimal-digit-pattern if it contains a decimal digit (from any unicode decimal digit group)\n                let zeroCode = null;\n                let mandatoryDigits = 0;\n                let optionalDigits = 0;\n                let groupingSeparators = [];\n                let separatorPosition = 0;\n                const formatCodepoints = stringToArray(primaryFormat).map(c => c.codePointAt(0)).reverse(); // reverse the array to determine positions of grouping-separator-signs\n                formatCodepoints.forEach((codePoint) => {\n                    // step though each char in the picture to determine the digit group\n                    let digit = false;\n                    for (let ii = 0; ii < decimalGroups.length; ii++) {\n                        const group = decimalGroups[ii];\n                        if (codePoint >= group && codePoint <= group + 9) {\n                            // codepoint is part of this decimal group\n                            digit = true;\n                            mandatoryDigits++;\n                            separatorPosition++;\n                            if (zeroCode === null) {\n                                zeroCode = group;\n                            } else if (group !== zeroCode) {\n                                // error! different decimal groups in the same pattern\n                                throw {\n                                    code: 'D3131'\n                                };\n                            }\n                            break;\n                        }\n                    }\n                    if (!digit) {\n                        if (codePoint === 0x23) { // # - optional-digit-sign\n                            separatorPosition++;\n                            optionalDigits++;\n                        } else {\n                            // neither a decimal-digit-sign ot optional-digit-sign, assume it is a grouping-separator-sign\n                            groupingSeparators.push({\n                                position: separatorPosition,\n                                character: String.fromCodePoint(codePoint)\n                            });\n                        }\n                    }\n                });\n                if (mandatoryDigits > 0) {\n                    format.primary = formats.DECIMAL;\n                    // TODO validate decimal-digit-pattern\n\n                    // the decimal digit family (codepoint offset)\n                    format.zeroCode = zeroCode;\n                    // the number of mandatory digits\n                    format.mandatoryDigits = mandatoryDigits;\n                    // the number of optional digits\n                    format.optionalDigits = optionalDigits;\n                    // grouping separator template\n                    // are the grouping-separator-signs 'regular'?\n                    const regularRepeat = function (separators) {\n                        // are the grouping positions regular? i.e. same interval between each of them\n                        // is there at least one separator?\n                        if (separators.length === 0) {\n                            return 0;\n                        }\n                        // are all the characters the same?\n                        const sepChar = separators[0].character;\n                        for (let ii = 1; ii < separators.length; ii++) {\n                            if (separators[ii].character !== sepChar) {\n                                return 0;\n                            }\n                        }\n                        // are they equally spaced?\n                        const indexes = separators.map(separator => separator.position);\n                        const gcd = function (a, b) {\n                            return b === 0 ? a : gcd(b, a % b);\n                        };\n                        // find the greatest common divisor of all the positions\n                        const factor = indexes.reduce(gcd);\n                        // is every position separated by this divisor? If so, it's regular\n                        for (let index = 1; index <= indexes.length; index++) {\n                            if (indexes.indexOf(index * factor) === -1) {\n                                return 0;\n                            }\n                        }\n                        return factor;\n                    };\n\n                    const regular = regularRepeat(groupingSeparators);\n                    if (regular > 0) {\n                        format.regular = true;\n                        format.groupingSeparators = {\n                            position: regular,\n                            character: groupingSeparators[0].character\n                        };\n                    } else {\n                        format.regular = false;\n                        format.groupingSeparators = groupingSeparators;\n                    }\n\n                } else {\n                    // this is a 'numbering sequence' which the spec says is implementation-defined\n                    // this implementation doesn't support any numbering sequences at the moment.\n                    format.primary = formats.SEQUENCE;\n                    format.token = primaryFormat;\n                }\n            }\n        }\n\n        return format;\n    }\n\n    const defaultPresentationModifiers = {\n        Y: '1', M: '1', D: '1', d: '1', F: 'n', W: '1', w: '1', X: '1', x: '1', H: '1', h: '1',\n        P: 'n', m: '01', s: '01', f: '1', Z: '01:01', z: '01:01', C: 'n', E: 'n'\n    };\n\n    // Â§9.8.4.1 the format specifier is an array of string literals and variable markers\n    /**\n     * analyse the date-time picture string\n     * @param {string} picture - picture string\n     * @returns {{type: string, parts: Array}} - the analysed string\n     */\n    function analyseDateTimePicture(picture) {\n        var spec = [];\n        const format = {\n            type: 'datetime',\n            parts: spec\n        };\n        const addLiteral = function (start, end) {\n            if (end > start) {\n                let literal = picture.substring(start, end);\n                // replace any doubled ]] with single ]\n                // what if there are instances of single ']' ? - the spec doesn't say\n                literal = literal.split(']]').join(']');\n                spec.push({type: 'literal', value: literal});\n            }\n        };\n\n        var start = 0, pos = 0;\n        while (pos < picture.length) {\n            if (picture.charAt(pos) === '[') {\n                // check it's not a doubled [[\n                if (picture.charAt(pos + 1) === '[') {\n                    // literal [\n                    addLiteral(start, pos);\n                    spec.push({type: 'literal', value: '['});\n                    pos += 2;\n                    start = pos;\n                    continue;\n                }\n                // start of variable marker\n                // push the string literal (if there is one) onto the array\n                addLiteral(start, pos);\n                start = pos;\n                // search forward to closing ]\n                pos = picture.indexOf(']', start);\n                // TODO handle error case if pos === -1\n                if(pos === -1) {\n                    // error - no closing bracket\n                    throw {\n                        code: 'D3135'\n                    };\n                }\n                let marker = picture.substring(start + 1, pos);\n                // whitespace within a variable marker is ignored (i.e. remove it)\n                marker = marker.split(/\\s+/).join('');\n                var def = {\n                    type: 'marker',\n                    component: marker.charAt(0)  // 1. The component specifier is always present and is always a single letter.\n                };\n                var comma = marker.lastIndexOf(','); // 2. The width modifier may be recognized by the presence of a comma\n                var presMod; // the presentation modifiers\n                if (comma !== -1) {\n                    // Â§9.8.4.2 The Width Modifier\n                    const widthMod = marker.substring(comma + 1);\n                    const dash = widthMod.indexOf('-');\n                    let min, max;\n                    const parseWidth = function (wm) {\n                        if (typeof wm === 'undefined' || wm === '*') {\n                            return undefined;\n                        } else {\n                            // TODO validate wm is an unsigned int\n                            return parseInt(wm);\n                        }\n                    };\n                    if (dash === -1) {\n                        min = widthMod;\n                    } else {\n                        min = widthMod.substring(0, dash);\n                        max = widthMod.substring(dash + 1);\n                    }\n                    const widthDef = {\n                        min: parseWidth(min),\n                        max: parseWidth(max)\n                    };\n                    def.width = widthDef;\n                    presMod = marker.substring(1, comma);\n                } else {\n                    presMod = marker.substring(1);\n                }\n                if (presMod.length === 1) {\n                    def.presentation1 = presMod; // first presentation modifier\n                    //TODO validate the first presentation modifier - it's either N, n, Nn or it passes analyseIntegerPicture\n                } else if (presMod.length > 1) {\n                    var lastChar = presMod.charAt(presMod.length - 1);\n                    if ('atco'.indexOf(lastChar) !== -1) {\n                        def.presentation2 = lastChar;\n                        if (lastChar === 'o') {\n                            def.ordinal = true;\n                        }\n                        // 'c' means 'cardinal' and is the default (i.e. not 'ordinal')\n                        // 'a' & 't' are ignored (not sure of their relevance to English numbering)\n                        def.presentation1 = presMod.substring(0, presMod.length - 1);\n                    } else {\n                        def.presentation1 = presMod;\n                        //TODO validate the first presentation modifier - it's either N, n, Nn or it passes analyseIntegerPicture,\n                        // doesn't use ] as grouping separator, and if grouping separator is , then must have width modifier\n                    }\n                } else {\n                    // no presentation modifier specified - apply the default;\n                    def.presentation1 = defaultPresentationModifiers[def.component];\n                }\n                if (typeof def.presentation1 === 'undefined') {\n                    // unknown component specifier\n                    throw {\n                        code: 'D3132',\n                        value: def.component\n                    };\n                }\n                if (def.presentation1[0] === 'n') {\n                    def.names = tcase.LOWER;\n                } else if (def.presentation1[0] === 'N') {\n                    if (def.presentation1[1] === 'n') {\n                        def.names = tcase.TITLE;\n                    } else {\n                        def.names = tcase.UPPER;\n                    }\n                } else if ('YMDdFWwXxHhmsf'.indexOf(def.component) !== -1) {\n                    var integerPattern = def.presentation1;\n                    if (def.presentation2) {\n                        integerPattern += ';' + def.presentation2;\n                    }\n                    def.integerFormat = analyseIntegerPicture(integerPattern);\n                    if (def.width && def.width.min !== undefined) {\n                        if (def.integerFormat.mandatoryDigits < def.width.min) {\n                            def.integerFormat.mandatoryDigits = def.width.min;\n                        }\n                    }\n                    if ('YMD'.indexOf(def.component) !== -1) {\n                        // Â§9.8.4.4\n                        def.n = -1;\n                        if (def.width && def.width.max !== undefined) {\n                            def.n = def.width.max;\n                            def.integerFormat.mandatoryDigits = def.n;\n                        } else {\n                            var w = def.integerFormat.mandatoryDigits + def.integerFormat.optionalDigits;\n                            if (w >= 2) {\n                                def.n = w;\n                            }\n                        }\n                    }\n                }\n                if (def.component === 'Z' || def.component === 'z') {\n                    def.integerFormat = analyseIntegerPicture(def.presentation1);\n                }\n                spec.push(def);\n                start = pos + 1;\n            }\n            pos++;\n        }\n        addLiteral(start, pos);\n        return format;\n    }\n\n    const days = ['', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];\n    const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n    const millisInADay = 1000 * 60 * 60 * 24;\n\n    const startOfFirstWeek = function (ym) {\n        // ISO 8601 defines the first week of the year to be the week that contains the first Thursday\n        // XPath F&O extends this same definition for the first week of a month\n        // the week starts on a Monday - calculate the millis for the start of the first week\n        // millis for given 1st Jan of that year (at 00:00 UTC)\n        const jan1 = Date.UTC(ym.year, ym.month);\n        var dayOfJan1 = (new Date(jan1)).getUTCDay();\n        if (dayOfJan1 === 0) {\n            dayOfJan1 = 7;\n        }\n        // if Jan 1 is Fri, Sat or Sun, then add the number of days (in millis) to jan1 to get the start of week 1\n        return dayOfJan1 > 4 ? jan1 + (8 - dayOfJan1) * millisInADay : jan1 - (dayOfJan1 - 1) * millisInADay;\n    };\n\n    const yearMonth = function (year, month) {\n        return {\n            year: year,\n            month: month,\n            nextMonth: function () {\n                return (month === 11) ? yearMonth(year + 1, 0) : yearMonth(year, month + 1);\n            },\n            previousMonth: function () {\n                return (month === 0) ? yearMonth(year - 1, 11) : yearMonth(year, month - 1);\n            },\n            nextYear: function () {\n                return yearMonth(year + 1, month);\n            },\n            previousYear: function () {\n                return yearMonth(year - 1, month);\n            }\n        };\n    };\n\n    const deltaWeeks = function (start, end) {\n        return (end - start) / (millisInADay * 7) + 1;\n    };\n\n    const getDateTimeFragment = (date, component) => {\n        let componentValue;\n        switch (component) {\n            case 'Y': // year\n                componentValue = date.getUTCFullYear();\n                break;\n            case 'M': // month in year\n                componentValue = date.getUTCMonth() + 1;\n                break;\n            case 'D': // day in month\n                componentValue = date.getUTCDate();\n                break;\n            case 'd': { // day in year\n                // millis for given date (at 00:00 UTC)\n                const today = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());\n                // millis for given 1st Jan of that year (at 00:00 UTC)\n                const firstJan = Date.UTC(date.getUTCFullYear(), 0);\n                componentValue = (today - firstJan) / millisInADay + 1;\n                break;\n            }\n            case 'F': // day of week\n                componentValue = date.getUTCDay();\n                if (componentValue === 0) {\n                    // ISO 8601 defines days 1-7: Mon-Sun\n                    componentValue = 7;\n                }\n                break;\n            case 'W': { // week in year\n                const thisYear = yearMonth(date.getUTCFullYear(), 0);\n                const startOfWeek1 = startOfFirstWeek(thisYear);\n                const today = Date.UTC(thisYear.year, date.getUTCMonth(), date.getUTCDate());\n                let week = deltaWeeks(startOfWeek1, today);\n                if (week > 52) {\n                    // might be first week of the following year\n                    const startOfFollowingYear = startOfFirstWeek(thisYear.nextYear());\n                    if (today >= startOfFollowingYear) {\n                        week = 1;\n                    }\n                } else if (week < 1) {\n                    // must be end of the previous year\n                    const startOfPreviousYear = startOfFirstWeek(thisYear.previousYear());\n                    week = deltaWeeks(startOfPreviousYear, today);\n                }\n                componentValue = Math.floor(week);\n                break;\n            }\n            case 'w': { // week in month\n                const thisMonth = yearMonth(date.getUTCFullYear(), date.getUTCMonth());\n                const startOfWeek1 = startOfFirstWeek(thisMonth);\n                const today = Date.UTC(thisMonth.year, thisMonth.month, date.getUTCDate());\n                let week = deltaWeeks(startOfWeek1, today);\n                if (week > 4) {\n                    // might be first week of the following month\n                    const startOfFollowingMonth = startOfFirstWeek(thisMonth.nextMonth());\n                    if (today >= startOfFollowingMonth) {\n                        week = 1;\n                    }\n                } else if (week < 1) {\n                    // must be end of the previous month\n                    const startOfPreviousMonth = startOfFirstWeek(thisMonth.previousMonth());\n                    week = deltaWeeks(startOfPreviousMonth, today);\n                }\n                componentValue = Math.floor(week);\n                break;\n            }\n            case 'X': { // ISO week-numbering year\n                // Extension: The F&O spec says nothing about how to access the year associated with the week-of-the-year\n                // e.g. Sat 1 Jan 2005 is in the 53rd week of 2004.\n                // The 'W' component specifier gives 53, but 'Y' will give 2005.\n                // I propose to add 'X' as the component specifier to give the ISO week-numbering year (2004 in this example)\n                const thisYear = yearMonth(date.getUTCFullYear(), 0);\n                const startOfISOYear = startOfFirstWeek(thisYear);\n                const endOfISOYear = startOfFirstWeek(thisYear.nextYear());\n                const now = date.getTime();\n                if (now < startOfISOYear) {\n                    componentValue = thisYear.year - 1;\n                } else if (now >= endOfISOYear) {\n                    componentValue = thisYear.year + 1;\n                } else {\n                    componentValue = thisYear.year;\n                }\n                break;\n            }\n            case 'x': { // ISO week-numbering month\n                // Extension: The F&O spec says nothing about how to access the month associated with the week-of-the-month\n                // e.g. Sat 1 Jan 2005 is in the 5th week of December 2004.\n                // The 'w' component specifier gives 5, but 'W' will give January and 'Y' will give 2005.\n                // I propose to add 'x' as the component specifier to give the 'week-numbering' month (December in this example)\n                const thisMonth = yearMonth(date.getUTCFullYear(), date.getUTCMonth());\n                const startOfISOMonth = startOfFirstWeek(thisMonth);\n                const nextMonth = thisMonth.nextMonth();\n                const endOfISOMonth = startOfFirstWeek(nextMonth);\n                const now = date.getTime();\n                if (now < startOfISOMonth) {\n                    componentValue = thisMonth.previousMonth().month + 1;\n                } else if (now >= endOfISOMonth) {\n                    componentValue = nextMonth.month + 1;\n                } else {\n                    componentValue = thisMonth.month + 1;\n                }\n                break;\n            }\n            case 'H': // hour in day (24 hours)\n                componentValue = date.getUTCHours();\n                break;\n            case 'h': // hour in half-day (12 hours)\n                componentValue = date.getUTCHours();\n                componentValue = componentValue % 12;\n                if (componentValue === 0) {\n                    componentValue = 12;\n                }\n                break;\n            case 'P': // am/pm marker\n                componentValue = date.getUTCHours() >= 12 ? 'pm' : 'am';\n                break;\n            case 'm': // minute in hour\n                componentValue = date.getUTCMinutes();\n                break;\n            case 's': // second in minute\n                componentValue = date.getUTCSeconds();\n                break;\n            case 'f': // fractional seconds\n                componentValue = date.getUTCMilliseconds();\n                break;\n            case 'Z': // timezone\n            case 'z':\n                // since the date object is constructed from epoch millis, the TZ component is always be UTC.\n                break;\n            case 'C': // calendar name\n                componentValue = 'ISO';\n                break;\n            case 'E': // era\n                componentValue = 'ISO';\n                break;\n        }\n        return componentValue;\n    };\n\n    let iso8601Spec = null;\n\n    /**\n     * formats the date/time as specified by the XPath fn:format-dateTime function\n     * @param {number} millis - the timestamp to be formatted, in millis since the epoch\n     * @param {string} picture - the picture string that specifies the format\n     * @param {string} timezone - the timezone to use\n     * @returns {string} - the formatted timestamp\n     */\n    function formatDateTime(millis, picture, timezone) {\n        var offsetHours = 0;\n        var offsetMinutes = 0;\n\n        if (typeof timezone !== 'undefined') {\n            // parse the hour and minute offsets\n            // assume for now the format supplied is +hhmm\n            const offset = parseInt(timezone);\n            offsetHours = Math.floor(offset / 100);\n            offsetMinutes = offset % 100;\n        }\n\n        var formatComponent = function (date, markerSpec) {\n            var componentValue = getDateTimeFragment(date, markerSpec.component);\n\n            // Â§9.8.4.3 Formatting Integer-Valued Date/Time Components\n            if ('YMDdFWwXxHhms'.indexOf(markerSpec.component) !== -1) {\n                if (markerSpec.component === 'Y') {\n                    // Â§9.8.4.4 Formatting the Year Component\n                    if (markerSpec.n !== -1) {\n                        componentValue = componentValue % Math.pow(10, markerSpec.n);\n                    }\n                }\n                if (markerSpec.names) {\n                    if (markerSpec.component === 'M' || markerSpec.component === 'x') {\n                        componentValue = months[componentValue - 1];\n                    } else if (markerSpec.component === 'F') {\n                        componentValue = days[componentValue];\n                    } else {\n                        throw {\n                            code: 'D3133',\n                            value: markerSpec.component\n                        };\n                    }\n                    if (markerSpec.names === tcase.UPPER) {\n                        componentValue = componentValue.toUpperCase();\n                    } else if (markerSpec.names === tcase.LOWER) {\n                        componentValue = componentValue.toLowerCase();\n                    }\n                    if (markerSpec.width && componentValue.length > markerSpec.width.max) {\n                        componentValue = componentValue.substring(0, markerSpec.width.max);\n                    }\n                } else {\n                    componentValue = _formatInteger(componentValue, markerSpec.integerFormat);\n                }\n            } else if (markerSpec.component === 'f') {\n                // TODO Â§9.8.4.5 Formatting Fractional Seconds\n                componentValue = _formatInteger(componentValue, markerSpec.integerFormat);\n            } else if (markerSpec.component === 'Z' || markerSpec.component === 'z') {\n                // Â§9.8.4.6 Formatting timezones\n                const offset = offsetHours * 100 + offsetMinutes;\n                if (markerSpec.integerFormat.regular) {\n                    componentValue = _formatInteger(offset, markerSpec.integerFormat);\n                } else {\n                    const numDigits = markerSpec.integerFormat.mandatoryDigits;\n                    if (numDigits === 1 || numDigits === 2) {\n                        componentValue = _formatInteger(offsetHours, markerSpec.integerFormat);\n                        if (offsetMinutes !== 0) {\n                            componentValue += ':' + formatInteger(offsetMinutes, '00');\n                        }\n                    } else if (numDigits === 3 || numDigits === 4) {\n                        componentValue = _formatInteger(offset, markerSpec.integerFormat);\n                    } else {\n                        throw {\n                            code: 'D3134',\n                            value: numDigits\n                        };\n                    }\n                }\n                if (offset >= 0) {\n                    componentValue = '+' + componentValue;\n                }\n                if (markerSpec.component === 'z') {\n                    componentValue = 'GMT' + componentValue;\n                }\n                if (offset === 0 && markerSpec.presentation2 === 't') {\n                    componentValue = 'Z';\n                }\n            } else if (markerSpec.component === 'P') {\n                // Â§9.8.4.7 Formatting Other Components\n                // Formatting P for am/pm\n                // getDateTimeFragment() always returns am/pm lower case so check for UPPER here\n                if (markerSpec.names === tcase.UPPER) {\n                    componentValue = componentValue.toUpperCase();\n                }\n            }\n            return componentValue;\n        };\n\n        let formatSpec;\n        if(typeof picture === 'undefined') {\n            // default to ISO 8601 format\n            if (iso8601Spec === null) {\n                iso8601Spec = analyseDateTimePicture('[Y0001]-[M01]-[D01]T[H01]:[m01]:[s01].[f001][Z01:01t]');\n            }\n            formatSpec = iso8601Spec;\n        } else {\n            formatSpec = analyseDateTimePicture(picture);\n        }\n\n        const offsetMillis = (60 * offsetHours + offsetMinutes) * 60 * 1000;\n        const dateTime = new Date(millis + offsetMillis);\n\n        let result = '';\n        formatSpec.parts.forEach(function (part) {\n            if (part.type === 'literal') {\n                result += part.value;\n            } else {\n                result += formatComponent(dateTime, part);\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Generate a regex to parse integers or timestamps\n     * @param {object} formatSpec - object representing the format\n     * @returns {object} - regex\n     */\n    function generateRegex(formatSpec) {\n        var matcher = {};\n        if (formatSpec.type === 'datetime') {\n            matcher.type = 'datetime';\n            matcher.parts = formatSpec.parts.map(function (part) {\n                var res = {};\n                if (part.type === 'literal') {\n                    res.regex = part.value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n                } else if (part.component === 'Z' || part.component === 'z') {\n                    // timezone\n                    let separator;\n                    if (!Array.isArray(part.integerFormat.groupingSeparators)) {\n                        separator = part.integerFormat.groupingSeparators;\n                    }\n                    res.regex = '';\n                    if (part.component === 'z') {\n                        res.regex = 'GMT';\n                    }\n                    res.regex += '[-+][0-9]+';\n                    if (separator) {\n                        res.regex += separator.character + '[0-9]+';\n                    }\n                    res.parse = function(value) {\n                        if (part.component === 'z') {\n                            value = value.substring(3); // remove the leading GMT\n                        }\n                        let offsetHours = 0, offsetMinutes = 0;\n                        if (separator) {\n                            offsetHours = Number.parseInt(value.substring(0, value.indexOf(separator.character)));\n                            offsetMinutes = Number.parseInt(value.substring(value.indexOf(separator.character) + 1));\n                        } else {\n                            // depends on number of digits\n                            const numdigits = value.length - 1;\n                            if (numdigits <= 2) {\n                                // just hour offset\n                                offsetHours = Number.parseInt(value);\n                            } else {\n                                offsetHours = Number.parseInt(value.substring(0, 3));\n                                offsetMinutes = Number.parseInt(value.substring(3));\n                            }\n                        }\n                        return offsetHours * 60 + offsetMinutes;\n                    };\n                } else if (part.integerFormat) {\n                    part.integerFormat.n = part.n;\n                    res = generateRegex(part.integerFormat);\n                } else {\n                    // must be a month or day name\n                    res.regex = '[a-zA-Z]+';\n                    var lookup = {};\n                    if (part.component === 'M' || part.component === 'x') {\n                        // months\n                        months.forEach(function (name, index) {\n                            if (part.width && part.width.max) {\n                                lookup[name.substring(0, part.width.max)] = index + 1;\n                            } else {\n                                lookup[name] = index + 1;\n                            }\n                        });\n                    } else if (part.component === 'F') {\n                        // days\n                        days.forEach(function (name, index) {\n                            if (index > 0) {\n                                if (part.width && part.width.max) {\n                                    lookup[name.substring(0, part.width.max)] = index;\n                                } else {\n                                    lookup[name] = index;\n                                }\n                            }\n                        });\n                    } else if (part.component === 'P') {\n                        lookup = {'am': 0, 'AM': 0, 'pm': 1, 'PM': 1};\n                    } else {\n                        // unsupported 'name' option for this component\n                        throw {\n                            code: 'D3133',\n                            value: part.component\n                        };\n                    }\n                    res.parse = function (value) {\n                        return lookup[value];\n                    };\n                }\n                res.component = part.component;\n                return res;\n            });\n        } else { // type === 'integer'\n            matcher.type = 'integer';\n            const isUpper = formatSpec.case === tcase.UPPER;\n            let occurrences;\n            if(formatSpec.n && formatSpec.n > 0){\n                if(formatSpec.optionalDigits === 0){\n                    occurrences = `{${formatSpec.n}}`;\n                } else {\n                    occurrences = `{${formatSpec.n - formatSpec.optionalDigits},${formatSpec.n}}`;\n                }\n            } else {\n                occurrences = '+';\n            }\n\n            switch (formatSpec.primary) {\n                case formats.LETTERS:\n                    matcher.regex = isUpper ? '[A-Z]+' : '[a-z]+';\n                    matcher.parse = function (value) {\n                        return lettersToDecimal(value, isUpper ? 'A' : 'a');\n                    };\n                    break;\n                case formats.ROMAN:\n                    matcher.regex = isUpper ? '[MDCLXVI]+' : '[mdclxvi]+';\n                    matcher.parse = function (value) {\n                        return romanToDecimal(isUpper ? value : value.toUpperCase());\n                    };\n                    break;\n                case formats.WORDS:\n                    matcher.regex = '(?:' + Object.keys(wordValues).concat('and', '[\\\\-, ]').join('|') + ')+';\n                    matcher.parse = function (value) {\n                        return wordsToNumber(value.toLowerCase());\n                    };\n                    break;\n                case formats.DECIMAL:\n                    matcher.regex = `[0-9]${occurrences}`;\n                    if (formatSpec.ordinal) {\n                        // ordinals\n                        matcher.regex += '(?:th|st|nd|rd)';\n                    }\n                    matcher.parse = function (value) {\n                        let digits = value;\n                        if (formatSpec.ordinal) {\n                            // strip off the suffix\n                            digits = value.substring(0, value.length - 2);\n                        }\n                        // strip out the separators\n                        if (formatSpec.regular) {\n                            digits = digits.split(',').join('');\n                        } else {\n                            formatSpec.groupingSeparators.forEach(sep => {\n                                digits = digits.split(sep.character).join('');\n                            });\n                        }\n                        if (formatSpec.zeroCode !== 0x30) {\n                            // apply offset\n                            digits = digits.split('').map(char => String.fromCodePoint(char.codePointAt(0) - formatSpec.zeroCode + 0x30)).join('');\n                        }\n                        return parseInt(digits);\n                    };\n                    break;\n                case formats.SEQUENCE:\n                    throw {\n                        code: 'D3130',\n                        value: formatSpec.token\n                    };\n            }\n\n        }\n        return matcher;\n    }\n\n    /**\n     * parse a string containing an integer as specified by the picture string\n     * @param {string} value - the string to parse\n     * @param {string} picture - the picture string\n     * @returns {number} - the parsed number\n     */\n    function parseInteger(value, picture) {\n        if (typeof value === 'undefined') {\n            return undefined;\n        }\n\n        const formatSpec = analyseIntegerPicture(picture);\n        const matchSpec = generateRegex(formatSpec);\n        //const fullRegex = '^' + matchSpec.regex + '$';\n        //const matcher = new RegExp(fullRegex);\n        // TODO validate input based on the matcher regex\n        const result = matchSpec.parse(value);\n        return result;\n    }\n\n    /**\n     * parse a string containing a timestamp as specified by the picture string\n     * @param {string} timestamp - the string to parse\n     * @param {string} picture - the picture string\n     * @returns {number} - the parsed timestamp in millis since the epoch\n     */\n    function parseDateTime(timestamp, picture) {\n        const formatSpec = analyseDateTimePicture(picture);\n        const matchSpec = generateRegex(formatSpec);\n        const fullRegex = '^' + matchSpec.parts.map(part => '(' + part.regex + ')').join('') + '$';\n\n        const matcher = new RegExp(fullRegex, 'i'); // TODO can cache this against the picture\n        var info = matcher.exec(timestamp);\n        if (info !== null) {\n            // validate what we've just parsed - do we have enough information to create a timestamp?\n            // rules:\n            // The date is specified by one of:\n            //    {Y, M, D}    (dateA)\n            // or {Y, d}       (dateB)\n            // or {Y, x, w, F} (dateC)\n            // or {X, W, F}    (dateD)\n            // The time is specified by one of:\n            //    {H, m, s, f}    (timeA)\n            // or {P, h, m, s, f} (timeB)\n            // All sets can have an optional Z\n            // To create a timestamp (epoch millis) we need both date and time, but we can default missing\n            // information according to the following rules:\n            // - line up one combination of the above from date, and one from time, most significant value (MSV) to least significant (LSV\n            // - for the values that have been captured, if there are any gaps between MSV and LSV, then throw an error\n            //     (e.g.) if hour and seconds, but not minutes is given - throw\n            //     (e.g.) if month, hour and minutes, but not day-of-month is given - throw\n            // - anything right of the LSV should be defaulted to zero\n            //     (e.g.) if hour and minutes given, default seconds and fractional seconds to zero\n            //     (e.g.) if date only given, default the time to 0:00:00.000 (midnight)\n            // - anything left of the MSV should be defaulted to the value of that component returned by $now()\n            //     (e.g.) if time only given, default the date to today\n            //     (e.g.) if month and date given, default to this year (and midnight, by previous rule)\n            //   -- default values for X, x, W, w, F will be derived from the values returned by $now()\n\n            // implement the above rules\n            // determine which of the above date/time combinations we have by using bit masks\n\n            //        Y X M x W w d D F P H h m s f Z\n            // dateA  1 0 1 0 0 0 0 1 ?                     0 - must not appear\n            // dateB  1 0 0 0 0 0 1 0 ?                     1 - can appear - relevant\n            // dateC  0 1 0 1 0 1 0 0 1                     ? - can appear - ignored\n            // dateD  0 1 0 0 1 0 0 0 1\n            // timeA                    0 1 0 1 1 1\n            // timeB                    1 0 1 1 1 1\n\n            // create bitmasks based on the above\n            //    date mask             YXMxWwdD\n            const dmA = 161;  // binary 10100001\n            const dmB = 130;  // binary 10000010\n            const dmC = 84;   // binary 01010100\n            const dmD = 72;   // binary 01001000\n            //    time mask             PHhmsf\n            const tmA = 23;   // binary 010111\n            const tmB = 47;   // binary 101111\n\n            const components = {};\n            for (let i = 1; i < info.length; i++) {\n                const mpart = matchSpec.parts[i - 1];\n                if (mpart.parse) {\n                    components[mpart.component] = mpart.parse(info[i]);\n                }\n            }\n\n            if(Object.getOwnPropertyNames(components).length === 0) {\n                // nothing specified\n                return undefined;\n            }\n\n            let mask = 0;\n\n            const shift = bit => {\n                mask <<= 1;\n                mask += bit ? 1 : 0;\n            };\n\n            const isType = type => {\n                // shouldn't match any 0's, must match at least one 1\n                return !(~type & mask) && !!(type & mask);\n            };\n\n            'YXMxWwdD'.split('').forEach(part => shift(components[part]));\n\n            const dateA = isType(dmA);\n            const dateB = !dateA && isType(dmB);\n            const dateC = isType(dmC);\n            const dateD = !dateC && isType(dmD);\n\n            mask = 0;\n            'PHhmsf'.split('').forEach(part => shift(components[part]));\n\n            const timeA = isType(tmA);\n            const timeB = !timeA && isType(tmB);\n\n            // should only be zero or one date type and zero or one time type\n\n            const dateComps = dateB ? 'YD' : dateC ? 'XxwF' : dateD? 'XWF' : 'YMD';\n            const timeComps = timeB ? 'Phmsf' : 'Hmsf';\n\n            const comps = dateComps + timeComps;\n\n            // step through the candidate parts from most significant to least significant\n            // default the most significant unspecified parts to current timestamp component\n            // default the least significant unspecified parts to zero\n            // if any gaps in between the specified parts, throw an error\n\n            const now = this.environment.timestamp; // must get the fixed timestamp from jsonata\n\n            let startSpecified = false;\n            let endSpecified = false;\n            comps.split('').forEach(part => {\n                if(typeof components[part] === 'undefined') {\n                    if(startSpecified) {\n                        // past the specified block - default to zero\n                        components[part] = ('MDd'.indexOf(part) !== -1) ? 1 : 0;\n                        endSpecified = true;\n                    } else {\n                        // haven't hit the specified block yet, default to current timestamp\n                        components[part] = getDateTimeFragment(now, part);\n                    }\n                } else {\n                    startSpecified = true;\n                    if(endSpecified) {\n                        throw {\n                            code: 'D3136'\n                        };\n                    }\n                }\n            });\n\n            // validate and fill in components\n            if (components.M > 0) {\n                components.M -= 1;  // Date.UTC requires a zero-indexed month\n            } else {\n                components.M = 0; // default to January\n            }\n            if (dateB) {\n                // millis for given 1st Jan of that year (at 00:00 UTC)\n                const firstJan = Date.UTC(components.Y, 0);\n                const offsetMillis = (components.d - 1) * 1000 * 60 * 60 * 24;\n                const derivedDate = new Date(firstJan + offsetMillis);\n                components.M = derivedDate.getUTCMonth();\n                components.D = derivedDate.getUTCDate();\n            }\n            if (dateC) {\n                // TODO implement this\n                // parsing this format not currently supported\n                throw {\n                    code: 'D3136'\n                };\n            }\n            if (dateD) {\n                // TODO implement this\n                // parsing this format (ISO week date) not currently supported\n                throw {\n                    code: 'D3136'\n                };\n            }\n            if (timeB) {\n                // 12hr to 24hr\n                components.H = components.h === 12 ? 0 : components.h;\n                if (components.P === 1) {\n                    components.H += 12;\n                }\n            }\n\n            var millis = Date.UTC(components.Y, components.M, components.D, components.H, components.m, components.s, components.f);\n            if(components.Z || components.z) {\n                // adjust for timezone\n                millis -= (components.Z || components.z) * 60 * 1000;\n            }\n            return millis;\n        }\n    }\n\n    // Regular expression to match an ISO 8601 formatted timestamp\n    var iso8601regex = new RegExp('^\\\\d{4}(-[01]\\\\d)*(-[0-3]\\\\d)*(T[0-2]\\\\d:[0-5]\\\\d:[0-5]\\\\d)*(\\\\.\\\\d+)?([+-][0-2]\\\\d:?[0-5]\\\\d|Z)?$');\n\n    /**\n     * Converts an ISO 8601 timestamp to milliseconds since the epoch\n     *\n     * @param {string} timestamp - the timestamp to be converted\n     * @param {string} [picture] - the picture string defining the format of the timestamp (defaults to ISO 8601)\n     * @returns {Number} - milliseconds since the epoch\n     */\n    function toMillis(timestamp, picture) {\n        // undefined inputs always return undefined\n        if(typeof timestamp === 'undefined') {\n            return undefined;\n        }\n\n        if(typeof picture === 'undefined') {\n            if (!iso8601regex.test(timestamp)) {\n                throw {\n                    stack: (new Error()).stack,\n                    code: \"D3110\",\n                    value: timestamp\n                };\n            }\n\n            return Date.parse(timestamp);\n        } else {\n            return parseDateTime.call(this, timestamp, picture);\n        }\n    }\n\n    /**\n     * Converts milliseconds since the epoch to an ISO 8601 timestamp\n     * @param {Number} millis - milliseconds since the epoch to be converted\n     * @param {string} [picture] - the picture string defining the format of the timestamp (defaults to ISO 8601)\n     * @param {string} [timezone] - the timezone to format the timestamp in (defaults to UTC)\n     * @returns {String} - the formatted timestamp\n     */\n    function fromMillis(millis, picture, timezone) {\n        // undefined inputs always return undefined\n        if(typeof millis === 'undefined') {\n            return undefined;\n        }\n\n        return formatDateTime.call(this, millis, picture, timezone);\n    }\n\n    return {\n        formatInteger, parseInteger, fromMillis, toMillis\n    };\n})();\n\nmodule.exports = dateTime;\n\n},{\"./utils\":6}],2:[function(require,module,exports){\n(function (global){(function (){\n/**\n * Â© Copyright IBM Corp. 2016, 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nvar utils = require('./utils');\n\nconst functions = (() => {\n    'use strict';\n\n    var isNumeric = utils.isNumeric;\n    var isArrayOfStrings = utils.isArrayOfStrings;\n    var isArrayOfNumbers = utils.isArrayOfNumbers;\n    var createSequence = utils.createSequence;\n    var isSequence = utils.isSequence;\n    var isFunction = utils.isFunction;\n    var isLambda = utils.isLambda;\n    var isPromise = utils.isPromise;\n    var getFunctionArity = utils.getFunctionArity;\n    var deepEquals = utils.isDeepEqual;\n    var stringToArray = utils.stringToArray;\n\n    /**\n     * Sum function\n     * @param {Object} args - Arguments\n     * @returns {number} Total value of arguments\n     */\n    function sum(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined') {\n            return undefined;\n        }\n\n        var total = 0;\n        args.forEach(function (num) {\n            total += num;\n        });\n        return total;\n    }\n\n    /**\n     * Count function\n     * @param {Object} args - Arguments\n     * @returns {number} Number of elements in the array\n     */\n    function count(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined') {\n            return 0;\n        }\n\n        return args.length;\n    }\n\n    /**\n     * Max function\n     * @param {Object} args - Arguments\n     * @returns {number} Max element in the array\n     */\n    function max(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined' || args.length === 0) {\n            return undefined;\n        }\n\n        return Math.max.apply(Math, args);\n    }\n\n    /**\n     * Min function\n     * @param {Object} args - Arguments\n     * @returns {number} Min element in the array\n     */\n    function min(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined' || args.length === 0) {\n            return undefined;\n        }\n\n        return Math.min.apply(Math, args);\n    }\n\n    /**\n     * Average function\n     * @param {Object} args - Arguments\n     * @returns {number} Average element in the array\n     */\n    function average(args) {\n        // undefined inputs always return undefined\n        if (typeof args === 'undefined' || args.length === 0) {\n            return undefined;\n        }\n\n        var total = 0;\n        args.forEach(function (num) {\n            total += num;\n        });\n        return total / args.length;\n    }\n\n    /**\n     * Stringify arguments\n     * @param {Object} arg - Arguments\n     * @param {boolean} [prettify] - Pretty print the result\n     * @returns {String} String from arguments\n     */\n    function string(arg, prettify = false) {\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        var str;\n\n        if (typeof arg === 'string') {\n            // already a string\n            str = arg;\n        } else if (isFunction(arg)) {\n            // functions (built-in and lambda convert to empty string\n            str = '';\n        } else if (typeof arg === 'number' && !isFinite(arg)) {\n            throw {\n                code: \"D3001\",\n                value: arg,\n                stack: (new Error()).stack\n            };\n        } else {\n            var space = prettify ? 2 : 0;\n            if(Array.isArray(arg) && arg.outerWrapper) {\n                arg = arg[0];\n            }\n            str = JSON.stringify(arg, function (key, val) {\n                return (typeof val !== 'undefined' && val !== null && val.toPrecision && isNumeric(val)) ? Number(val.toPrecision(15)) :\n                    (val && isFunction(val)) ? '' : val;\n            }, space);\n        }\n        return str;\n    }\n\n    /**\n     * Create substring based on character number and length\n     * @param {String} str - String to evaluate\n     * @param {Integer} start - Character number to start substring\n     * @param {Integer} [length] - Number of characters in substring\n     * @returns {string|*} Substring\n     */\n    function substring(str, start, length) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var strArray = stringToArray(str);\n        var strLength = strArray.length;\n\n        if (strLength + start < 0) {\n            start = 0;\n        }\n\n        if (typeof length !== 'undefined') {\n            if (length <= 0) {\n                return '';\n            }\n            var end = start >= 0 ? start + length : strLength + start + length;\n            return strArray.slice(start, end).join('');\n        }\n\n        return strArray.slice(start).join('');\n    }\n\n    /**\n     * Create substring up until a character\n     * @param {String} str - String to evaluate\n     * @param {String} chars - Character to define substring boundary\n     * @returns {*} Substring\n     */\n    function substringBefore(str, chars) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var pos = str.indexOf(chars);\n        if (pos > -1) {\n            return str.substr(0, pos);\n        } else {\n            return str;\n        }\n    }\n\n    /**\n     * Create substring after a character\n     * @param {String} str - String to evaluate\n     * @param {String} chars - Character to define substring boundary\n     * @returns {*} Substring\n     */\n    function substringAfter(str, chars) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var pos = str.indexOf(chars);\n        if (pos > -1) {\n            return str.substr(pos + chars.length);\n        } else {\n            return str;\n        }\n    }\n\n    /**\n     * Lowercase a string\n     * @param {String} str - String to evaluate\n     * @returns {string} Lowercase string\n     */\n    function lowercase(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        return str.toLowerCase();\n    }\n\n    /**\n     * Uppercase a string\n     * @param {String} str - String to evaluate\n     * @returns {string} Uppercase string\n     */\n    function uppercase(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        return str.toUpperCase();\n    }\n\n    /**\n     * length of a string\n     * @param {String} str - string\n     * @returns {Number} The number of characters in the string\n     */\n    function length(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        return stringToArray(str).length;\n    }\n\n    /**\n     * Normalize and trim whitespace within a string\n     * @param {string} str - string to be trimmed\n     * @returns {string} - trimmed string\n     */\n    function trim(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // normalize whitespace\n        var result = str.replace(/[ \\t\\n\\r]+/gm, ' ');\n        if (result.charAt(0) === ' ') {\n            // strip leading space\n            result = result.substring(1);\n        }\n        if (result.charAt(result.length - 1) === ' ') {\n            // strip trailing space\n            result = result.substring(0, result.length - 1);\n        }\n        return result;\n    }\n\n    /**\n     * Pad a string to a minimum width by adding characters to the start or end\n     * @param {string} str - string to be padded\n     * @param {number} width - the minimum width; +ve pads to the right, -ve pads to the left\n     * @param {string} [char] - the pad character(s); defaults to ' '\n     * @returns {string} - padded string\n     */\n    function pad(str, width, char) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        if (typeof char === 'undefined' || char.length === 0) {\n            char = ' ';\n        }\n\n        var result;\n        var padLength = Math.abs(width) - length(str);\n        if (padLength > 0) {\n            var padding = (new Array(padLength + 1)).join(char);\n            if (char.length > 1) {\n                padding = substring(padding, 0, padLength);\n            }\n            if (width > 0) {\n                result = str + padding;\n            } else {\n                result = padding + str;\n            }\n        } else {\n            result = str;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate the matcher function against the str arg\n     *\n     * @param {*} matcher - matching function (native or lambda)\n     * @param {string} str - the string to match against\n     * @returns {object} - structure that represents the match(es)\n     */\n    async function evaluateMatcher(matcher, str) {\n        var result = matcher.apply(this, [str]); // eslint-disable-line no-useless-call\n        if(isPromise(result)) {\n            result = await result;\n        }\n        if(result && !(typeof result.start === 'number' || result.end === 'number' || Array.isArray(result.groups) || isFunction(result.next))) {\n            // the matcher function didn't return the correct structure\n            throw {\n                code: \"T1010\",\n                stack: (new Error()).stack,\n            };\n        }\n        return result;\n    }\n\n    /**\n     * Tests if the str contains the token\n     * @param {String} str - string to test\n     * @param {String} token - substring or regex to find\n     * @returns {Boolean} - true if str contains token\n     */\n    async function contains(str, token) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var result;\n\n        if (typeof token === 'string') {\n            result = (str.indexOf(token) !== -1);\n        } else {\n            var matches = await evaluateMatcher(token, str);\n            result = (typeof matches !== 'undefined');\n        }\n\n        return result;\n    }\n\n    /**\n     * Match a string with a regex returning an array of object containing details of each match\n     * @param {String} str - string\n     * @param {String} regex - the regex applied to the string\n     * @param {Integer} [limit] - max number of matches to return\n     * @returns {Array} The array of match objects\n     */\n    async function match(str, regex, limit) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // limit, if specified, must be a non-negative number\n        if (limit < 0) {\n            throw {\n                stack: (new Error()).stack,\n                value: limit,\n                code: 'D3040',\n                index: 3\n            };\n        }\n\n        var result = createSequence();\n\n        if (typeof limit === 'undefined' || limit > 0) {\n            var count = 0;\n            var matches = await evaluateMatcher(regex, str);\n            if (typeof matches !== 'undefined') {\n                while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {\n                    result.push({\n                        match: matches.match,\n                        index: matches.start,\n                        groups: matches.groups\n                    });\n                    matches = await evaluateMatcher(matches.next);\n                    count++;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Match a string with a regex returning an array of object containing details of each match\n     * @param {String} str - string\n     * @param {String} pattern - the substring/regex applied to the string\n     * @param {String} replacement - text to replace the matched substrings\n     * @param {Integer} [limit] - max number of matches to return\n     * @returns {Array} The array of match objects\n     */\n    async function replace(str, pattern, replacement, limit) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        var self = this;\n\n        // pattern cannot be an empty string\n        if (pattern === '') {\n            throw {\n                code: \"D3010\",\n                stack: (new Error()).stack,\n                value: pattern,\n                index: 2\n            };\n        }\n\n        // limit, if specified, must be a non-negative number\n        if (limit < 0) {\n            throw {\n                code: \"D3011\",\n                stack: (new Error()).stack,\n                value: limit,\n                index: 4\n            };\n        }\n\n        var replacer;\n        if (typeof replacement === 'string') {\n            replacer = function (regexMatch) {\n                var substitute = '';\n                // scan forward, copying the replacement text into the substitute string\n                // and replace any occurrence of $n with the values matched by the regex\n                var position = 0;\n                var index = replacement.indexOf('$', position);\n                while (index !== -1 && position < replacement.length) {\n                    substitute += replacement.substring(position, index);\n                    position = index + 1;\n                    var dollarVal = replacement.charAt(position);\n                    if (dollarVal === '$') {\n                        // literal $\n                        substitute += '$';\n                        position++;\n                    } else if (dollarVal === '0') {\n                        substitute += regexMatch.match;\n                        position++;\n                    } else {\n                        var maxDigits;\n                        if (regexMatch.groups.length === 0) {\n                            // no sub-matches; any $ followed by a digit will be replaced by an empty string\n                            maxDigits = 1;\n                        } else {\n                            // max number of digits to parse following the $\n                            maxDigits = Math.floor(Math.log(regexMatch.groups.length) * Math.LOG10E) + 1;\n                        }\n                        index = parseInt(replacement.substring(position, position + maxDigits), 10);\n                        if (maxDigits > 1 && index > regexMatch.groups.length) {\n                            index = parseInt(replacement.substring(position, position + maxDigits - 1), 10);\n                        }\n                        if (!isNaN(index)) {\n                            if (regexMatch.groups.length > 0) {\n                                var submatch = regexMatch.groups[index - 1];\n                                if (typeof submatch !== 'undefined') {\n                                    substitute += submatch;\n                                }\n                            }\n                            position += index.toString().length;\n                        } else {\n                            // not a capture group, treat the $ as literal\n                            substitute += '$';\n                        }\n                    }\n                    index = replacement.indexOf('$', position);\n                }\n                substitute += replacement.substring(position);\n                return substitute;\n            };\n        } else {\n            replacer = replacement;\n        }\n\n        var result = '';\n        var position = 0;\n\n        if (typeof limit === 'undefined' || limit > 0) {\n            var count = 0;\n            if (typeof pattern === 'string') {\n                var index = str.indexOf(pattern, position);\n                while (index !== -1 && (typeof limit === 'undefined' || count < limit)) {\n                    result += str.substring(position, index);\n                    result += replacement;\n                    position = index + pattern.length;\n                    count++;\n                    index = str.indexOf(pattern, position);\n                }\n                result += str.substring(position);\n            } else {\n                var matches = await evaluateMatcher(pattern, str);\n                if (typeof matches !== 'undefined') {\n                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {\n                        result += str.substring(position, matches.start);\n                        var replacedWith = replacer.apply(self, [matches]);\n                        if (isPromise(replacedWith)) {\n                            replacedWith = await replacedWith;\n                        }\n                        // check replacedWith is a string\n                        if (typeof replacedWith === 'string') {\n                            result += replacedWith;\n                        } else {\n                            // not a string - throw error\n                            throw {\n                                code: \"D3012\",\n                                stack: (new Error()).stack,\n                                value: replacedWith\n                            };\n                        }\n                        position = matches.start + matches.match.length;\n                        count++;\n                        matches = await evaluateMatcher(matches.next);\n                    }\n                    result += str.substring(position);\n                } else {\n                    result = str;\n                }\n            }\n        } else {\n            result = str;\n        }\n\n        return result;\n    }\n\n    /**\n     * Base64 encode a string\n     * @param {String} str - string\n     * @returns {String} Base 64 encoding of the binary data\n     */\n    function base64encode(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n        // Use btoa in a browser, or Buffer in Node.js\n\n        var btoa = typeof window !== 'undefined' ?\n            /* istanbul ignore next */ window.btoa :\n            function (str) {\n                // Simply doing `new Buffer` at this point causes Browserify to pull\n                // in the entire Buffer browser library, which is large and unnecessary.\n                // Using `global.Buffer` defeats this.\n                return new global.Buffer.from(str, 'binary').toString('base64'); // eslint-disable-line new-cap\n            };\n        return btoa(str);\n    }\n\n    /**\n     * Base64 decode a string\n     * @param {String} str - string\n     * @returns {String} Base 64 encoding of the binary data\n     */\n    function base64decode(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n        // Use btoa in a browser, or Buffer in Node.js\n        var atob = typeof window !== 'undefined' ?\n            /* istanbul ignore next */ window.atob :\n            function (str) {\n                // Simply doing `new Buffer` at this point causes Browserify to pull\n                // in the entire Buffer browser library, which is large and unnecessary.\n                // Using `global.Buffer` defeats this.\n                return new global.Buffer.from(str, 'base64').toString('binary'); // eslint-disable-line new-cap\n            };\n        return atob(str);\n    }\n\n    /**\n     * Encode a string into a component for a url\n     * @param {String} str - String to encode\n     * @returns {string} Encoded string\n     */\n    function encodeUrlComponent(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // Catch URIErrors when URI sequence is malformed\n        var returnVal;\n        try {\n            returnVal = encodeURIComponent(str);\n        } catch (e) {\n            throw {\n                code: \"D3140\",\n                stack: (new Error()).stack,\n                value: str,\n                functionName: \"encodeUrlComponent\"\n            };\n        }\n        return returnVal;\n    }\n\n    /**\n     * Encode a string into a url\n     * @param {String} str - String to encode\n     * @returns {string} Encoded string\n     */\n    function encodeUrl(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // Catch URIErrors when URI sequence is malformed\n        var returnVal;\n        try {\n            returnVal = encodeURI(str);\n        } catch (e) {\n            throw {\n                code: \"D3140\",\n                stack: (new Error()).stack,\n                value: str,\n                functionName: \"encodeUrl\"\n            };\n        }\n        return returnVal;\n    }\n\n    /**\n     * Decode a string from a component for a url\n     * @param {String} str - String to decode\n     * @returns {string} Decoded string\n     */\n    function decodeUrlComponent(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // Catch URIErrors when URI sequence is malformed\n        var returnVal;\n        try {\n            returnVal = decodeURIComponent(str);\n        } catch (e) {\n            throw {\n                code: \"D3140\",\n                stack: (new Error()).stack,\n                value: str,\n                functionName: \"decodeUrlComponent\"\n            };\n        }\n        return returnVal;\n    }\n\n    /**\n     * Decode a string from a url\n     * @param {String} str - String to decode\n     * @returns {string} Decoded string\n     */\n    function decodeUrl(str) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // Catch URIErrors when URI sequence is malformed\n        var returnVal;\n        try {\n            returnVal = decodeURI(str);\n        } catch (e) {\n            throw {\n                code: \"D3140\",\n                stack: (new Error()).stack,\n                value: str,\n                functionName: \"decodeUrl\"\n            };\n        }\n        return returnVal;\n    }\n\n    /**\n     * Split a string into an array of substrings\n     * @param {String} str - string\n     * @param {String} separator - the token or regex that splits the string\n     * @param {Integer} [limit] - max number of substrings\n     * @returns {Array} The array of string\n     */\n    async function split(str, separator, limit) {\n        // undefined inputs always return undefined\n        if (typeof str === 'undefined') {\n            return undefined;\n        }\n\n        // limit, if specified, must be a non-negative number\n        if (limit < 0) {\n            throw {\n                code: \"D3020\",\n                stack: (new Error()).stack,\n                value: limit,\n                index: 3\n            };\n        }\n\n        var result = [];\n\n        if (typeof limit === 'undefined' || limit > 0) {\n            if (typeof separator === 'string') {\n                result = str.split(separator, limit);\n            } else {\n                var count = 0;\n                var matches = await evaluateMatcher(separator, str);\n                if (typeof matches !== 'undefined') {\n                    var start = 0;\n                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {\n                        result.push(str.substring(start, matches.start));\n                        start = matches.end;\n                        matches = await evaluateMatcher(matches.next);\n                        count++;\n                    }\n                    if (typeof limit === 'undefined' || count < limit) {\n                        result.push(str.substring(start));\n                    }\n                } else {\n                    result.push(str);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Join an array of strings\n     * @param {Array} strs - array of string\n     * @param {String} [separator] - the token that splits the string\n     * @returns {String} The concatenated string\n     */\n    function join(strs, separator) {\n        // undefined inputs always return undefined\n        if (typeof strs === 'undefined') {\n            return undefined;\n        }\n\n        // if separator is not specified, default to empty string\n        if (typeof separator === 'undefined') {\n            separator = \"\";\n        }\n\n        return strs.join(separator);\n    }\n\n    /**\n     * Formats a number into a decimal string representation using XPath 3.1 F&O fn:format-number spec\n     * @param {number} value - number to format\n     * @param {String} picture - picture string definition\n     * @param {Object} [options] - override locale defaults\n     * @returns {String} The formatted string\n     */\n    function formatNumber(value, picture, options) {\n        // undefined inputs always return undefined\n        if (typeof value === 'undefined') {\n            return undefined;\n        }\n\n        var defaults = {\n            \"decimal-separator\": \".\",\n            \"grouping-separator\": \",\",\n            \"exponent-separator\": \"e\",\n            \"infinity\": \"Infinity\",\n            \"minus-sign\": \"-\",\n            \"NaN\": \"NaN\",\n            \"percent\": \"%\",\n            \"per-mille\": \"\\u2030\",\n            \"zero-digit\": \"0\",\n            \"digit\": \"#\",\n            \"pattern-separator\": \";\"\n        };\n\n        // if `options` is specified, then its entries override defaults\n        var properties = defaults;\n        if (typeof options !== 'undefined') {\n            Object.keys(options).forEach(function (key) {\n                properties[key] = options[key];\n            });\n        }\n\n        var decimalDigitFamily = [];\n        var zeroCharCode = properties['zero-digit'].charCodeAt(0);\n        for (var ii = zeroCharCode; ii < zeroCharCode + 10; ii++) {\n            decimalDigitFamily.push(String.fromCharCode(ii));\n        }\n\n        var activeChars = decimalDigitFamily.concat([properties['decimal-separator'], properties['exponent-separator'], properties['grouping-separator'], properties.digit, properties['pattern-separator']]);\n\n        var subPictures = picture.split(properties['pattern-separator']);\n\n        if (subPictures.length > 2) {\n            throw {\n                code: 'D3080',\n                stack: (new Error()).stack\n            };\n        }\n\n        var splitParts = function (subpicture) {\n            var prefix = (function () {\n                var ch;\n                for (var ii = 0; ii < subpicture.length; ii++) {\n                    ch = subpicture.charAt(ii);\n                    if (activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {\n                        return subpicture.substring(0, ii);\n                    }\n                }\n            })();\n            var suffix = (function () {\n                var ch;\n                for (var ii = subpicture.length - 1; ii >= 0; ii--) {\n                    ch = subpicture.charAt(ii);\n                    if (activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {\n                        return subpicture.substring(ii + 1);\n                    }\n                }\n            })();\n            var activePart = subpicture.substring(prefix.length, subpicture.length - suffix.length);\n            var mantissaPart, exponentPart, integerPart, fractionalPart;\n            var exponentPosition = subpicture.indexOf(properties['exponent-separator'], prefix.length);\n            if (exponentPosition === -1 || exponentPosition > subpicture.length - suffix.length) {\n                mantissaPart = activePart;\n                exponentPart = undefined;\n            } else {\n                mantissaPart = activePart.substring(0, exponentPosition);\n                exponentPart = activePart.substring(exponentPosition + 1);\n            }\n            var decimalPosition = mantissaPart.indexOf(properties['decimal-separator']);\n            if (decimalPosition === -1) {\n                integerPart = mantissaPart;\n                fractionalPart = suffix;\n            } else {\n                integerPart = mantissaPart.substring(0, decimalPosition);\n                fractionalPart = mantissaPart.substring(decimalPosition + 1);\n            }\n            return {\n                prefix: prefix,\n                suffix: suffix,\n                activePart: activePart,\n                mantissaPart: mantissaPart,\n                exponentPart: exponentPart,\n                integerPart: integerPart,\n                fractionalPart: fractionalPart,\n                subpicture: subpicture\n            };\n        };\n\n        // validate the picture string, F&O 4.7.3\n        var validate = function (parts) {\n            var error;\n            var ii;\n            var subpicture = parts.subpicture;\n            var decimalPos = subpicture.indexOf(properties['decimal-separator']);\n            if (decimalPos !== subpicture.lastIndexOf(properties['decimal-separator'])) {\n                error = 'D3081';\n            }\n            if (subpicture.indexOf(properties.percent) !== subpicture.lastIndexOf(properties.percent)) {\n                error = 'D3082';\n            }\n            if (subpicture.indexOf(properties['per-mille']) !== subpicture.lastIndexOf(properties['per-mille'])) {\n                error = 'D3083';\n            }\n            if (subpicture.indexOf(properties.percent) !== -1 && subpicture.indexOf(properties['per-mille']) !== -1) {\n                error = 'D3084';\n            }\n            var valid = false;\n            for (ii = 0; ii < parts.mantissaPart.length; ii++) {\n                var ch = parts.mantissaPart.charAt(ii);\n                if (decimalDigitFamily.indexOf(ch) !== -1 || ch === properties.digit) {\n                    valid = true;\n                    break;\n                }\n            }\n            if (!valid) {\n                error = 'D3085';\n            }\n            var charTypes = parts.activePart.split('').map(function (char) {\n                return activeChars.indexOf(char) === -1 ? 'p' : 'a';\n            }).join('');\n            if (charTypes.indexOf('p') !== -1) {\n                error = 'D3086';\n            }\n            if (decimalPos !== -1) {\n                if (subpicture.charAt(decimalPos - 1) === properties['grouping-separator'] || subpicture.charAt(decimalPos + 1) === properties['grouping-separator']) {\n                    error = 'D3087';\n                }\n            } else if (parts.integerPart.charAt(parts.integerPart.length - 1) === properties['grouping-separator']) {\n                error = 'D3088';\n            }\n            if (subpicture.indexOf(properties['grouping-separator'] + properties['grouping-separator']) !== -1) {\n                error = 'D3089';\n            }\n            var optionalDigitPos = parts.integerPart.indexOf(properties.digit);\n            if (optionalDigitPos !== -1 && parts.integerPart.substring(0, optionalDigitPos).split('').filter(function (char) {\n                return decimalDigitFamily.indexOf(char) > -1;\n            }).length > 0) {\n                error = 'D3090';\n            }\n            optionalDigitPos = parts.fractionalPart.lastIndexOf(properties.digit);\n            if (optionalDigitPos !== -1 && parts.fractionalPart.substring(optionalDigitPos).split('').filter(function (char) {\n                return decimalDigitFamily.indexOf(char) > -1;\n            }).length > 0) {\n                error = 'D3091';\n            }\n            var exponentExists = (typeof parts.exponentPart === 'string');\n            if (exponentExists && parts.exponentPart.length > 0 && (subpicture.indexOf(properties.percent) !== -1 || subpicture.indexOf(properties['per-mille']) !== -1)) {\n                error = 'D3092';\n            }\n            if (exponentExists && (parts.exponentPart.length === 0 || parts.exponentPart.split('').filter(function (char) {\n                return decimalDigitFamily.indexOf(char) === -1;\n            }).length > 0)) {\n                error = 'D3093';\n            }\n            if (error) {\n                throw {\n                    code: error,\n                    stack: (new Error()).stack\n                };\n            }\n        };\n\n        // analyse the picture string, F&O 4.7.4\n        var analyse = function (parts) {\n            var getGroupingPositions = function (part, toLeft) {\n                var positions = [];\n                var groupingPosition = part.indexOf(properties['grouping-separator']);\n                while (groupingPosition !== -1) {\n                    var charsToTheRight = (toLeft ? part.substring(0, groupingPosition) : part.substring(groupingPosition)).split('').filter(function (char) {\n                        return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;\n                    }).length;\n                    positions.push(charsToTheRight);\n                    groupingPosition = parts.integerPart.indexOf(properties['grouping-separator'], groupingPosition + 1);\n                }\n                return positions;\n            };\n            var integerPartGroupingPositions = getGroupingPositions(parts.integerPart);\n            var regular = function (indexes) {\n                // are the grouping positions regular? i.e. same interval between each of them\n                if (indexes.length === 0) {\n                    return 0;\n                }\n                var gcd = function (a, b) {\n                    return b === 0 ? a : gcd(b, a % b);\n                };\n                // find the greatest common divisor of all the positions\n                var factor = indexes.reduce(gcd);\n                // is every position separated by this divisor? If so, it's regular\n                for (var index = 1; index <= indexes.length; index++) {\n                    if (indexes.indexOf(index * factor) === -1) {\n                        return 0;\n                    }\n                }\n                return factor;\n            };\n\n            var regularGrouping = regular(integerPartGroupingPositions);\n            var fractionalPartGroupingPositions = getGroupingPositions(parts.fractionalPart, true);\n\n            var minimumIntegerPartSize = parts.integerPart.split('').filter(function (char) {\n                return decimalDigitFamily.indexOf(char) !== -1;\n            }).length;\n            var scalingFactor = minimumIntegerPartSize;\n\n            var fractionalPartArray = parts.fractionalPart.split('');\n            var minimumFactionalPartSize = fractionalPartArray.filter(function (char) {\n                return decimalDigitFamily.indexOf(char) !== -1;\n            }).length;\n            var maximumFactionalPartSize = fractionalPartArray.filter(function (char) {\n                return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;\n            }).length;\n            var exponentPresent = typeof parts.exponentPart === 'string';\n            if (minimumIntegerPartSize === 0 && maximumFactionalPartSize === 0) {\n                if (exponentPresent) {\n                    minimumFactionalPartSize = 1;\n                    maximumFactionalPartSize = 1;\n                } else {\n                    minimumIntegerPartSize = 1;\n                }\n            }\n            if (exponentPresent && minimumIntegerPartSize === 0 && parts.integerPart.indexOf(properties.digit) !== -1) {\n                minimumIntegerPartSize = 1;\n            }\n            if (minimumIntegerPartSize === 0 && minimumFactionalPartSize === 0) {\n                minimumFactionalPartSize = 1;\n            }\n            var minimumExponentSize = 0;\n            if (exponentPresent) {\n                minimumExponentSize = parts.exponentPart.split('').filter(function (char) {\n                    return decimalDigitFamily.indexOf(char) !== -1;\n                }).length;\n            }\n\n            return {\n                integerPartGroupingPositions: integerPartGroupingPositions,\n                regularGrouping: regularGrouping,\n                minimumIntegerPartSize: minimumIntegerPartSize,\n                scalingFactor: scalingFactor,\n                prefix: parts.prefix,\n                fractionalPartGroupingPositions: fractionalPartGroupingPositions,\n                minimumFactionalPartSize: minimumFactionalPartSize,\n                maximumFactionalPartSize: maximumFactionalPartSize,\n                minimumExponentSize: minimumExponentSize,\n                suffix: parts.suffix,\n                picture: parts.subpicture\n            };\n        };\n\n        var parts = subPictures.map(splitParts);\n        parts.forEach(validate);\n\n        var variables = parts.map(analyse);\n\n        var minus_sign = properties['minus-sign'];\n        var zero_digit = properties['zero-digit'];\n        var decimal_separator = properties['decimal-separator'];\n        var grouping_separator = properties['grouping-separator'];\n\n        if (variables.length === 1) {\n            variables.push(JSON.parse(JSON.stringify(variables[0])));\n            variables[1].prefix = minus_sign + variables[1].prefix;\n        }\n\n        // TODO cache the result of the analysis\n\n        // format the number\n        // bullet 1: TODO: NaN - not sure we'd ever get this in JSON\n        var pic;\n        // bullet 2:\n        if (value >= 0) {\n            pic = variables[0];\n        } else {\n            pic = variables[1];\n        }\n        var adjustedNumber;\n        // bullet 3:\n        if (pic.picture.indexOf(properties.percent) !== -1) {\n            adjustedNumber = value * 100;\n        } else if (pic.picture.indexOf(properties['per-mille']) !== -1) {\n            adjustedNumber = value * 1000;\n        } else {\n            adjustedNumber = value;\n        }\n        // bullet 4:\n        // TODO: infinity - not sure we'd ever get this in JSON\n        // bullet 5:\n        var mantissa, exponent;\n        if (pic.minimumExponentSize === 0) {\n            mantissa = adjustedNumber;\n        } else {\n            // mantissa * 10^exponent = adjustedNumber\n            var maxMantissa = Math.pow(10, pic.scalingFactor);\n            var minMantissa = Math.pow(10, pic.scalingFactor - 1);\n            mantissa = adjustedNumber;\n            exponent = 0;\n            while (mantissa < minMantissa) {\n                mantissa *= 10;\n                exponent -= 1;\n            }\n            while (mantissa > maxMantissa) {\n                mantissa /= 10;\n                exponent += 1;\n            }\n        }\n        // bullet 6:\n        var roundedNumber = round(mantissa, pic.maximumFactionalPartSize);\n        // bullet 7:\n        var makeString = function (value, dp) {\n            var str = Math.abs(value).toFixed(dp);\n            if (zero_digit !== '0') {\n                str = str.split('').map(function (digit) {\n                    if (digit >= '0' && digit <= '9') {\n                        return decimalDigitFamily[digit.charCodeAt(0) - 48];\n                    } else {\n                        return digit;\n                    }\n                }).join('');\n            }\n            return str;\n        };\n        var stringValue = makeString(roundedNumber, pic.maximumFactionalPartSize);\n        var decimalPos = stringValue.indexOf('.');\n        if (decimalPos === -1) {\n            stringValue = stringValue + decimal_separator;\n        } else {\n            stringValue = stringValue.replace('.', decimal_separator);\n        }\n        while (stringValue.charAt(0) === zero_digit) {\n            stringValue = stringValue.substring(1);\n        }\n        while (stringValue.charAt(stringValue.length - 1) === zero_digit) {\n            stringValue = stringValue.substring(0, stringValue.length - 1);\n        }\n        // bullets 8 & 9:\n        decimalPos = stringValue.indexOf(decimal_separator);\n        var padLeft = pic.minimumIntegerPartSize - decimalPos;\n        var padRight = pic.minimumFactionalPartSize - (stringValue.length - decimalPos - 1);\n        stringValue = (padLeft > 0 ? new Array(padLeft + 1).join(zero_digit) : '') + stringValue;\n        stringValue = stringValue + (padRight > 0 ? new Array(padRight + 1).join(zero_digit) : '');\n        decimalPos = stringValue.indexOf(decimal_separator);\n        // bullet 10:\n        if (pic.regularGrouping > 0) {\n            var groupCount = Math.floor((decimalPos - 1) / pic.regularGrouping);\n            for (var group = 1; group <= groupCount; group++) {\n                stringValue = [stringValue.slice(0, decimalPos - group * pic.regularGrouping), grouping_separator, stringValue.slice(decimalPos - group * pic.regularGrouping)].join('');\n            }\n        } else {\n            pic.integerPartGroupingPositions.forEach(function (pos) {\n                stringValue = [stringValue.slice(0, decimalPos - pos), grouping_separator, stringValue.slice(decimalPos - pos)].join('');\n                decimalPos++;\n            });\n        }\n        // bullet 11:\n        decimalPos = stringValue.indexOf(decimal_separator);\n        pic.fractionalPartGroupingPositions.forEach(function (pos) {\n            stringValue = [stringValue.slice(0, pos + decimalPos + 1), grouping_separator, stringValue.slice(pos + decimalPos + 1)].join('');\n        });\n        // bullet 12:\n        decimalPos = stringValue.indexOf(decimal_separator);\n        if (pic.picture.indexOf(decimal_separator) === -1 || decimalPos === stringValue.length - 1) {\n            stringValue = stringValue.substring(0, stringValue.length - 1);\n        }\n        // bullet 13:\n        if (typeof exponent !== 'undefined') {\n            var stringExponent = makeString(exponent, 0);\n            padLeft = pic.minimumExponentSize - stringExponent.length;\n            if (padLeft > 0) {\n                stringExponent = new Array(padLeft + 1).join(zero_digit) + stringExponent;\n            }\n            stringValue = stringValue + properties['exponent-separator'] + (exponent < 0 ? minus_sign : '') + stringExponent;\n        }\n        // bullet 14:\n        stringValue = pic.prefix + stringValue + pic.suffix;\n        return stringValue;\n    }\n\n    /**\n     * Converts a number to a string using a specified number base\n     * @param {number} value - the number to convert\n     * @param {number} [radix] - the number base; must be between 2 and 36. Defaults to 10\n     * @returns {string} - the converted string\n     */\n    function formatBase(value, radix) {\n        // undefined inputs always return undefined\n        if (typeof value === 'undefined') {\n            return undefined;\n        }\n\n        value = round(value);\n\n        if (typeof radix === 'undefined') {\n            radix = 10;\n        } else {\n            radix = round(radix);\n        }\n\n        if (radix < 2 || radix > 36) {\n            throw {\n                code: 'D3100',\n                stack: (new Error()).stack,\n                value: radix\n            };\n\n        }\n\n        var result = value.toString(radix);\n\n        return result;\n    }\n\n    /**\n     * Cast argument to number\n     * @param {Object} arg - Argument\n     * @returns {Number} numeric value of argument\n     */\n    function number(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        if (typeof arg === 'number') {\n            // already a number\n            result = arg;\n        } else if (typeof arg === 'string' && /^-?[0-9]+(\\.[0-9]+)?([Ee][-+]?[0-9]+)?$/.test(arg) && !isNaN(parseFloat(arg)) && isFinite(arg)) {\n            result = parseFloat(arg);\n        } else if (typeof arg === 'string' && /^(0[xX][0-9A-Fa-f]+)|(0[oO][0-7]+)|(0[bB][0-1]+)$/.test(arg)) {\n            result = Number(arg);\n        } else if (arg === true) {\n            // boolean true casts to 1\n            result = 1;\n        } else if (arg === false) {\n            // boolean false casts to 0\n            result = 0;\n        } else {\n            throw {\n                code: \"D3030\",\n                value: arg,\n                stack: (new Error()).stack,\n                index: 1\n            };\n        }\n        return result;\n    }\n\n    /**\n     * Absolute value of a number\n     * @param {Number} arg - Argument\n     * @returns {Number} absolute value of argument\n     */\n    function abs(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        result = Math.abs(arg);\n        return result;\n    }\n\n    /**\n     * Rounds a number down to integer\n     * @param {Number} arg - Argument\n     * @returns {Number} rounded integer\n     */\n    function floor(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        result = Math.floor(arg);\n        return result;\n    }\n\n    /**\n     * Rounds a number up to integer\n     * @param {Number} arg - Argument\n     * @returns {Number} rounded integer\n     */\n    function ceil(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        result = Math.ceil(arg);\n        return result;\n    }\n\n    /**\n     * Round to half even\n     * @param {Number} arg - Argument\n     * @param {Number} [precision] - number of decimal places\n     * @returns {Number} rounded integer\n     */\n    function round(arg, precision) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        if (precision) {\n            // shift the decimal place - this needs to be done in a string since multiplying\n            // by a power of ten can introduce floating point precision errors which mess up\n            // this rounding algorithm - See 'Decimal rounding' in\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n            // Shift\n            var value = arg.toString().split('e');\n            arg = +(value[0] + 'e' + (value[1] ? (+value[1] + precision) : precision));\n\n        }\n\n        // round up to nearest int\n        result = Math.round(arg);\n        var diff = result - arg;\n        if (Math.abs(diff) === 0.5 && Math.abs(result % 2) === 1) {\n            // rounded the wrong way - adjust to nearest even number\n            result = result - 1;\n        }\n        if (precision) {\n            // Shift back\n            value = result.toString().split('e');\n            /* istanbul ignore next */\n            result = +(value[0] + 'e' + (value[1] ? (+value[1] - precision) : -precision));\n        }\n        if (Object.is(result, -0)) { // ESLint rule 'no-compare-neg-zero' suggests this way\n            // JSON doesn't do -0\n            result = 0;\n        }\n        return result;\n    }\n\n    /**\n     * Square root of number\n     * @param {Number} arg - Argument\n     * @returns {Number} square root\n     */\n    function sqrt(arg) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        if (arg < 0) {\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3060\",\n                index: 1,\n                value: arg\n            };\n        }\n\n        result = Math.sqrt(arg);\n\n        return result;\n    }\n\n    /**\n     * Raises number to the power of the second number\n     * @param {Number} arg - the base\n     * @param {Number} exp - the exponent\n     * @returns {Number} rounded integer\n     */\n    function power(arg, exp) {\n        var result;\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        result = Math.pow(arg, exp);\n\n        if (!isFinite(result)) {\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3061\",\n                index: 1,\n                value: arg,\n                exp: exp\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns a random number 0 <= n < 1\n     * @returns {number} random number\n     */\n    function random() {\n        return Math.random();\n    }\n\n    /**\n     * Evaluate an input and return a boolean\n     * @param {*} arg - Arguments\n     * @returns {boolean} Boolean\n     */\n    function boolean(arg) {\n        // cast arg to its effective boolean value\n        // boolean: unchanged\n        // string: zero-length -> false; otherwise -> true\n        // number: 0 -> false; otherwise -> true\n        // null -> false\n        // array: empty -> false; length > 1 -> true\n        // object: empty -> false; non-empty -> true\n        // function -> false\n\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        var result = false;\n        if (Array.isArray(arg)) {\n            if (arg.length === 1) {\n                result = boolean(arg[0]);\n            } else if (arg.length > 1) {\n                var trues = arg.filter(function (val) {\n                    return boolean(val);\n                });\n                result = trues.length > 0;\n            }\n        } else if (typeof arg === 'string') {\n            if (arg.length > 0) {\n                result = true;\n            }\n        } else if (isNumeric(arg)) {\n            if (arg !== 0) {\n                result = true;\n            }\n        } else if (arg !== null && typeof arg === 'object') {\n            if (Object.keys(arg).length > 0) {\n                result = true;\n            }\n        } else if (typeof arg === 'boolean' && arg === true) {\n            result = true;\n        }\n        return result;\n    }\n\n    /**\n     * returns the Boolean NOT of the arg\n     * @param {*} arg - argument\n     * @returns {boolean} - NOT arg\n     */\n    function not(arg) {\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        return !boolean(arg);\n    }\n\n    /**\n     * Helper function to build the arguments to be supplied to the function arg of the\n     * HOFs map, filter, each, sift and single\n     * @param {function} func - the function to be invoked\n     * @param {*} arg1 - the first (required) arg - the value\n     * @param {*} arg2 - the second (optional) arg - the position (index or key)\n     * @param {*} arg3 - the third (optional) arg - the whole structure (array or object)\n     * @returns {*[]} the argument list\n     */\n    function hofFuncArgs(func, arg1, arg2, arg3) {\n        var func_args = [arg1]; // the first arg (the value) is required\n        // the other two are optional - only supply it if the function can take it\n        var length = getFunctionArity(func);\n        if (length >= 2) {\n            func_args.push(arg2);\n        }\n        if (length >= 3) {\n            func_args.push(arg3);\n        }\n        return func_args;\n    }\n\n    /**\n     * Create a map from an array of arguments\n     * @param {Array} [arr] - array to map over\n     * @param {Function} func - function to apply\n     * @returns {Array} Map array\n     */\n    async function map(arr, func) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        var result = createSequence();\n        // do the map - iterate over the arrays, and invoke func\n        for (var i = 0; i < arr.length; i++) {\n            var func_args = hofFuncArgs(func, arr[i], i, arr);\n            // invoke func\n            var res = await func.apply(this, func_args);\n            if (typeof res !== 'undefined') {\n                result.push(res);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Create a map from an array of arguments\n     * @param {Array} [arr] - array to filter\n     * @param {Function} func - predicate function\n     * @returns {Array} Map array\n     */\n    async function filter(arr, func) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        var result = createSequence();\n\n        for (var i = 0; i < arr.length; i++) {\n            var entry = arr[i];\n            var func_args = hofFuncArgs(func, entry, i, arr);\n            // invoke func\n            var res = await func.apply(this, func_args);\n            if (boolean(res)) {\n                result.push(entry);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Given an array, find the single element matching a specified condition\n     * Throws an exception if the number of matching elements is not exactly one\n     * @param {Array} [arr] - array to filter\n     * @param {Function} [func] - predicate function\n     * @returns {*} Matching element\n     */\n    async function single(arr, func) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        var hasFoundMatch = false;\n        var result;\n\n        for (var i = 0; i < arr.length; i++) {\n            var entry = arr[i];\n            var positiveResult = true;\n            if (typeof func !== 'undefined') {\n                var func_args = hofFuncArgs(func, entry, i, arr);\n                // invoke func\n                var res = await func.apply(this, func_args);\n                positiveResult = boolean(res);\n            }\n            if (positiveResult) {\n                if(!hasFoundMatch) {\n                    result = entry;\n                    hasFoundMatch = true;\n                } else {\n                    throw {\n                        stack: (new Error()).stack,\n                        code: \"D3138\",\n                        index: i\n                    };\n                }\n            }\n        }\n\n        if(!hasFoundMatch) {\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3139\"\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     * Convolves (zips) each value from a set of arrays\n     * @param {Array} [args] - arrays to zip\n     * @returns {Array} Zipped array\n     */\n    function zip() {\n        // this can take a variable number of arguments\n        var result = [];\n        var args = Array.prototype.slice.call(arguments);\n        // length of the shortest array\n        var length = Math.min.apply(Math, args.map(function (arg) {\n            if (Array.isArray(arg)) {\n                return arg.length;\n            }\n            return 0;\n        }));\n        for (var i = 0; i < length; i++) {\n            var tuple = args.map((arg) => {\n                return arg[i];\n            });\n            result.push(tuple);\n        }\n        return result;\n    }\n\n    /**\n     * Fold left function\n     * @param {Array} sequence - Sequence\n     * @param {Function} func - Function\n     * @param {Object} init - Initial value\n     * @returns {*} Result\n     */\n    async function foldLeft(sequence, func, init) {\n        // undefined inputs always return undefined\n        if (typeof sequence === 'undefined') {\n            return undefined;\n        }\n\n        var result;\n\n        var arity = getFunctionArity(func);\n        if (arity < 2) {\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3050\",\n                index: 1\n            };\n        }\n\n        var index;\n        if (typeof init === 'undefined' && sequence.length > 0) {\n            result = sequence[0];\n            index = 1;\n        } else {\n            result = init;\n            index = 0;\n        }\n\n        while (index < sequence.length) {\n            var args = [result, sequence[index]];\n            if (arity >= 3) {\n                args.push(index);\n            }\n            if (arity >= 4) {\n                args.push(sequence);\n            }\n            result = await func.apply(this, args);\n            index++;\n        }\n\n        return result;\n    }\n\n    /**\n     * Return keys for an object\n     * @param {Object} arg - Object\n     * @returns {Array} Array of keys\n     */\n    function keys(arg) {\n        var result = createSequence();\n\n        if (Array.isArray(arg)) {\n            // merge the keys of all of the items in the array\n            var merge = {};\n            arg.forEach(function (item) {\n                var allkeys = keys(item);\n                allkeys.forEach(function (key) {\n                    merge[key] = true;\n                });\n            });\n            result = keys(merge);\n        } else if (arg !== null && typeof arg === 'object' && !isFunction(arg)) {\n            Object.keys(arg).forEach(key => result.push(key));\n        }\n        return result;\n    }\n\n    /**\n     * Return value from an object for a given key\n     * @param {Object} input - Object/Array\n     * @param {String} key - Key in object\n     * @returns {*} Value of key in object\n     */\n    function lookup(input, key) {\n        // lookup the 'name' item in the input\n        var result;\n        if (Array.isArray(input)) {\n            result = createSequence();\n            for(var ii = 0; ii < input.length; ii++) {\n                var res =  lookup(input[ii], key);\n                if (typeof res !== 'undefined') {\n                    if (Array.isArray(res)) {\n                        res.forEach(val => result.push(val));\n                    } else {\n                        result.push(res);\n                    }\n                }\n            }\n        } else if (input !== null && typeof input === 'object' && !isFunction(input)) {\n            result = input[key];\n        }\n        return result;\n    }\n\n    /**\n     * Append second argument to first\n     * @param {Array|Object} arg1 - First argument\n     * @param {Array|Object} arg2 - Second argument\n     * @returns {*} Appended arguments\n     */\n    function append(arg1, arg2) {\n        // disregard undefined args\n        if (typeof arg1 === 'undefined') {\n            return arg2;\n        }\n        if (typeof arg2 === 'undefined') {\n            return arg1;\n        }\n        // if either argument is not an array, make it so\n        if (!Array.isArray(arg1)) {\n            arg1 = createSequence(arg1);\n        }\n        if (!Array.isArray(arg2)) {\n            arg2 = [arg2];\n        }\n        return arg1.concat(arg2);\n    }\n\n    /**\n     * Determines if the argument is undefined\n     * @param {*} arg - argument\n     * @returns {boolean} False if argument undefined, otherwise true\n     */\n    function exists(arg) {\n        if (typeof arg === 'undefined') {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Splits an object into an array of object with one property each\n     * @param {*} arg - the object to split\n     * @returns {*} - the array\n     */\n    function spread(arg) {\n        var result = createSequence();\n\n        if (Array.isArray(arg)) {\n            // spread all of the items in the array\n            arg.forEach(function (item) {\n                result = append(result, spread(item));\n            });\n        } else if (arg !== null && typeof arg === 'object' && !isLambda(arg)) {\n            for (var key in arg) {\n                var obj = {};\n                obj[key] = arg[key];\n                result.push(obj);\n            }\n        } else {\n            result = arg;\n        }\n        return result;\n    }\n\n    /**\n     * Merges an array of objects into a single object.  Duplicate properties are\n     * overridden by entries later in the array\n     * @param {*} arg - the objects to merge\n     * @returns {*} - the object\n     */\n    function merge(arg) {\n        // undefined inputs always return undefined\n        if (typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        var result = {};\n\n        arg.forEach(function (obj) {\n            for (var prop in obj) {\n                result[prop] = obj[prop];\n            }\n        });\n        return result;\n    }\n\n    /**\n     * Reverses the order of items in an array\n     * @param {Array} arr - the array to reverse\n     * @returns {Array} - the reversed array\n     */\n    function reverse(arr) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        if (arr.length <= 1) {\n            return arr;\n        }\n\n        var length = arr.length;\n        var result = new Array(length);\n        for (var i = 0; i < length; i++) {\n            result[length - i - 1] = arr[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *\n     * @param {*} obj - the input object to iterate over\n     * @param {*} func - the function to apply to each key/value pair\n     * @returns {Array} - the resultant array\n     */\n    async function each(obj, func) {\n        var result = createSequence();\n\n        for (var key in obj) {\n            var func_args = hofFuncArgs(func, obj[key], key, obj);\n            // invoke func\n            var val = await func.apply(this, func_args);\n            if(typeof val !== 'undefined') {\n                result.push(val);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *\n     * @param {string} [message] - the message to attach to the error\n     * @throws custom error with code 'D3137'\n     */\n    function error(message) {\n        throw {\n            code: \"D3137\",\n            stack: (new Error()).stack,\n            message: message || \"$error() function evaluated\"\n        };\n    }\n\n    /**\n     *\n     * @param {boolean} condition - the condition to evaluate\n     * @param {string} [message] - the message to attach to the error\n     * @throws custom error with code 'D3137'\n     * @returns {undefined}\n     */\n    function assert(condition, message) {\n        if(!condition) {\n            throw {\n                code: \"D3141\",\n                stack: (new Error()).stack,\n                message: message || \"$assert() statement failed\"\n            };\n        }\n\n        return undefined;\n    }\n\n    /**\n     *\n     * @param {*} [value] - the input to which the type will be checked\n     * @returns {string} - the type of the input\n     */\n    function type(value) {\n        if (value === undefined) {\n            return undefined;\n        }\n\n        if (value === null) {\n            return 'null';\n        }\n\n        if (isNumeric(value)) {\n            return 'number';\n        }\n\n        if (typeof value === 'string') {\n            return 'string';\n        }\n\n        if (typeof value === 'boolean') {\n            return 'boolean';\n        }\n\n        if(Array.isArray(value)) {\n            return 'array';\n        }\n\n        if(isFunction(value)) {\n            return 'function';\n        }\n\n        return 'object';\n    }\n\n    /**\n     * Implements the merge sort (stable) with optional comparator function\n     *\n     * @param {Array} arr - the array to sort\n     * @param {*} comparator - comparator function\n     * @returns {Array} - sorted array\n     */\n    async function sort(arr, comparator) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        if (arr.length <= 1) {\n            return arr;\n        }\n\n        var comp;\n        if (typeof comparator === 'undefined') {\n            // inject a default comparator - only works for numeric or string arrays\n            if (!isArrayOfNumbers(arr) && !isArrayOfStrings(arr)) {\n                throw {\n                    stack: (new Error()).stack,\n                    code: \"D3070\",\n                    index: 1\n                };\n            }\n\n            comp = async function (a, b) {\n                return a > b;\n            };\n        } else {\n            // for internal usage of functionSort (i.e. order-by syntax)\n            comp = comparator;\n        }\n\n        var merge = async function (l, r) {\n            var merge_iter = async function (result, left, right) {\n                if (left.length === 0) {\n                    Array.prototype.push.apply(result, right);\n                } else if (right.length === 0) {\n                    Array.prototype.push.apply(result, left);\n                } else if (await comp(left[0], right[0])) { // invoke the comparator function\n                    // if it returns true - swap left and right\n                    result.push(right[0]);\n                    await merge_iter(result, left, right.slice(1));\n                } else {\n                    // otherwise keep the same order\n                    result.push(left[0]);\n                    await merge_iter(result, left.slice(1), right);\n                }\n            };\n            var merged = [];\n            await merge_iter(merged, l, r);\n            return merged;\n        };\n\n        var msort = async function (array) {\n            if (!Array.isArray(array) || array.length <= 1) {\n                return array;\n            } else {\n                var middle = Math.floor(array.length / 2);\n                var left = array.slice(0, middle);\n                var right = array.slice(middle);\n                left = await msort(left);\n                right = await msort(right);\n                return await merge(left, right);\n            }\n        };\n\n        var result = await msort(arr);\n\n        return result;\n    }\n\n    /**\n     * Randomly shuffles the contents of an array\n     * @param {Array} arr - the input array\n     * @returns {Array} the shuffled array\n     */\n    function shuffle(arr) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        if (arr.length <= 1) {\n            return arr;\n        }\n\n        // shuffle using the 'inside-out' variant of the Fisher-Yates algorithm\n        var result = new Array(arr.length);\n        for (var i = 0; i < arr.length; i++) {\n            var j = Math.floor(Math.random() * (i + 1)); // random integer such that 0 â¤ j â¤ i\n            if (i !== j) {\n                result[i] = result[j];\n            }\n            result[j] = arr[i];\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the values that appear in a sequence, with duplicates eliminated.\n     * @param {Array} arr - An array or sequence of values\n     * @returns {Array} - sequence of distinct values\n     */\n    function distinct(arr) {\n        // undefined inputs always return undefined\n        if (typeof arr === 'undefined') {\n            return undefined;\n        }\n\n        if(!Array.isArray(arr) || arr.length <= 1) {\n            return arr;\n        }\n\n        var results = isSequence(arr) ? createSequence() : [];\n\n        for(var ii = 0; ii < arr.length; ii++) {\n            var value = arr[ii];\n            // is this value already in the result sequence?\n            var includes = false;\n            for(var jj = 0; jj < results.length; jj++) {\n                if (deepEquals(value, results[jj])) {\n                    includes = true;\n                    break;\n                }\n            }\n            if(!includes) {\n                results.push(value);\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Applies a predicate function to each key/value pair in an object, and returns an object containing\n     * only the key/value pairs that passed the predicate\n     *\n     * @param {object} arg - the object to be sifted\n     * @param {object} func - the predicate function (lambda or native)\n     * @returns {object} - sifted object\n     */\n    async function sift(arg, func) {\n        var result = {};\n\n        for (var item in arg) {\n            var entry = arg[item];\n            var func_args = hofFuncArgs(func, entry, item, arg);\n            // invoke func\n            var res = await func.apply(this, func_args);\n            if (boolean(res)) {\n                result[item] = entry;\n            }\n        }\n\n        // empty objects should be changed to undefined\n        if (Object.keys(result).length === 0) {\n            result = undefined;\n        }\n\n        return result;\n    }\n\n    return {\n        sum, count, max, min, average,\n        string, substring, substringBefore, substringAfter, lowercase, uppercase, length, trim, pad,\n        match, contains, replace, split, join,\n        formatNumber, formatBase, number, floor, ceil, round, abs, sqrt, power, random,\n        boolean, not,\n        map, zip, filter, single, foldLeft, sift,\n        keys, lookup, append, exists, spread, merge, reverse, each, error, assert, type, sort, shuffle, distinct,\n        base64encode, base64decode,  encodeUrlComponent, encodeUrl, decodeUrlComponent, decodeUrl\n    };\n})();\n\nmodule.exports = functions;\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./utils\":6}],3:[function(require,module,exports){\n/**\n * Â© Copyright IBM Corp. 2016, 2017 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\n/**\n * @module JSONata\n * @description JSON query and transformation language\n */\n\nvar datetime = require('./datetime');\nvar fn = require('./functions');\nvar utils = require('./utils');\nvar parser = require('./parser');\nvar parseSignature = require('./signature');\n\n/**\n * jsonata\n * @function\n * @param {Object} expr - JSONata expression\n * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression\n */\nvar jsonata = (function() {\n    'use strict';\n\n    var isNumeric = utils.isNumeric;\n    var isArrayOfStrings = utils.isArrayOfStrings;\n    var isArrayOfNumbers = utils.isArrayOfNumbers;\n    var createSequence = utils.createSequence;\n    var isSequence = utils.isSequence;\n    var isFunction = utils.isFunction;\n    var isLambda = utils.isLambda;\n    var isIterable = utils.isIterable;\n    var isPromise = utils.isPromise;\n    var getFunctionArity = utils.getFunctionArity;\n    var isDeepEqual = utils.isDeepEqual;\n\n    // Start of Evaluator code\n\n    var staticFrame = createFrame(null);\n\n    /**\n     * Evaluate expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluate(expr, input, environment) {\n        var result;\n\n        var entryCallback = environment.lookup('__evaluate_entry');\n        if(entryCallback) {\n            await entryCallback(expr, input, environment);\n        }\n\n        switch (expr.type) {\n            case 'path':\n                result = await evaluatePath(expr, input, environment);\n                break;\n            case 'binary':\n                result = await evaluateBinary(expr, input, environment);\n                break;\n            case 'unary':\n                result = await evaluateUnary(expr, input, environment);\n                break;\n            case 'name':\n                result = evaluateName(expr, input, environment);\n                break;\n            case 'string':\n            case 'number':\n            case 'value':\n                result = evaluateLiteral(expr, input, environment);\n                break;\n            case 'wildcard':\n                result = evaluateWildcard(expr, input, environment);\n                break;\n            case 'descendant':\n                result = evaluateDescendants(expr, input, environment);\n                break;\n            case 'parent':\n                result = environment.lookup(expr.slot.label);\n                break;\n            case 'condition':\n                result = await evaluateCondition(expr, input, environment);\n                break;\n            case 'block':\n                result = await evaluateBlock(expr, input, environment);\n                break;\n            case 'bind':\n                result = await evaluateBindExpression(expr, input, environment);\n                break;\n            case 'regex':\n                result = evaluateRegex(expr, input, environment);\n                break;\n            case 'function':\n                result = await evaluateFunction(expr, input, environment);\n                break;\n            case 'variable':\n                result = evaluateVariable(expr, input, environment);\n                break;\n            case 'lambda':\n                result = evaluateLambda(expr, input, environment);\n                break;\n            case 'partial':\n                result = await evaluatePartialApplication(expr, input, environment);\n                break;\n            case 'apply':\n                result = await evaluateApplyExpression(expr, input, environment);\n                break;\n            case 'transform':\n                result = evaluateTransformExpression(expr, input, environment);\n                break;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(expr, 'predicate')) {\n            for(var ii = 0; ii < expr.predicate.length; ii++) {\n                result = await evaluateFilter(expr.predicate[ii].expr, result, environment);\n            }\n        }\n\n        if (expr.type !== 'path' && Object.prototype.hasOwnProperty.call(expr, 'group')) {\n            result = await evaluateGroupExpression(expr.group, result, environment);\n        }\n\n        var exitCallback = environment.lookup('__evaluate_exit');\n        if(exitCallback) {\n            await exitCallback(expr, input, environment, result);\n        }\n\n        if(result && isSequence(result) && !result.tupleStream) {\n            if(expr.keepArray) {\n                result.keepSingleton = true;\n            }\n            if(result.length === 0) {\n                result = undefined;\n            } else if(result.length === 1) {\n                result =  result.keepSingleton ? result : result[0];\n            }\n\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate path expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluatePath(expr, input, environment) {\n        var inputSequence;\n        // expr is an array of steps\n        // if the first step is a variable reference ($...), including root reference ($$),\n        //   then the path is absolute rather than relative\n        if (Array.isArray(input) && expr.steps[0].type !== 'variable') {\n            inputSequence = input;\n        } else {\n            // if input is not an array, make it so\n            inputSequence = createSequence(input);\n        }\n\n        var resultSequence;\n        var isTupleStream = false;\n        var tupleBindings = undefined;\n\n        // evaluate each step in turn\n        for(var ii = 0; ii < expr.steps.length; ii++) {\n            var step = expr.steps[ii];\n\n            if(step.tuple) {\n                isTupleStream = true;\n            }\n\n            // if the first step is an explicit array constructor, then just evaluate that (i.e. don't iterate over a context array)\n            if(ii === 0 && step.consarray) {\n                resultSequence = await evaluate(step, inputSequence, environment);\n            } else {\n                if(isTupleStream) {\n                    tupleBindings = await evaluateTupleStep(step, inputSequence, tupleBindings, environment);\n                } else {\n                    resultSequence = await evaluateStep(step, inputSequence, environment, ii === expr.steps.length - 1);\n                }\n            }\n\n            if (!isTupleStream && (typeof resultSequence === 'undefined' || resultSequence.length === 0)) {\n                break;\n            }\n\n            if(typeof step.focus === 'undefined') {\n                inputSequence = resultSequence;\n            }\n\n        }\n\n        if(isTupleStream) {\n            if(expr.tuple) {\n                // tuple stream is carrying ancestry information - keep this\n                resultSequence = tupleBindings;\n            } else {\n                resultSequence = createSequence();\n                for (ii = 0; ii < tupleBindings.length; ii++) {\n                    resultSequence.push(tupleBindings[ii]['@']);\n                }\n            }\n        }\n\n        if(expr.keepSingletonArray) {\n            // if the array is explicitly constructed in the expression and marked to promote singleton sequences to array\n            if(Array.isArray(resultSequence) && resultSequence.cons && !resultSequence.sequence) {\n                resultSequence = createSequence(resultSequence);\n            }\n            resultSequence.keepSingleton = true;\n        }\n\n        if (expr.hasOwnProperty('group')) {\n            resultSequence = await evaluateGroupExpression(expr.group, isTupleStream ? tupleBindings : resultSequence, environment)\n        }\n\n        return resultSequence;\n    }\n\n    function createFrameFromTuple(environment, tuple) {\n        var frame = createFrame(environment);\n        for(const prop in tuple) {\n            frame.bind(prop, tuple[prop]);\n        }\n        return frame;\n    }\n\n    /**\n     * Evaluate a step within a path\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @param {boolean} lastStep - flag the last step in a path\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateStep(expr, input, environment, lastStep) {\n        var result;\n        if(expr.type === 'sort') {\n             result = await evaluateSortExpression(expr, input, environment);\n             if(expr.stages) {\n                 result = await evaluateStages(expr.stages, result, environment);\n             }\n             return result;\n        }\n\n        result = createSequence();\n\n        for(var ii = 0; ii < input.length; ii++) {\n            var res = await evaluate(expr, input[ii], environment);\n            if(expr.stages) {\n                for(var ss = 0; ss < expr.stages.length; ss++) {\n                    res = await evaluateFilter(expr.stages[ss].expr, res, environment);\n                }\n            }\n            if(typeof res !== 'undefined') {\n                result.push(res);\n            }\n        }\n\n        var resultSequence = createSequence();\n        if(lastStep && result.length === 1 && Array.isArray(result[0]) && !isSequence(result[0])) {\n            resultSequence = result[0];\n        } else {\n            // flatten the sequence\n            result.forEach(function(res) {\n                if (!Array.isArray(res) || res.cons) {\n                    // it's not an array - just push into the result sequence\n                    resultSequence.push(res);\n                } else {\n                    // res is a sequence - flatten it into the parent sequence\n                    res.forEach(val => resultSequence.push(val));\n                }\n            });\n        }\n\n        return resultSequence;\n    }\n\n    async function evaluateStages(stages, input, environment) {\n        var result = input;\n        for(var ss = 0; ss < stages.length; ss++) {\n            var stage = stages[ss];\n            switch(stage.type) {\n                case 'filter':\n                    result = await evaluateFilter(stage.expr, result, environment);\n                    break;\n                case 'index':\n                    for(var ee = 0; ee < result.length; ee++) {\n                        var tuple = result[ee];\n                        tuple[stage.value] = ee;\n                    }\n                    break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate a step within a path\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} tupleBindings - The tuple stream\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateTupleStep(expr, input, tupleBindings, environment) {\n        var result;\n        if(expr.type === 'sort') {\n            if(tupleBindings) {\n                result = await evaluateSortExpression(expr, tupleBindings, environment);\n            } else {\n                var sorted = await evaluateSortExpression(expr, input, environment);\n                result = createSequence();\n                result.tupleStream = true;\n                for(var ss = 0; ss < sorted.length; ss++) {\n                    var tuple = {'@': sorted[ss]};\n                    tuple[expr.index] = ss;\n                    result.push(tuple);\n                }\n            }\n            if(expr.stages) {\n                result = await evaluateStages(expr.stages, result, environment);\n            }\n            return result;\n        }\n\n        result = createSequence();\n        result.tupleStream = true;\n        var stepEnv = environment;\n        if(tupleBindings === undefined) {\n            tupleBindings = input.map(item => { return {'@': item} });\n        }\n\n        for(var ee = 0; ee < tupleBindings.length; ee++) {\n            stepEnv = createFrameFromTuple(environment, tupleBindings[ee]);\n            var res = await evaluate(expr, tupleBindings[ee]['@'], stepEnv);\n            // res is the binding sequence for the output tuple stream\n            if(typeof res !== 'undefined') {\n                if (!Array.isArray(res)) {\n                    res = [res];\n                }\n                for (var bb = 0; bb < res.length; bb++) {\n                    tuple = {};\n                    Object.assign(tuple, tupleBindings[ee]);\n                    if(res.tupleStream) {\n                        Object.assign(tuple, res[bb]);\n                    } else {\n                        if (expr.focus) {\n                            tuple[expr.focus] = res[bb];\n                            tuple['@'] = tupleBindings[ee]['@'];\n                        } else {\n                            tuple['@'] = res[bb];\n                        }\n                        if (expr.index) {\n                            tuple[expr.index] = bb;\n                        }\n                        if (expr.ancestor) {\n                            tuple[expr.ancestor.label] = tupleBindings[ee]['@'];\n                        }\n                    }\n                    result.push(tuple);\n                }\n            }\n        }\n\n        if(expr.stages) {\n            result = await evaluateStages(expr.stages, result, environment);\n        }\n\n        return result;\n    }\n\n    /**\n     * Apply filter predicate to input data\n     * @param {Object} predicate - filter expression\n     * @param {Object} input - Input data to apply predicates against\n     * @param {Object} environment - Environment\n     * @returns {*} Result after applying predicates\n     */\n    async function evaluateFilter(predicate, input, environment) {\n        var results = createSequence();\n        if( input && input.tupleStream) {\n            results.tupleStream = true;\n        }\n        if (!Array.isArray(input)) {\n            input = createSequence(input);\n        }\n        if (predicate.type === 'number') {\n            var index = Math.floor(predicate.value);  // round it down\n            if (index < 0) {\n                // count in from end of array\n                index = input.length + index;\n            }\n            var item = input[index];\n            if(typeof item !== 'undefined') {\n                if(Array.isArray(item)) {\n                    results = item;\n                } else {\n                    results.push(item);\n                }\n            }\n        } else {\n            for (index = 0; index < input.length; index++) {\n                var item = input[index];\n                var context = item;\n                var env = environment;\n                if(input.tupleStream) {\n                    context = item['@'];\n                    env = createFrameFromTuple(environment, item);\n                }\n                var res = await evaluate(predicate, context, env);\n                if (isNumeric(res)) {\n                    res = [res];\n                }\n                if (isArrayOfNumbers(res)) {\n                    res.forEach(function (ires) {\n                        // round it down\n                        var ii = Math.floor(ires);\n                        if (ii < 0) {\n                            // count in from end of array\n                            ii = input.length + ii;\n                        }\n                        if (ii === index) {\n                            results.push(item);\n                        }\n                    });\n                } else if (fn.boolean(res)) { // truthy\n                    results.push(item);\n                }\n            }\n        }\n        return results;\n    }\n\n    /**\n     * Evaluate binary expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateBinary(expr, input, environment) {\n        var result;\n        var lhs = await evaluate(expr.lhs, input, environment);\n        var op = expr.value;\n\n        //defer evaluation of RHS to allow short-circuiting\n        var evalrhs = async () => await evaluate(expr.rhs, input, environment);\n        if (op === \"and\" || op === \"or\") {\n            try {\n                return await evaluateBooleanExpression(lhs, evalrhs, op);\n            } catch(err) {\n                err.position = expr.position;\n                err.token = op;\n                throw err;\n            }\n        }\n\n        var rhs = await evalrhs();\n        try {\n            switch (op) {\n                case '+':\n                case '-':\n                case '*':\n                case '/':\n                case '%':\n                    result = evaluateNumericExpression(lhs, rhs, op);\n                    break;\n                case '=':\n                case '!=':\n                    result = evaluateEqualityExpression(lhs, rhs, op);\n                    break;\n                case '<':\n                case '<=':\n                case '>':\n                case '>=':\n                    result = evaluateComparisonExpression(lhs, rhs, op);\n                    break;\n                case '&':\n                    result = evaluateStringConcat(lhs, rhs);\n                    break;\n                case '..':\n                    result = evaluateRangeExpression(lhs, rhs);\n                    break;\n                case 'in':\n                    result = evaluateIncludesExpression(lhs, rhs);\n                    break;\n            }\n        } catch(err) {\n            err.position = expr.position;\n            err.token = op;\n            throw err;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate unary expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateUnary(expr, input, environment) {\n        var result;\n\n        switch (expr.value) {\n            case '-':\n                result = await evaluate(expr.expression, input, environment);\n                if(typeof result === 'undefined') {\n                    result = undefined;\n                } else if (isNumeric(result)) {\n                    result = -result;\n                } else {\n                    throw {\n                        code: \"D1002\",\n                        stack: (new Error()).stack,\n                        position: expr.position,\n                        token: expr.value,\n                        value: result\n                    };\n                }\n                break;\n            case '[':\n                // array constructor - evaluate each item\n                result = [];\n                let generators = await Promise.all(expr.expressions\n                    .map(async (item, idx) => {\n                        environment.isParallelCall = idx > 0\n                        return [item, await evaluate(item, input, environment)]\n                    }));\n                for (let generator of generators) {\n                    var [item, value] = generator;\n                    if (typeof value !== 'undefined') {\n                        if(item.value === '[') {\n                            result.push(value);\n                        } else {\n                            result = fn.append(result, value);\n                        }\n                    }\n                }\n                if(expr.consarray) {\n                    Object.defineProperty(result, 'cons', {\n                        enumerable: false,\n                        configurable: false,\n                        value: true\n                    });\n                }\n                break;\n            case '{':\n                // object constructor - apply grouping\n                result = await evaluateGroupExpression(expr, input, environment);\n                break;\n\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate name object against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    function evaluateName(expr, input, environment) {\n        // lookup the 'name' item in the input\n        return fn.lookup(input, expr.value);\n    }\n\n    /**\n     * Evaluate literal against input data\n     * @param {Object} expr - JSONata expression\n     * @returns {*} Evaluated input data\n     */\n    function evaluateLiteral(expr) {\n        return expr.value;\n    }\n\n    /**\n     * Evaluate wildcard against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @returns {*} Evaluated input data\n     */\n    function evaluateWildcard(expr, input) {\n        var results = createSequence();\n        if (Array.isArray(input) && input.outerWrapper && input.length > 0) {\n            input = input[0];\n        }\n        if (input !== null && typeof input === 'object') {\n            Object.keys(input).forEach(function (key) {\n                var value = input[key];\n                if(Array.isArray(value)) {\n                    value = flatten(value);\n                    results = fn.append(results, value);\n                } else {\n                    results.push(value);\n                }\n            });\n        }\n\n        //        result = normalizeSequence(results);\n        return results;\n    }\n\n    /**\n     * Returns a flattened array\n     * @param {Array} arg - the array to be flatten\n     * @param {Array} flattened - carries the flattened array - if not defined, will initialize to []\n     * @returns {Array} - the flattened array\n     */\n    function flatten(arg, flattened) {\n        if(typeof flattened === 'undefined') {\n            flattened = [];\n        }\n        if(Array.isArray(arg)) {\n            arg.forEach(function (item) {\n                flatten(item, flattened);\n            });\n        } else {\n            flattened.push(arg);\n        }\n        return flattened;\n    }\n\n    /**\n     * Evaluate descendants against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @returns {*} Evaluated input data\n     */\n    function evaluateDescendants(expr, input) {\n        var result;\n        var resultSequence = createSequence();\n        if (typeof input !== 'undefined') {\n            // traverse all descendants of this object/array\n            recurseDescendants(input, resultSequence);\n            if (resultSequence.length === 1) {\n                result = resultSequence[0];\n            } else {\n                result = resultSequence;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Recurse through descendants\n     * @param {Object} input - Input data\n     * @param {Object} results - Results\n     */\n    function recurseDescendants(input, results) {\n        // this is the equivalent of //* in XPath\n        if (!Array.isArray(input)) {\n            results.push(input);\n        }\n        if (Array.isArray(input)) {\n            input.forEach(function (member) {\n                recurseDescendants(member, results);\n            });\n        } else if (input !== null && typeof input === 'object') {\n            Object.keys(input).forEach(function (key) {\n                recurseDescendants(input[key], results);\n            });\n        }\n    }\n\n    /**\n     * Evaluate numeric expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @param {Object} op - opcode\n     * @returns {*} Result\n     */\n    function evaluateNumericExpression(lhs, rhs, op) {\n        var result;\n\n        if (typeof lhs !== 'undefined' && !isNumeric(lhs)) {\n            throw {\n                code: \"T2001\",\n                stack: (new Error()).stack,\n                value: lhs\n            };\n        }\n        if (typeof rhs !== 'undefined' && !isNumeric(rhs)) {\n            throw {\n                code: \"T2002\",\n                stack: (new Error()).stack,\n                value: rhs\n            };\n        }\n\n        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {\n            // if either side is undefined, the result is undefined\n            return result;\n        }\n\n        switch (op) {\n            case '+':\n                result = lhs + rhs;\n                break;\n            case '-':\n                result = lhs - rhs;\n                break;\n            case '*':\n                result = lhs * rhs;\n                break;\n            case '/':\n                result = lhs / rhs;\n                break;\n            case '%':\n                result = lhs % rhs;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate equality expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @param {Object} op - opcode\n     * @returns {*} Result\n     */\n    function evaluateEqualityExpression(lhs, rhs, op) {\n        var result;\n\n        // type checks\n        var ltype = typeof lhs;\n        var rtype = typeof rhs;\n\n        if (ltype === 'undefined' || rtype === 'undefined') {\n            // if either side is undefined, the result is false\n            return false;\n        }\n\n        switch (op) {\n            case '=':\n                result = isDeepEqual(lhs, rhs);\n                break;\n            case '!=':\n                result = !isDeepEqual(lhs, rhs);\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate comparison expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @param {Object} op - opcode\n     * @returns {*} Result\n     */\n    function evaluateComparisonExpression(lhs, rhs, op) {\n        var result;\n\n        // type checks\n        var ltype = typeof lhs;\n        var rtype = typeof rhs;\n\n        var lcomparable = (ltype === 'undefined' || ltype === 'string' || ltype === 'number');\n        var rcomparable = (rtype === 'undefined' || rtype === 'string' || rtype === 'number');\n\n        // if either aa or bb are not comparable (string or numeric) values, then throw an error\n        if (!lcomparable || !rcomparable) {\n            throw {\n                code: \"T2010\",\n                stack: (new Error()).stack,\n                value: !(ltype === 'string' || ltype === 'number') ? lhs : rhs\n            };\n        }\n\n        // if either side is undefined, the result is undefined\n        if (ltype === 'undefined' || rtype === 'undefined') {\n            return undefined;\n        }\n\n        //if aa and bb are not of the same type\n        if (ltype !== rtype) {\n            throw {\n                code: \"T2009\",\n                stack: (new Error()).stack,\n                value: lhs,\n                value2: rhs\n            };\n        }\n\n        switch (op) {\n            case '<':\n                result = lhs < rhs;\n                break;\n            case '<=':\n                result = lhs <= rhs;\n                break;\n            case '>':\n                result = lhs > rhs;\n                break;\n            case '>=':\n                result = lhs >= rhs;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Inclusion operator - in\n     *\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @returns {boolean} - true if lhs is a member of rhs\n     */\n    function evaluateIncludesExpression(lhs, rhs) {\n        var result = false;\n\n        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {\n            // if either side is undefined, the result is false\n            return false;\n        }\n\n        if(!Array.isArray(rhs)) {\n            rhs = [rhs];\n        }\n\n        for(var i = 0; i < rhs.length; i++) {\n            if(rhs[i] === lhs) {\n                result = true;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate boolean expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Function} evalrhs - function to evaluate RHS value\n     * @param {Object} op - opcode\n     * @returns {*} Result\n     */\n    async function evaluateBooleanExpression(lhs, evalrhs, op) {\n        var result;\n\n        var lBool = boolize(lhs);\n\n        switch (op) {\n            case 'and':\n                result = lBool && boolize(await evalrhs());\n                break;\n            case 'or':\n                result = lBool || boolize(await evalrhs());\n                break;\n        }\n        return result;\n    }\n\n    function boolize(value) {\n        var booledValue = fn.boolean(value);\n        return typeof booledValue === 'undefined' ? false : booledValue;\n    }\n\n    /**\n     * Evaluate string concatenation against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @returns {string|*} Concatenated string\n     */\n    function evaluateStringConcat(lhs, rhs) {\n        var result;\n\n        var lstr = '';\n        var rstr = '';\n        if (typeof lhs !== 'undefined') {\n            lstr = fn.string(lhs);\n        }\n        if (typeof rhs !== 'undefined') {\n            rstr = fn.string(rhs);\n        }\n\n        result = lstr.concat(rstr);\n        return result;\n    }\n\n    /**\n     * Evaluate group expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {{}} Evaluated input data\n     */\n    async function evaluateGroupExpression(expr, input, environment) {\n        var result = {};\n        var groups = {};\n        var reduce = input && input.tupleStream ? true : false;\n        // group the input sequence by 'key' expression\n        if (!Array.isArray(input)) {\n            input = createSequence(input);\n        }\n        // if the array is empty, add an undefined entry to enable literal JSON object to be generated\n        if (input.length === 0) {\n            input.push(undefined);\n        }\n\n        for(var itemIndex = 0; itemIndex < input.length; itemIndex++) {\n            var item = input[itemIndex];\n            var env = reduce ? createFrameFromTuple(environment, item) : environment;\n            for(var pairIndex = 0; pairIndex < expr.lhs.length; pairIndex++) {\n                var pair = expr.lhs[pairIndex];\n                var key = await evaluate(pair[0], reduce ? item['@'] : item, env);\n                // key has to be a string\n                if (typeof  key !== 'string' && key !== undefined) {\n                    throw {\n                        code: \"T1003\",\n                        stack: (new Error()).stack,\n                        position: expr.position,\n                        value: key\n                    };\n                }\n\n                if (key !== undefined) {\n                    var entry = {data: item, exprIndex: pairIndex};\n                    if (groups.hasOwnProperty(key)) {\n                        // a value already exists in this slot\n                        if(groups[key].exprIndex !== pairIndex) {\n                            // this key has been generated by another expression in this group\n                            // when multiple key expressions evaluate to the same key, then error D1009 must be thrown\n                            throw {\n                                code: \"D1009\",\n                                stack: (new Error()).stack,\n                                position: expr.position,\n                                value: key\n                            };\n                        }\n\n                        // append it as an array\n                        groups[key].data = fn.append(groups[key].data, item);\n                    } else {\n                        groups[key] = entry;\n                    }\n                }\n            }\n        }\n\n        // iterate over the groups to evaluate the 'value' expression\n        let generators = await Promise.all(Object.keys(groups).map(async (key, idx) => {\n            let entry = groups[key];\n            var context = entry.data;\n            var env = environment;\n            if (reduce) {\n                var tuple = reduceTupleStream(entry.data);\n                context = tuple['@'];\n                delete tuple['@'];\n                env = createFrameFromTuple(environment, tuple);\n            }\n            environment.isParallelCall = idx > 0\n            return [key, await evaluate(expr.lhs[entry.exprIndex][1], context, env)];\n        }));\n\n        for (let generator of generators) {\n            var [key, value] = await generator;\n            if(typeof value !== 'undefined') {\n                result[key] = value;\n            }\n        }\n\n        return result;\n    }\n\n    function reduceTupleStream(tupleStream) {\n        if(!Array.isArray(tupleStream)) {\n            return tupleStream;\n        }\n        var result = {};\n        Object.assign(result, tupleStream[0]);\n        for(var ii = 1; ii < tupleStream.length; ii++) {\n            for(const prop in tupleStream[ii]) {\n                result[prop] = fn.append(result[prop], tupleStream[ii][prop]);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate range expression against input data\n     * @param {Object} lhs - LHS value\n     * @param {Object} rhs - RHS value\n     * @returns {Array} Resultant array\n     */\n    function evaluateRangeExpression(lhs, rhs) {\n        var result;\n\n        if (typeof lhs !== 'undefined' && !Number.isInteger(lhs)) {\n            throw {\n                code: \"T2003\",\n                stack: (new Error()).stack,\n                value: lhs\n            };\n        }\n        if (typeof rhs !== 'undefined' && !Number.isInteger(rhs)) {\n            throw {\n                code: \"T2004\",\n                stack: (new Error()).stack,\n                value: rhs\n            };\n        }\n\n        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {\n            // if either side is undefined, the result is undefined\n            return result;\n        }\n\n        if (lhs > rhs) {\n            // if the lhs is greater than the rhs, return undefined\n            return result;\n        }\n\n        // limit the size of the array to ten million entries (1e7)\n        // this is an implementation defined limit to protect against\n        // memory and performance issues.  This value may increase in the future.\n        var size = rhs - lhs + 1;\n        if(size > 1e7) {\n            throw {\n                code: \"D2014\",\n                stack: (new Error()).stack,\n                value: size\n            };\n        }\n\n        result = new Array(size);\n        for (var item = lhs, index = 0; item <= rhs; item++, index++) {\n            result[index] = item;\n        }\n        result.sequence = true;\n        return result;\n    }\n\n    /**\n     * Evaluate bind expression against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateBindExpression(expr, input, environment) {\n        // The RHS is the expression to evaluate\n        // The LHS is the name of the variable to bind to - should be a VARIABLE token (enforced by parser)\n        var value = await evaluate(expr.rhs, input, environment);\n        environment.bind(expr.lhs.value, value);\n        return value;\n    }\n\n    /**\n     * Evaluate condition against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateCondition(expr, input, environment) {\n        var result;\n        var condition = await evaluate(expr.condition, input, environment);\n        if (fn.boolean(condition)) {\n            result = await evaluate(expr.then, input, environment);\n        } else if (typeof expr.else !== 'undefined') {\n            result = await evaluate(expr.else, input, environment);\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate block against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateBlock(expr, input, environment) {\n        var result;\n        // create a new frame to limit the scope of variable assignments\n        // TODO, only do this if the post-parse stage has flagged this as required\n        var frame = createFrame(environment);\n        // invoke each expression in turn\n        // only return the result of the last one\n        for(var ii = 0; ii < expr.expressions.length; ii++) {\n            result = await evaluate(expr.expressions[ii], input, frame);\n        }\n\n        return result;\n    }\n\n    /**\n     * Prepare a regex\n     * @param {Object} expr - expression containing regex\n     * @returns {Function} Higher order function representing prepared regex\n     */\n    function evaluateRegex(expr) {\n        var re = new jsonata.RegexEngine(expr.value);\n        var closure = function(str, fromIndex) {\n            var result;\n            re.lastIndex = fromIndex || 0;\n            var match = re.exec(str);\n            if(match !== null) {\n                result = {\n                    match: match[0],\n                    start: match.index,\n                    end: match.index + match[0].length,\n                    groups: []\n                };\n                if(match.length > 1) {\n                    for(var i = 1; i < match.length; i++) {\n                        result.groups.push(match[i]);\n                    }\n                }\n                result.next = function() {\n                    if(re.lastIndex >= str.length) {\n                        return undefined;\n                    } else {\n                        var next = closure(str, re.lastIndex);\n                        if(next && next.match === '') {\n                            // matches zero length string; this will never progress\n                            throw {\n                                code: \"D1004\",\n                                stack: (new Error()).stack,\n                                position: expr.position,\n                                value: expr.value.source\n                            };\n                        }\n                        return next;\n                    }\n                };\n            }\n\n            return result;\n        };\n        return closure;\n    }\n\n    /**\n     * Evaluate variable against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    function evaluateVariable(expr, input, environment) {\n        // lookup the variable value in the environment\n        var result;\n        // if the variable name is empty string, then it refers to context value\n        if (expr.value === '') {\n            result = input && input.outerWrapper ? input[0] : input;\n        } else {\n            result = environment.lookup(expr.value);\n        }\n        return result;\n    }\n\n    /**\n     * sort / order-by operator\n     * @param {Object} expr - AST for operator\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Ordered sequence\n     */\n    async function evaluateSortExpression(expr, input, environment) {\n        var result;\n\n        // evaluate the lhs, then sort the results in order according to rhs expression\n        var lhs = input;\n        var isTupleSort = input.tupleStream ? true : false;\n\n        // sort the lhs array\n        // use comparator function\n        var comparator = async function(a, b) { \n            // expr.terms is an array of order-by in priority order\n            var comp = 0;\n            for(var index = 0; comp === 0 && index < expr.terms.length; index++) {\n                var term = expr.terms[index];\n                //evaluate the sort term in the context of a\n                var context = a;\n                var env = environment;\n                if(isTupleSort) {\n                    context = a['@'];\n                    env = createFrameFromTuple(environment, a);\n                }\n                var aa = await evaluate(term.expression, context, env);\n                //evaluate the sort term in the context of b\n                context = b;\n                env = environment;\n                if(isTupleSort) {\n                    context = b['@'];\n                    env = createFrameFromTuple(environment, b);\n                }\n                var bb = await evaluate(term.expression, context, env);\n\n                // type checks\n                var atype = typeof aa;\n                var btype = typeof bb;\n                // undefined should be last in sort order\n                if(atype === 'undefined') {\n                    // swap them, unless btype is also undefined\n                    comp = (btype === 'undefined') ? 0 : 1;\n                    continue;\n                }\n                if(btype === 'undefined') {\n                    comp = -1;\n                    continue;\n                }\n\n                // if aa or bb are not string or numeric values, then throw an error\n                if(!(atype === 'string' || atype === 'number') || !(btype === 'string' || btype === 'number')) {\n                    throw {\n                        code: \"T2008\",\n                        stack: (new Error()).stack,\n                        position: expr.position,\n                        value: !(atype === 'string' || atype === 'number') ? aa : bb\n                    };\n                }\n\n                //if aa and bb are not of the same type\n                if(atype !== btype) {\n                    throw {\n                        code: \"T2007\",\n                        stack: (new Error()).stack,\n                        position: expr.position,\n                        value: aa,\n                        value2: bb\n                    };\n                }\n                if(aa === bb) {\n                    // both the same - move on to next term\n                    continue;\n                } else if (aa < bb) {\n                    comp = -1;\n                } else {\n                    comp = 1;\n                }\n                if(term.descending === true) {\n                    comp = -comp;\n                }\n            }\n            // only swap a & b if comp equals 1\n            return comp === 1;\n        };\n\n        var focus = {\n            environment: environment,\n            input: input\n        };\n        // the `focus` is passed in as the `this` for the invoked function\n        result = await fn.sort.apply(focus, [lhs, comparator]);\n\n        return result;\n    }\n\n    /**\n     * create a transformer function\n     * @param {Object} expr - AST for operator\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} tranformer function\n     */\n    function evaluateTransformExpression(expr, input, environment) {\n        // create a function to implement the transform definition\n        var transformer = async function (obj) { // signature <(oa):o>\n            // undefined inputs always return undefined\n            if(typeof obj === 'undefined') {\n                return undefined;\n            }\n\n            // this function returns a copy of obj with changes specified by the pattern/operation\n            var cloneFunction = environment.lookup('clone');\n            if(!isFunction(cloneFunction)) {\n                // throw type error\n                throw {\n                    code: \"T2013\",\n                    stack: (new Error()).stack,\n                    position: expr.position\n                };\n            }\n            var result = await apply(cloneFunction, [obj], null, environment);\n            var matches = await evaluate(expr.pattern, result, environment);\n            if(typeof matches !== 'undefined') {\n                if(!Array.isArray(matches)) {\n                    matches = [matches];\n                }\n                for(var ii = 0; ii < matches.length; ii++) {\n                    var match = matches[ii];\n                    if (match && (match.isPrototypeOf(result) || match instanceof Object.constructor)) {\n                        throw {\n                            code: \"D1010\",\n                            stack: (new Error()).stack,\n                            position: expr.position\n                        };\n                    }\n                    // evaluate the update value for each match\n                    var update = await evaluate(expr.update, match, environment);\n                    // update must be an object\n                    var updateType = typeof update;\n                    if(updateType !== 'undefined') {\n                        if(updateType !== 'object' || update === null || Array.isArray(update)) {\n                            // throw type error\n                            throw {\n                                code: \"T2011\",\n                                stack: (new Error()).stack,\n                                position: expr.update.position,\n                                value: update\n                            };\n                        }\n                        // merge the update\n                        for(var prop in update) {\n                            match[prop] = update[prop];\n                        }\n                    }\n\n                    // delete, if specified, must be an array of strings (or single string)\n                    if(typeof expr.delete !== 'undefined') {\n                        var deletions = await evaluate(expr.delete, match, environment);\n                        if(typeof deletions !== 'undefined') {\n                            var val = deletions;\n                            if (!Array.isArray(deletions)) {\n                                deletions = [deletions];\n                            }\n                            if (!isArrayOfStrings(deletions)) {\n                                // throw type error\n                                throw {\n                                    code: \"T2012\",\n                                    stack: (new Error()).stack,\n                                    position: expr.delete.position,\n                                    value: val\n                                };\n                            }\n                            for (var jj = 0; jj < deletions.length; jj++) {\n                                if(typeof match === 'object' && match !== null) {\n                                    delete match[deletions[jj]];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            return result;\n        };\n\n        return defineFunction(transformer, '<(oa):o>');\n    }\n\n    var chainAST = parser('function($f, $g) { function($x){ $g($f($x)) } }');\n\n    /**\n     * Apply the function on the RHS using the sequence on the LHS as the first argument\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateApplyExpression(expr, input, environment) {\n        var result;\n\n\n        var lhs = await evaluate(expr.lhs, input, environment);\n        if(expr.rhs.type === 'function') {\n            // this is a function _invocation_; invoke it with lhs expression as the first argument\n            result = await evaluateFunction(expr.rhs, input, environment, { context: lhs });\n        } else {\n            var func = await evaluate(expr.rhs, input, environment);\n\n            if(!isFunction(func)) {\n                throw {\n                    code: \"T2006\",\n                    stack: (new Error()).stack,\n                    position: expr.position,\n                    value: func\n                };\n            }\n\n            if(isFunction(lhs)) {\n                // this is function chaining (func1 ~> func2)\n                // Î»($f, $g) { Î»($x){ $g($f($x)) } }\n                var chain = await evaluate(chainAST, null, environment);\n                result = await apply(chain, [lhs, func], null, environment);\n            } else {\n                result = await apply(func, [lhs], null, environment);\n            }\n\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate function against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluateFunction(expr, input, environment, applyto) {\n        var result;\n\n        // create the procedure\n        // can't assume that expr.procedure is a lambda type directly\n        // could be an expression that evaluates to a function (e.g. variable reference, parens expr etc.\n        // evaluate it generically first, then check that it is a function.  Throw error if not.\n        var proc = await evaluate(expr.procedure, input, environment);\n\n        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {\n            // help the user out here if they simply forgot the leading $\n            throw {\n                code: \"T1005\",\n                stack: (new Error()).stack,\n                position: expr.position,\n                token: expr.procedure.steps[0].value\n            };\n        }\n\n        var evaluatedArgs = [];\n        if(typeof applyto !== 'undefined') {\n            evaluatedArgs.push(applyto.context);\n        }\n        // eager evaluation - evaluate the arguments\n        for (var jj = 0; jj < expr.arguments.length; jj++) {\n            const arg = await evaluate(expr.arguments[jj], input, environment);\n            if(isFunction(arg)) {\n                // wrap this in a closure\n                const closure = async function (...params) {\n                    // invoke func\n                    return await apply(arg, params, null, environment);\n                };\n                closure.arity = getFunctionArity(arg);\n                evaluatedArgs.push(closure);\n            } else {\n                evaluatedArgs.push(arg);\n            }\n        }\n        // apply the procedure\n        var procName = expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value;\n        try {\n            if(typeof proc === 'object') {\n                proc.token = procName;\n                proc.position = expr.position;\n            }\n            result = await apply(proc, evaluatedArgs, input, environment);\n        } catch (err) {\n            if(!err.position) {\n                // add the position field to the error\n                err.position = expr.position;\n            }\n            if (!err.token) {\n                // and the function identifier\n                err.token = procName;\n            }\n            throw err;\n        }\n        return result;\n    }\n\n    /**\n     * Apply procedure or function\n     * @param {Object} proc - Procedure\n     * @param {Array} args - Arguments\n     * @param {Object} input - input\n     * @param {Object} environment - environment\n     * @returns {*} Result of procedure\n     */\n    async function apply(proc, args, input, environment) {\n        var result;\n        result = await applyInner(proc, args, input, environment);\n        while(isLambda(result) && result.thunk === true) {\n            // trampoline loop - this gets invoked as a result of tail-call optimization\n            // the function returned a tail-call thunk\n            // unpack it, evaluate its arguments, and apply the tail call\n            var next = await evaluate(result.body.procedure, result.input, result.environment);\n            if(result.body.procedure.type === 'variable') {\n                next.token = result.body.procedure.value;\n            }\n            next.position = result.body.procedure.position;\n            var evaluatedArgs = [];\n            for(var ii = 0; ii < result.body.arguments.length; ii++) {\n                evaluatedArgs.push(await evaluate(result.body.arguments[ii], result.input, result.environment));\n            }\n\n            result = await applyInner(next, evaluatedArgs, input, environment);\n        }\n        return result;\n    }\n\n    /**\n     * Apply procedure or function\n     * @param {Object} proc - Procedure\n     * @param {Array} args - Arguments\n     * @param {Object} input - input\n     * @param {Object} environment - environment\n     * @returns {*} Result of procedure\n     */\n    async function applyInner(proc, args, input, environment) {\n        var result;\n        try {\n            var validatedArgs = args;\n            if (proc) {\n                validatedArgs = validateArguments(proc.signature, args, input);\n            }\n\n            if (isLambda(proc)) {\n                result = await applyProcedure(proc, validatedArgs);\n            } else if (proc && proc._jsonata_function === true) {\n                var focus = {\n                    environment: environment,\n                    input: input\n                };\n                // the `focus` is passed in as the `this` for the invoked function\n                result = proc.implementation.apply(focus, validatedArgs);\n                // `proc.implementation` might be a generator function\n                // and `result` might be a generator - if so, yield\n                if (isIterable(result)) {\n                    result = result.next().value;\n                }\n                if (isPromise(result)) {\n                    result = await result;\n                }\n            } else if (typeof proc === 'function') {\n                // typically these are functions that are returned by the invocation of plugin functions\n                // the `input` is being passed in as the `this` for the invoked function\n                // this is so that functions that return objects containing functions can chain\n                // e.g. await (await $func())\n                result = proc.apply(input, validatedArgs);\n                if (isPromise(result)) {\n                    result = await result;\n                }\n            } else {\n                throw {\n                    code: \"T1006\",\n                    stack: (new Error()).stack\n                };\n            }\n        } catch(err) {\n            if(proc) {\n                if (typeof err.token == 'undefined' && typeof proc.token !== 'undefined') {\n                    err.token = proc.token;\n                }\n                err.position = proc.position || err.position;\n            }\n            throw err;\n        }\n        return result;\n    }\n\n    /**\n     * Evaluate lambda against input data\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {{lambda: boolean, input: *, environment: *, arguments: *, body: *}} Evaluated input data\n     */\n    function evaluateLambda(expr, input, environment) {\n        // make a function (closure)\n        var procedure = {\n            _jsonata_lambda: true,\n            input: input,\n            environment: environment,\n            arguments: expr.arguments,\n            signature: expr.signature,\n            body: expr.body\n        };\n        if(expr.thunk === true) {\n            procedure.thunk = true;\n        }\n        procedure.apply = async function(self, args) {\n            return await apply(procedure, args, input, !!self ? self.environment : environment);\n        };\n        return procedure;\n    }\n\n    /**\n     * Evaluate partial application\n     * @param {Object} expr - JSONata expression\n     * @param {Object} input - Input data to evaluate against\n     * @param {Object} environment - Environment\n     * @returns {*} Evaluated input data\n     */\n    async function evaluatePartialApplication(expr, input, environment) {\n        // partially apply a function\n        var result;\n        // evaluate the arguments\n        var evaluatedArgs = [];\n        for(var ii = 0; ii < expr.arguments.length; ii++) {\n            var arg = expr.arguments[ii];\n            if (arg.type === 'operator' && arg.value === '?') {\n                evaluatedArgs.push(arg);\n            } else {\n                evaluatedArgs.push(await evaluate(arg, input, environment));\n            }\n        }\n        // lookup the procedure\n        var proc = await evaluate(expr.procedure, input, environment);\n        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {\n            // help the user out here if they simply forgot the leading $\n            throw {\n                code: \"T1007\",\n                stack: (new Error()).stack,\n                position: expr.position,\n                token: expr.procedure.steps[0].value\n            };\n        }\n        if (isLambda(proc)) {\n            result = partialApplyProcedure(proc, evaluatedArgs);\n        } else if (proc && proc._jsonata_function === true) {\n            result = partialApplyNativeFunction(proc.implementation, evaluatedArgs);\n        } else if (typeof proc === 'function') {\n            result = partialApplyNativeFunction(proc, evaluatedArgs);\n        } else {\n            throw {\n                code: \"T1008\",\n                stack: (new Error()).stack,\n                position: expr.position,\n                token: expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value\n            };\n        }\n        return result;\n    }\n\n    /**\n     * Validate the arguments against the signature validator (if it exists)\n     * @param {Function} signature - validator function\n     * @param {Array} args - function arguments\n     * @param {*} context - context value\n     * @returns {Array} - validated arguments\n     */\n    function validateArguments(signature, args, context) {\n        if(typeof signature === 'undefined') {\n            // nothing to validate\n            return args;\n        }\n        var validatedArgs = signature.validate(args, context);\n        return validatedArgs;\n    }\n\n    /**\n     * Apply procedure\n     * @param {Object} proc - Procedure\n     * @param {Array} args - Arguments\n     * @returns {*} Result of procedure\n     */\n    async function applyProcedure(proc, args) {\n        var result;\n        var env = createFrame(proc.environment);\n        proc.arguments.forEach(function (param, index) {\n            env.bind(param.value, args[index]);\n        });\n        if (typeof proc.body === 'function') {\n            // this is a lambda that wraps a native function - generated by partially evaluating a native\n            result = await applyNativeFunction(proc.body, env);\n        } else {\n            result = await evaluate(proc.body, proc.input, env);\n        }\n        return result;\n    }\n\n    /**\n     * Partially apply procedure\n     * @param {Object} proc - Procedure\n     * @param {Array} args - Arguments\n     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applied procedure\n     */\n    function partialApplyProcedure(proc, args) {\n        // create a closure, bind the supplied parameters and return a function that takes the remaining (?) parameters\n        var env = createFrame(proc.environment);\n        var unboundArgs = [];\n        proc.arguments.forEach(function (param, index) {\n            var arg = args[index];\n            if (arg && arg.type === 'operator' && arg.value === '?') {\n                unboundArgs.push(param);\n            } else {\n                env.bind(param.value, arg);\n            }\n        });\n        var procedure = {\n            _jsonata_lambda: true,\n            input: proc.input,\n            environment: env,\n            arguments: unboundArgs,\n            body: proc.body\n        };\n        return procedure;\n    }\n\n    /**\n     * Partially apply native function\n     * @param {Function} native - Native function\n     * @param {Array} args - Arguments\n     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applying native function\n     */\n    function partialApplyNativeFunction(native, args) {\n        // create a lambda function that wraps and invokes the native function\n        // get the list of declared arguments from the native function\n        // this has to be picked out from the toString() value\n        var sigArgs = getNativeFunctionArguments(native);\n        sigArgs = sigArgs.map(function (sigArg) {\n            return '$' + sigArg.trim();\n        });\n        var body = 'function(' + sigArgs.join(', ') + '){ _ }';\n\n        var bodyAST = parser(body);\n        bodyAST.body = native;\n\n        var partial = partialApplyProcedure(bodyAST, args);\n        return partial;\n    }\n\n    /**\n     * Apply native function\n     * @param {Object} proc - Procedure\n     * @param {Object} env - Environment\n     * @returns {*} Result of applying native function\n     */\n    async function applyNativeFunction(proc, env) {\n        var sigArgs = getNativeFunctionArguments(proc);\n        // generate the array of arguments for invoking the function - look them up in the environment\n        var args = sigArgs.map(function (sigArg) {\n            return env.lookup(sigArg.trim());\n        });\n\n        var focus = {\n            environment: env\n        };\n        var result = proc.apply(focus, args);\n        if (isPromise(result)) {\n            result = await result;\n        }\n        return result;\n    }\n\n    /**\n     * Get native function arguments\n     * @param {Function} func - Function\n     * @returns {*|Array} Native function arguments\n     */\n    function getNativeFunctionArguments(func) {\n        var signature = func.toString();\n        var sigParens = /\\(([^)]*)\\)/.exec(signature)[1]; // the contents of the parens\n        var sigArgs = sigParens.split(',');\n        return sigArgs;\n    }\n\n    /**\n     * Creates a function definition\n     * @param {Function} func - function implementation in Javascript\n     * @param {string} signature - JSONata function signature definition\n     * @returns {{implementation: *, signature: *}} function definition\n     */\n    function defineFunction(func, signature) {\n        var definition = {\n            _jsonata_function: true,\n            implementation: func\n        };\n        if(typeof signature !== 'undefined') {\n            definition.signature = parseSignature(signature);\n        }\n        return definition;\n    }\n\n\n    /**\n     * parses and evaluates the supplied expression\n     * @param {string} expr - expression to evaluate\n     * @returns {*} - result of evaluating the expression\n     */\n    async function functionEval(expr, focus) {\n        // undefined inputs always return undefined\n        if(typeof expr === 'undefined') {\n            return undefined;\n        }\n        var input = this.input;\n        if(typeof focus !== 'undefined') {\n            input = focus;\n            // if the input is a JSON array, then wrap it in a singleton sequence so it gets treated as a single input\n            if(Array.isArray(input) && !isSequence(input)) {\n                input = createSequence(input);\n                input.outerWrapper = true;\n            }\n        }\n\n        try {\n            var ast = parser(expr, false);\n        } catch(err) {\n            // error parsing the expression passed to $eval\n            populateMessage(err);\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3120\",\n                value: err.message,\n                error: err\n            };\n        }\n        try {\n            var result = await evaluate(ast, input, this.environment);\n        } catch(err) {\n            // error evaluating the expression passed to $eval\n            populateMessage(err);\n            throw {\n                stack: (new Error()).stack,\n                code: \"D3121\",\n                value:err.message,\n                error: err\n            };\n        }\n\n        return result;\n    }\n\n    /**\n     * Clones an object\n     * @param {Object} arg - object to clone (deep copy)\n     * @returns {*} - the cloned object\n     */\n    function functionClone(arg) {\n        // undefined inputs always return undefined\n        if(typeof arg === 'undefined') {\n            return undefined;\n        }\n\n        return JSON.parse(fn.string(arg));\n    }\n\n    /**\n     * Create frame\n     * @param {Object} enclosingEnvironment - Enclosing environment\n     * @returns {{bind: bind, lookup: lookup}} Created frame\n     */\n    function createFrame(enclosingEnvironment) {\n        var bindings = {};\n        return {\n            bind: function (name, value) {\n                bindings[name] = value;\n            },\n            lookup: function (name) {\n                var value;\n                if(bindings.hasOwnProperty(name)) {\n                    value = bindings[name];\n                } else if (enclosingEnvironment) {\n                    value = enclosingEnvironment.lookup(name);\n                }\n                return value;\n            },\n            timestamp: enclosingEnvironment ? enclosingEnvironment.timestamp : null,\n            async: enclosingEnvironment ? enclosingEnvironment.async : false,\n            isParallelCall: enclosingEnvironment ? enclosingEnvironment.isParallelCall : false,\n            global: enclosingEnvironment ? enclosingEnvironment.global : {\n                ancestry: [ null ]\n            }\n        };\n    }\n\n    // Function registration\n    staticFrame.bind('sum', defineFunction(fn.sum, '<a<n>:n>'));\n    staticFrame.bind('count', defineFunction(fn.count, '<a:n>'));\n    staticFrame.bind('max', defineFunction(fn.max, '<a<n>:n>'));\n    staticFrame.bind('min', defineFunction(fn.min, '<a<n>:n>'));\n    staticFrame.bind('average', defineFunction(fn.average, '<a<n>:n>'));\n    staticFrame.bind('string', defineFunction(fn.string, '<x-b?:s>'));\n    staticFrame.bind('substring', defineFunction(fn.substring, '<s-nn?:s>'));\n    staticFrame.bind('substringBefore', defineFunction(fn.substringBefore, '<s-s:s>'));\n    staticFrame.bind('substringAfter', defineFunction(fn.substringAfter, '<s-s:s>'));\n    staticFrame.bind('lowercase', defineFunction(fn.lowercase, '<s-:s>'));\n    staticFrame.bind('uppercase', defineFunction(fn.uppercase, '<s-:s>'));\n    staticFrame.bind('length', defineFunction(fn.length, '<s-:n>'));\n    staticFrame.bind('trim', defineFunction(fn.trim, '<s-:s>'));\n    staticFrame.bind('pad', defineFunction(fn.pad, '<s-ns?:s>'));\n    staticFrame.bind('match', defineFunction(fn.match, '<s-f<s:o>n?:a<o>>'));\n    staticFrame.bind('contains', defineFunction(fn.contains, '<s-(sf):b>')); // TODO <s-(sf<s:o>):b>\n    staticFrame.bind('replace', defineFunction(fn.replace, '<s-(sf)(sf)n?:s>')); // TODO <s-(sf<s:o>)(sf<o:s>)n?:s>\n    staticFrame.bind('split', defineFunction(fn.split, '<s-(sf)n?:a<s>>')); // TODO <s-(sf<s:o>)n?:a<s>>\n    staticFrame.bind('join', defineFunction(fn.join, '<a<s>s?:s>'));\n    staticFrame.bind('formatNumber', defineFunction(fn.formatNumber, '<n-so?:s>'));\n    staticFrame.bind('formatBase', defineFunction(fn.formatBase, '<n-n?:s>'));\n    staticFrame.bind('formatInteger', defineFunction(datetime.formatInteger, '<n-s:s>'));\n    staticFrame.bind('parseInteger', defineFunction(datetime.parseInteger, '<s-s:n>'));\n    staticFrame.bind('number', defineFunction(fn.number, '<(nsb)-:n>'));\n    staticFrame.bind('floor', defineFunction(fn.floor, '<n-:n>'));\n    staticFrame.bind('ceil', defineFunction(fn.ceil, '<n-:n>'));\n    staticFrame.bind('round', defineFunction(fn.round, '<n-n?:n>'));\n    staticFrame.bind('abs', defineFunction(fn.abs, '<n-:n>'));\n    staticFrame.bind('sqrt', defineFunction(fn.sqrt, '<n-:n>'));\n    staticFrame.bind('power', defineFunction(fn.power, '<n-n:n>'));\n    staticFrame.bind('random', defineFunction(fn.random, '<:n>'));\n    staticFrame.bind('boolean', defineFunction(fn.boolean, '<x-:b>'));\n    staticFrame.bind('not', defineFunction(fn.not, '<x-:b>'));\n    staticFrame.bind('map', defineFunction(fn.map, '<af>'));\n    staticFrame.bind('zip', defineFunction(fn.zip, '<a+>'));\n    staticFrame.bind('filter', defineFunction(fn.filter, '<af>'));\n    staticFrame.bind('single', defineFunction(fn.single, '<af?>'));\n    staticFrame.bind('reduce', defineFunction(fn.foldLeft, '<afj?:j>')); // TODO <f<jj:j>a<j>j?:j>\n    staticFrame.bind('sift', defineFunction(fn.sift, '<o-f?:o>'));\n    staticFrame.bind('keys', defineFunction(fn.keys, '<x-:a<s>>'));\n    staticFrame.bind('lookup', defineFunction(fn.lookup, '<x-s:x>'));\n    staticFrame.bind('append', defineFunction(fn.append, '<xx:a>'));\n    staticFrame.bind('exists', defineFunction(fn.exists, '<x:b>'));\n    staticFrame.bind('spread', defineFunction(fn.spread, '<x-:a<o>>'));\n    staticFrame.bind('merge', defineFunction(fn.merge, '<a<o>:o>'));\n    staticFrame.bind('reverse', defineFunction(fn.reverse, '<a:a>'));\n    staticFrame.bind('each', defineFunction(fn.each, '<o-f:a>'));\n    staticFrame.bind('error', defineFunction(fn.error, '<s?:x>'));\n    staticFrame.bind('assert', defineFunction(fn.assert, '<bs?:x>'));\n    staticFrame.bind('type', defineFunction(fn.type, '<x:s>'));\n    staticFrame.bind('sort', defineFunction(fn.sort, '<af?:a>'));\n    staticFrame.bind('shuffle', defineFunction(fn.shuffle, '<a:a>'));\n    staticFrame.bind('distinct', defineFunction(fn.distinct, '<x:x>'));\n    staticFrame.bind('base64encode', defineFunction(fn.base64encode, '<s-:s>'));\n    staticFrame.bind('base64decode', defineFunction(fn.base64decode, '<s-:s>'));\n    staticFrame.bind('encodeUrlComponent', defineFunction(fn.encodeUrlComponent, '<s-:s>'));\n    staticFrame.bind('encodeUrl', defineFunction(fn.encodeUrl, '<s-:s>'));\n    staticFrame.bind('decodeUrlComponent', defineFunction(fn.decodeUrlComponent, '<s-:s>'));\n    staticFrame.bind('decodeUrl', defineFunction(fn.decodeUrl, '<s-:s>'));\n    staticFrame.bind('eval', defineFunction(functionEval, '<sx?:x>'));\n    staticFrame.bind('toMillis', defineFunction(datetime.toMillis, '<s-s?:n>'));\n    staticFrame.bind('fromMillis', defineFunction(datetime.fromMillis, '<n-s?s?:s>'));\n    staticFrame.bind('clone', defineFunction(functionClone, '<(oa)-:o>'));\n\n    /**\n     * Error codes\n     *\n     * Sxxxx    - Static errors (compile time)\n     * Txxxx    - Type errors\n     * Dxxxx    - Dynamic errors (evaluate time)\n     *  01xx    - tokenizer\n     *  02xx    - parser\n     *  03xx    - regex parser\n     *  04xx    - function signature parser/evaluator\n     *  10xx    - evaluator\n     *  20xx    - operators\n     *  3xxx    - functions (blocks of 10 for each function)\n     */\n    var errorCodes = {\n        \"S0101\": \"String literal must be terminated by a matching quote\",\n        \"S0102\": \"Number out of range: {{token}}\",\n        \"S0103\": \"Unsupported escape sequence: \\\\{{token}}\",\n        \"S0104\": \"The escape sequence \\\\u must be followed by 4 hex digits\",\n        \"S0105\": \"Quoted property name must be terminated with a backquote (`)\",\n        \"S0106\": \"Comment has no closing tag\",\n        \"S0201\": \"Syntax error: {{token}}\",\n        \"S0202\": \"Expected {{value}}, got {{token}}\",\n        \"S0203\": \"Expected {{value}} before end of expression\",\n        \"S0204\": \"Unknown operator: {{token}}\",\n        \"S0205\": \"Unexpected token: {{token}}\",\n        \"S0206\": \"Unknown expression type: {{token}}\",\n        \"S0207\": \"Unexpected end of expression\",\n        \"S0208\": \"Parameter {{value}} of function definition must be a variable name (start with $)\",\n        \"S0209\": \"A predicate cannot follow a grouping expression in a step\",\n        \"S0210\": \"Each step can only have one grouping expression\",\n        \"S0211\": \"The symbol {{token}} cannot be used as a unary operator\",\n        \"S0212\": \"The left side of := must be a variable name (start with $)\",\n        \"S0213\": \"The literal value {{value}} cannot be used as a step within a path expression\",\n        \"S0214\": \"The right side of {{token}} must be a variable name (start with $)\",\n        \"S0215\": \"A context variable binding must precede any predicates on a step\",\n        \"S0216\": \"A context variable binding must precede the 'order-by' clause on a step\",\n        \"S0217\": \"The object representing the 'parent' cannot be derived from this expression\",\n        \"S0301\": \"Empty regular expressions are not allowed\",\n        \"S0302\": \"No terminating / in regular expression\",\n        \"S0402\": \"Choice groups containing parameterized types are not supported\",\n        \"S0401\": \"Type parameters can only be applied to functions and arrays\",\n        \"S0500\": \"Attempted to evaluate an expression containing syntax error(s)\",\n        \"T0410\": \"Argument {{index}} of function {{token}} does not match function signature\",\n        \"T0411\": \"Context value is not a compatible type with argument {{index}} of function {{token}}\",\n        \"T0412\": \"Argument {{index}} of function {{token}} must be an array of {{type}}\",\n        \"D1001\": \"Number out of range: {{value}}\",\n        \"D1002\": \"Cannot negate a non-numeric value: {{value}}\",\n        \"T1003\": \"Key in object structure must evaluate to a string; got: {{value}}\",\n        \"D1004\": \"Regular expression matches zero length string\",\n        \"T1005\": \"Attempted to invoke a non-function. Did you mean ${{{token}}}?\",\n        \"T1006\": \"Attempted to invoke a non-function\",\n        \"T1007\": \"Attempted to partially apply a non-function. Did you mean ${{{token}}}?\",\n        \"T1008\": \"Attempted to partially apply a non-function\",\n        \"D1009\": \"Multiple key definitions evaluate to same key: {{value}}\",\n        \"D1010\": \"Attempted to access the Javascript object prototype\", // Javascript specific \n        \"T1010\": \"The matcher function argument passed to function {{token}} does not return the correct object structure\",\n        \"T2001\": \"The left side of the {{token}} operator must evaluate to a number\",\n        \"T2002\": \"The right side of the {{token}} operator must evaluate to a number\",\n        \"T2003\": \"The left side of the range operator (..) must evaluate to an integer\",\n        \"T2004\": \"The right side of the range operator (..) must evaluate to an integer\",\n        \"D2005\": \"The left side of := must be a variable name (start with $)\",  // defunct - replaced by S0212 parser error\n        \"T2006\": \"The right side of the function application operator ~> must be a function\",\n        \"T2007\": \"Type mismatch when comparing values {{value}} and {{value2}} in order-by clause\",\n        \"T2008\": \"The expressions within an order-by clause must evaluate to numeric or string values\",\n        \"T2009\": \"The values {{value}} and {{value2}} either side of operator {{token}} must be of the same data type\",\n        \"T2010\": \"The expressions either side of operator {{token}} must evaluate to numeric or string values\",\n        \"T2011\": \"The insert/update clause of the transform expression must evaluate to an object: {{value}}\",\n        \"T2012\": \"The delete clause of the transform expression must evaluate to a string or array of strings: {{value}}\",\n        \"T2013\": \"The transform expression clones the input object using the $clone() function.  This has been overridden in the current scope by a non-function.\",\n        \"D2014\": \"The size of the sequence allocated by the range operator (..) must not exceed 1e6.  Attempted to allocate {{value}}.\",\n        \"D3001\": \"Attempting to invoke string function on Infinity or NaN\",\n        \"D3010\": \"Second argument of replace function cannot be an empty string\",\n        \"D3011\": \"Fourth argument of replace function must evaluate to a positive number\",\n        \"D3012\": \"Attempted to replace a matched string with a non-string value\",\n        \"D3020\": \"Third argument of split function must evaluate to a positive number\",\n        \"D3030\": \"Unable to cast value to a number: {{value}}\",\n        \"D3040\": \"Third argument of match function must evaluate to a positive number\",\n        \"D3050\": \"The second argument of reduce function must be a function with at least two arguments\",\n        \"D3060\": \"The sqrt function cannot be applied to a negative number: {{value}}\",\n        \"D3061\": \"The power function has resulted in a value that cannot be represented as a JSON number: base={{value}}, exponent={{exp}}\",\n        \"D3070\": \"The single argument form of the sort function can only be applied to an array of strings or an array of numbers.  Use the second argument to specify a comparison function\",\n        \"D3080\": \"The picture string must only contain a maximum of two sub-pictures\",\n        \"D3081\": \"The sub-picture must not contain more than one instance of the 'decimal-separator' character\",\n        \"D3082\": \"The sub-picture must not contain more than one instance of the 'percent' character\",\n        \"D3083\": \"The sub-picture must not contain more than one instance of the 'per-mille' character\",\n        \"D3084\": \"The sub-picture must not contain both a 'percent' and a 'per-mille' character\",\n        \"D3085\": \"The mantissa part of a sub-picture must contain at least one character that is either an 'optional digit character' or a member of the 'decimal digit family'\",\n        \"D3086\": \"The sub-picture must not contain a passive character that is preceded by an active character and that is followed by another active character\",\n        \"D3087\": \"The sub-picture must not contain a 'grouping-separator' character that appears adjacent to a 'decimal-separator' character\",\n        \"D3088\": \"The sub-picture must not contain a 'grouping-separator' at the end of the integer part\",\n        \"D3089\": \"The sub-picture must not contain two adjacent instances of the 'grouping-separator' character\",\n        \"D3090\": \"The integer part of the sub-picture must not contain a member of the 'decimal digit family' that is followed by an instance of the 'optional digit character'\",\n        \"D3091\": \"The fractional part of the sub-picture must not contain an instance of the 'optional digit character' that is followed by a member of the 'decimal digit family'\",\n        \"D3092\": \"A sub-picture that contains a 'percent' or 'per-mille' character must not contain a character treated as an 'exponent-separator'\",\n        \"D3093\": \"The exponent part of the sub-picture must comprise only of one or more characters that are members of the 'decimal digit family'\",\n        \"D3100\": \"The radix of the formatBase function must be between 2 and 36.  It was given {{value}}\",\n        \"D3110\": \"The argument of the toMillis function must be an ISO 8601 formatted timestamp. Given {{value}}\",\n        \"D3120\": \"Syntax error in expression passed to function eval: {{value}}\",\n        \"D3121\": \"Dynamic error evaluating the expression passed to function eval: {{value}}\",\n        \"D3130\": \"Formatting or parsing an integer as a sequence starting with {{value}} is not supported by this implementation\",\n        \"D3131\": \"In a decimal digit pattern, all digits must be from the same decimal group\",\n        \"D3132\": \"Unknown component specifier {{value}} in date/time picture string\",\n        \"D3133\": \"The 'name' modifier can only be applied to months and days in the date/time picture string, not {{value}}\",\n        \"D3134\": \"The timezone integer format specifier cannot have more than four digits\",\n        \"D3135\": \"No matching closing bracket ']' in date/time picture string\",\n        \"D3136\": \"The date/time picture string is missing specifiers required to parse the timestamp\",\n        \"D3137\": \"{{{message}}}\",\n        \"D3138\": \"The $single() function expected exactly 1 matching result.  Instead it matched more.\",\n        \"D3139\": \"The $single() function expected exactly 1 matching result.  Instead it matched 0.\",\n        \"D3140\": \"Malformed URL passed to ${{{functionName}}}(): {{value}}\",\n        \"D3141\": \"{{{message}}}\"\n    };\n\n    /**\n     * lookup a message template from the catalog and substitute the inserts.\n     * Populates `err.message` with the substituted message. Leaves `err.message`\n     * untouched if code lookup fails.\n     * @param {string} err - error code to lookup\n     * @returns {undefined} - `err` is modified in place\n     */\n    function populateMessage(err) {\n        var template = errorCodes[err.code];\n        if(typeof template !== 'undefined') {\n            // if there are any handlebars, replace them with the field references\n            // triple braces - replace with value\n            // double braces - replace with json stringified value\n            var message = template.replace(/\\{\\{\\{([^}]+)}}}/g, function() {\n                return err[arguments[1]];\n            });\n            message = message.replace(/\\{\\{([^}]+)}}/g, function() {\n                return JSON.stringify(err[arguments[1]]);\n            });\n            err.message = message;\n        }\n        // Otherwise retain the original `err.message`\n    }\n\n    /**\n     * JSONata\n     * @param {Object} expr - JSONata expression\n     * @param {Object} options\n     * @param {boolean} options.recover: attempt to recover on parse error\n     * @param {Function} options.RegexEngine: RegEx class constructor to use\n     * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression\n     */\n    function jsonata(expr, options) {\n        var ast;\n        var errors;\n        try {\n            ast = parser(expr, options && options.recover);\n            errors = ast.errors;\n            delete ast.errors;\n        } catch(err) {\n            // insert error message into structure\n            populateMessage(err); // possible side-effects on `err`\n            throw err;\n        }\n        var environment = createFrame(staticFrame);\n\n        var timestamp = new Date(); // will be overridden on each call to evalute()\n        environment.bind('now', defineFunction(function(picture, timezone) {\n            return datetime.fromMillis(timestamp.getTime(), picture, timezone);\n        }, '<s?s?:s>'));\n        environment.bind('millis', defineFunction(function() {\n            return timestamp.getTime();\n        }, '<:n>'));\n\n        if(options && options.RegexEngine) {\n            jsonata.RegexEngine = options.RegexEngine;\n        } else {\n            jsonata.RegexEngine = RegExp;\n        }\n\n        return {\n            evaluate: async function (input, bindings, callback) {\n                // throw if the expression compiled with syntax errors\n                if(typeof errors !== 'undefined') {\n                    var err = {\n                        code: 'S0500',\n                        position: 0\n                    };\n                    populateMessage(err); // possible side-effects on `err`\n                    throw err;\n                }\n\n                if (typeof bindings !== 'undefined') {\n                    var exec_env;\n                    // the variable bindings have been passed in - create a frame to hold these\n                    exec_env = createFrame(environment);\n                    for (var v in bindings) {\n                        exec_env.bind(v, bindings[v]);\n                    }\n                } else {\n                    exec_env = environment;\n                }\n                // put the input document into the environment as the root object\n                exec_env.bind('$', input);\n\n                // capture the timestamp and put it in the execution environment\n                // the $now() and $millis() functions will return this value - whenever it is called\n                timestamp = new Date();\n                exec_env.timestamp = timestamp;\n\n                // if the input is a JSON array, then wrap it in a singleton sequence so it gets treated as a single input\n                if(Array.isArray(input) && !isSequence(input)) {\n                    input = createSequence(input);\n                    input.outerWrapper = true;\n                }\n\n                var it;\n                try {\n                    it = await evaluate(ast, input, exec_env);\n                    if (typeof callback === \"function\") {\n                        callback(null, it);\n                    }\n                    return it;\n                } catch (err) {\n                    // insert error message into structure\n                    populateMessage(err); // possible side-effects on `err`\n                    throw err;\n                }\n            },\n            assign: function (name, value) {\n                environment.bind(name, value);\n            },\n            registerFunction: function(name, implementation, signature) {\n                var func = defineFunction(implementation, signature);\n                environment.bind(name, func);\n            },\n            ast: function() {\n                return ast;\n            },\n            errors: function() {\n                return errors;\n            }\n        };\n    }\n\n    jsonata.parser = parser; // TODO remove this in a future release - use ast() instead\n\n    return jsonata;\n\n})();\n\nmodule.exports = jsonata;\n\n},{\"./datetime\":1,\"./functions\":2,\"./parser\":4,\"./signature\":5,\"./utils\":6}],4:[function(require,module,exports){\n/**\n * Â© Copyright IBM Corp. 2016, 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nvar parseSignature = require('./signature');\n\nconst parser = (() => {\n    'use strict';\n\n    var operators = {\n        '.': 75,\n        '[': 80,\n        ']': 0,\n        '{': 70,\n        '}': 0,\n        '(': 80,\n        ')': 0,\n        ',': 0,\n        '@': 80,\n        '#': 80,\n        ';': 80,\n        ':': 80,\n        '?': 20,\n        '+': 50,\n        '-': 50,\n        '*': 60,\n        '/': 60,\n        '%': 60,\n        '|': 20,\n        '=': 40,\n        '<': 40,\n        '>': 40,\n        '^': 40,\n        '**': 60,\n        '..': 20,\n        ':=': 10,\n        '!=': 40,\n        '<=': 40,\n        '>=': 40,\n        '~>': 40,\n        'and': 30,\n        'or': 25,\n        'in': 40,\n        '&': 50,\n        '!': 0,   // not an operator, but needed as a stop character for name tokens\n        '~': 0   // not an operator, but needed as a stop character for name tokens\n    };\n\n    var escapes = {  // JSON string escape sequences - see json.org\n        '\"': '\"',\n        '\\\\': '\\\\',\n        '/': '/',\n        'b': '\\b',\n        'f': '\\f',\n        'n': '\\n',\n        'r': '\\r',\n        't': '\\t'\n    };\n\n    // Tokenizer (lexer) - invoked by the parser to return one token at a time\n    var tokenizer = function (path) {\n        var position = 0;\n        var length = path.length;\n\n        var create = function (type, value) {\n            var obj = {type: type, value: value, position: position};\n            return obj;\n        };\n\n        var scanRegex = function () {\n            // the prefix '/' will have been previously scanned. Find the end of the regex.\n            // search for closing '/' ignoring any that are escaped, or within brackets\n            var start = position;\n            var depth = 0;\n            var pattern;\n            var flags;\n\n            var isClosingSlash = function (position) {\n                if (path.charAt(position) === '/' && depth === 0) {\n                    var backslashCount = 0;\n                    while (path.charAt(position - (backslashCount + 1)) === '\\\\') {\n                        backslashCount++;\n                    }\n                    if (backslashCount % 2 === 0) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n\n            while (position < length) {\n                var currentChar = path.charAt(position);\n                if (isClosingSlash(position)) {\n                    // end of regex found\n                    pattern = path.substring(start, position);\n                    if (pattern === '') {\n                        throw {\n                            code: \"S0301\",\n                            stack: (new Error()).stack,\n                            position: position\n                        };\n                    }\n                    position++;\n                    currentChar = path.charAt(position);\n                    // flags\n                    start = position;\n                    while (currentChar === 'i' || currentChar === 'm') {\n                        position++;\n                        currentChar = path.charAt(position);\n                    }\n                    flags = path.substring(start, position) + 'g';\n                    return new RegExp(pattern, flags);\n                }\n                if ((currentChar === '(' || currentChar === '[' || currentChar === '{') && path.charAt(position - 1) !== '\\\\') {\n                    depth++;\n                }\n                if ((currentChar === ')' || currentChar === ']' || currentChar === '}') && path.charAt(position - 1) !== '\\\\') {\n                    depth--;\n                }\n\n                position++;\n            }\n            throw {\n                code: \"S0302\",\n                stack: (new Error()).stack,\n                position: position\n            };\n        };\n\n        var next = function (prefix) {\n            if (position >= length) return null;\n            var currentChar = path.charAt(position);\n            // skip whitespace\n            while (position < length && ' \\t\\n\\r\\v'.indexOf(currentChar) > -1) {\n                position++;\n                currentChar = path.charAt(position);\n            }\n            // skip comments\n            if (currentChar === '/' && path.charAt(position + 1) === '*') {\n                var commentStart = position;\n                position += 2;\n                currentChar = path.charAt(position);\n                while (!(currentChar === '*' && path.charAt(position + 1) === '/')) {\n                    currentChar = path.charAt(++position);\n                    if (position >= length) {\n                        // no closing tag\n                        throw {\n                            code: \"S0106\",\n                            stack: (new Error()).stack,\n                            position: commentStart\n                        };\n                    }\n                }\n                position += 2;\n                currentChar = path.charAt(position);\n                return next(prefix); // need this to swallow any following whitespace\n            }\n            // test for regex\n            if (prefix !== true && currentChar === '/') {\n                position++;\n                return create('regex', scanRegex());\n            }\n            // handle double-char operators\n            if (currentChar === '.' && path.charAt(position + 1) === '.') {\n                // double-dot .. range operator\n                position += 2;\n                return create('operator', '..');\n            }\n            if (currentChar === ':' && path.charAt(position + 1) === '=') {\n                // := assignment\n                position += 2;\n                return create('operator', ':=');\n            }\n            if (currentChar === '!' && path.charAt(position + 1) === '=') {\n                // !=\n                position += 2;\n                return create('operator', '!=');\n            }\n            if (currentChar === '>' && path.charAt(position + 1) === '=') {\n                // >=\n                position += 2;\n                return create('operator', '>=');\n            }\n            if (currentChar === '<' && path.charAt(position + 1) === '=') {\n                // <=\n                position += 2;\n                return create('operator', '<=');\n            }\n            if (currentChar === '*' && path.charAt(position + 1) === '*') {\n                // **  descendant wildcard\n                position += 2;\n                return create('operator', '**');\n            }\n            if (currentChar === '~' && path.charAt(position + 1) === '>') {\n                // ~>  chain function\n                position += 2;\n                return create('operator', '~>');\n            }\n            // test for single char operators\n            if (Object.prototype.hasOwnProperty.call(operators, currentChar)) {\n                position++;\n                return create('operator', currentChar);\n            }\n            // test for string literals\n            if (currentChar === '\"' || currentChar === \"'\") {\n                var quoteType = currentChar;\n                // double quoted string literal - find end of string\n                position++;\n                var qstr = \"\";\n                while (position < length) {\n                    currentChar = path.charAt(position);\n                    if (currentChar === '\\\\') { // escape sequence\n                        position++;\n                        currentChar = path.charAt(position);\n                        if (Object.prototype.hasOwnProperty.call(escapes, currentChar)) {\n                            qstr += escapes[currentChar];\n                        } else if (currentChar === 'u') {\n                            // \\u should be followed by 4 hex digits\n                            var octets = path.substr(position + 1, 4);\n                            if (/^[0-9a-fA-F]+$/.test(octets)) {\n                                var codepoint = parseInt(octets, 16);\n                                qstr += String.fromCharCode(codepoint);\n                                position += 4;\n                            } else {\n                                throw {\n                                    code: \"S0104\",\n                                    stack: (new Error()).stack,\n                                    position: position\n                                };\n                            }\n                        } else {\n                            // illegal escape sequence\n                            throw {\n                                code: \"S0103\",\n                                stack: (new Error()).stack,\n                                position: position,\n                                token: currentChar\n                            };\n\n                        }\n                    } else if (currentChar === quoteType) {\n                        position++;\n                        return create('string', qstr);\n                    } else {\n                        qstr += currentChar;\n                    }\n                    position++;\n                }\n                throw {\n                    code: \"S0101\",\n                    stack: (new Error()).stack,\n                    position: position\n                };\n            }\n            // test for numbers\n            var numregex = /^-?(0|([1-9][0-9]*))(\\.[0-9]+)?([Ee][-+]?[0-9]+)?/;\n            var match = numregex.exec(path.substring(position));\n            if (match !== null) {\n                var num = parseFloat(match[0]);\n                if (!isNaN(num) && isFinite(num)) {\n                    position += match[0].length;\n                    return create('number', num);\n                } else {\n                    throw {\n                        code: \"S0102\",\n                        stack: (new Error()).stack,\n                        position: position,\n                        token: match[0]\n                    };\n                }\n            }\n            // test for quoted names (backticks)\n            var name;\n            if (currentChar === '`') {\n                // scan for closing quote\n                position++;\n                var end = path.indexOf('`', position);\n                if (end !== -1) {\n                    name = path.substring(position, end);\n                    position = end + 1;\n                    return create('name', name);\n                }\n                position = length;\n                throw {\n                    code: \"S0105\",\n                    stack: (new Error()).stack,\n                    position: position\n                };\n            }\n            // test for names\n            var i = position;\n            var ch;\n            for (; ;) {\n                ch = path.charAt(i);\n                if (i === length || ' \\t\\n\\r\\v'.indexOf(ch) > -1 || Object.prototype.hasOwnProperty.call(operators, ch)) {\n                    if (path.charAt(position) === '$') {\n                        // variable reference\n                        name = path.substring(position + 1, i);\n                        position = i;\n                        return create('variable', name);\n                    } else {\n                        name = path.substring(position, i);\n                        position = i;\n                        switch (name) {\n                            case 'or':\n                            case 'in':\n                            case 'and':\n                                return create('operator', name);\n                            case 'true':\n                                return create('value', true);\n                            case 'false':\n                                return create('value', false);\n                            case 'null':\n                                return create('value', null);\n                            default:\n                                if (position === length && name === '') {\n                                    // whitespace at end of input\n                                    return null;\n                                }\n                                return create('name', name);\n                        }\n                    }\n                } else {\n                    i++;\n                }\n            }\n        };\n\n        return next;\n    };\n\n    // This parser implements the 'Top down operator precedence' algorithm developed by Vaughan R Pratt; http://dl.acm.org/citation.cfm?id=512931.\n    // and builds on the Javascript framework described by Douglas Crockford at http://javascript.crockford.com/tdop/tdop.html\n    // and in 'Beautiful Code', edited by Andy Oram and Greg Wilson, Copyright 2007 O'Reilly Media, Inc. 798-0-596-51004-6\n\n    var parser = function (source, recover) {\n        var node;\n        var lexer;\n\n        var symbol_table = {};\n        var errors = [];\n\n        var remainingTokens = function () {\n            var remaining = [];\n            if (node.id !== '(end)') {\n                remaining.push({type: node.type, value: node.value, position: node.position});\n            }\n            var nxt = lexer();\n            while (nxt !== null) {\n                remaining.push(nxt);\n                nxt = lexer();\n            }\n            return remaining;\n        };\n\n        var base_symbol = {\n            nud: function () {\n                // error - symbol has been invoked as a unary operator\n                var err = {\n                    code: 'S0211',\n                    token: this.value,\n                    position: this.position\n                };\n\n                if (recover) {\n                    err.remaining = remainingTokens();\n                    err.type = 'error';\n                    errors.push(err);\n                    return err;\n                } else {\n                    err.stack = (new Error()).stack;\n                    throw err;\n                }\n            }\n        };\n\n        var symbol = function (id, bp) {\n            var s = symbol_table[id];\n            bp = bp || 0;\n            if (s) {\n                if (bp >= s.lbp) {\n                    s.lbp = bp;\n                }\n            } else {\n                s = Object.create(base_symbol);\n                s.id = s.value = id;\n                s.lbp = bp;\n                symbol_table[id] = s;\n            }\n            return s;\n        };\n\n        var handleError = function (err) {\n            if (recover) {\n                // tokenize the rest of the buffer and add it to an error token\n                err.remaining = remainingTokens();\n                errors.push(err);\n                var symbol = symbol_table[\"(error)\"];\n                node = Object.create(symbol);\n                node.error = err;\n                node.type = \"(error)\";\n                return node;\n            } else {\n                err.stack = (new Error()).stack;\n                throw err;\n            }\n        };\n\n        var advance = function (id, infix) {\n            if (id && node.id !== id) {\n                var code;\n                if (node.id === '(end)') {\n                    // unexpected end of buffer\n                    code = \"S0203\";\n                } else {\n                    code = \"S0202\";\n                }\n                var err = {\n                    code: code,\n                    position: node.position,\n                    token: node.value,\n                    value: id\n                };\n                return handleError(err);\n            }\n            var next_token = lexer(infix);\n            if (next_token === null) {\n                node = symbol_table[\"(end)\"];\n                node.position = source.length;\n                return node;\n            }\n            var value = next_token.value;\n            var type = next_token.type;\n            var symbol;\n            switch (type) {\n                case 'name':\n                case 'variable':\n                    symbol = symbol_table[\"(name)\"];\n                    break;\n                case 'operator':\n                    symbol = symbol_table[value];\n                    if (!symbol) {\n                        return handleError({\n                            code: \"S0204\",\n                            stack: (new Error()).stack,\n                            position: next_token.position,\n                            token: value\n                        });\n                    }\n                    break;\n                case 'string':\n                case 'number':\n                case 'value':\n                    symbol = symbol_table[\"(literal)\"];\n                    break;\n                case 'regex':\n                    type = \"regex\";\n                    symbol = symbol_table[\"(regex)\"];\n                    break;\n                /* istanbul ignore next */\n                default:\n                    return handleError({\n                        code: \"S0205\",\n                        stack: (new Error()).stack,\n                        position: next_token.position,\n                        token: value\n                    });\n            }\n\n            node = Object.create(symbol);\n            node.value = value;\n            node.type = type;\n            node.position = next_token.position;\n            return node;\n        };\n\n        // Pratt's algorithm\n        var expression = function (rbp) {\n            var left;\n            var t = node;\n            advance(null, true);\n            left = t.nud();\n            while (rbp < node.lbp) {\n                t = node;\n                advance();\n                left = t.led(left);\n            }\n            return left;\n        };\n\n        var terminal = function (id) {\n            var s = symbol(id, 0);\n            s.nud = function () {\n                return this;\n            };\n        };\n\n        // match infix operators\n        // <expression> <operator> <expression>\n        // left associative\n        var infix = function (id, bp, led) {\n            var bindingPower = bp || operators[id];\n            var s = symbol(id, bindingPower);\n            s.led = led || function (left) {\n                this.lhs = left;\n                this.rhs = expression(bindingPower);\n                this.type = \"binary\";\n                return this;\n            };\n            return s;\n        };\n\n        // match infix operators\n        // <expression> <operator> <expression>\n        // right associative\n        var infixr = function (id, bp, led) {\n            var s = symbol(id, bp);\n            s.led = led;\n            return s;\n        };\n\n        // match prefix operators\n        // <operator> <expression>\n        var prefix = function (id, nud) {\n            var s = symbol(id);\n            s.nud = nud || function () {\n                this.expression = expression(70);\n                this.type = \"unary\";\n                return this;\n            };\n            return s;\n        };\n\n        terminal(\"(end)\");\n        terminal(\"(name)\");\n        terminal(\"(literal)\");\n        terminal(\"(regex)\");\n        symbol(\":\");\n        symbol(\";\");\n        symbol(\",\");\n        symbol(\")\");\n        symbol(\"]\");\n        symbol(\"}\");\n        symbol(\"..\"); // range operator\n        infix(\".\"); // map operator\n        infix(\"+\"); // numeric addition\n        infix(\"-\"); // numeric subtraction\n        infix(\"*\"); // numeric multiplication\n        infix(\"/\"); // numeric division\n        infix(\"%\"); // numeric modulus\n        infix(\"=\"); // equality\n        infix(\"<\"); // less than\n        infix(\">\"); // greater than\n        infix(\"!=\"); // not equal to\n        infix(\"<=\"); // less than or equal\n        infix(\">=\"); // greater than or equal\n        infix(\"&\"); // string concatenation\n        infix(\"and\"); // Boolean AND\n        infix(\"or\"); // Boolean OR\n        infix(\"in\"); // is member of array\n        terminal(\"and\"); // the 'keywords' can also be used as terminals (field names)\n        terminal(\"or\"); //\n        terminal(\"in\"); //\n        prefix(\"-\"); // unary numeric negation\n        infix(\"~>\"); // function application\n\n        infixr(\"(error)\", 10, function (left) {\n            this.lhs = left;\n\n            this.error = node.error;\n            this.remaining = remainingTokens();\n            this.type = 'error';\n            return this;\n        });\n\n        // field wildcard (single level)\n        prefix('*', function () {\n            this.type = \"wildcard\";\n            return this;\n        });\n\n        // descendant wildcard (multi-level)\n        prefix('**', function () {\n            this.type = \"descendant\";\n            return this;\n        });\n\n        // parent operator\n        prefix('%', function () {\n            this.type = \"parent\";\n            return this;\n        });\n\n        // function invocation\n        infix(\"(\", operators['('], function (left) {\n            // left is is what we are trying to invoke\n            this.procedure = left;\n            this.type = 'function';\n            this.arguments = [];\n            if (node.id !== ')') {\n                for (; ;) {\n                    if (node.type === 'operator' && node.id === '?') {\n                        // partial function application\n                        this.type = 'partial';\n                        this.arguments.push(node);\n                        advance('?');\n                    } else {\n                        this.arguments.push(expression(0));\n                    }\n                    if (node.id !== ',') break;\n                    advance(',');\n                }\n            }\n            advance(\")\", true);\n            // if the name of the function is 'function' or Î», then this is function definition (lambda function)\n            if (left.type === 'name' && (left.value === 'function' || left.value === '\\u03BB')) {\n                // all of the args must be VARIABLE tokens\n                this.arguments.forEach(function (arg, index) {\n                    if (arg.type !== 'variable') {\n                        return handleError({\n                            code: \"S0208\",\n                            stack: (new Error()).stack,\n                            position: arg.position,\n                            token: arg.value,\n                            value: index + 1\n                        });\n                    }\n                });\n                this.type = 'lambda';\n                // is the next token a '<' - if so, parse the function signature\n                if (node.id === '<') {\n                    var sigPos = node.position;\n                    var depth = 1;\n                    var sig = '<';\n                    while (depth > 0 && node.id !== '{' && node.id !== '(end)') {\n                        var tok = advance();\n                        if (tok.id === '>') {\n                            depth--;\n                        } else if (tok.id === '<') {\n                            depth++;\n                        }\n                        sig += tok.value;\n                    }\n                    advance('>');\n                    try {\n                        this.signature = parseSignature(sig);\n                    } catch (err) {\n                        // insert the position into this error\n                        err.position = sigPos + err.offset;\n                        return handleError(err);\n                    }\n                }\n                // parse the function body\n                advance('{');\n                this.body = expression(0);\n                advance('}');\n            }\n            return this;\n        });\n\n        // parenthesis - block expression\n        prefix(\"(\", function () {\n            var expressions = [];\n            while (node.id !== \")\") {\n                expressions.push(expression(0));\n                if (node.id !== \";\") {\n                    break;\n                }\n                advance(\";\");\n            }\n            advance(\")\", true);\n            this.type = 'block';\n            this.expressions = expressions;\n            return this;\n        });\n\n        // array constructor\n        prefix(\"[\", function () {\n            var a = [];\n            if (node.id !== \"]\") {\n                for (; ;) {\n                    var item = expression(0);\n                    if (node.id === \"..\") {\n                        // range operator\n                        var range = {type: \"binary\", value: \"..\", position: node.position, lhs: item};\n                        advance(\"..\");\n                        range.rhs = expression(0);\n                        item = range;\n                    }\n                    a.push(item);\n                    if (node.id !== \",\") {\n                        break;\n                    }\n                    advance(\",\");\n                }\n            }\n            advance(\"]\", true);\n            this.expressions = a;\n            this.type = \"unary\";\n            return this;\n        });\n\n        // filter - predicate or array index\n        infix(\"[\", operators['['], function (left) {\n            if (node.id === \"]\") {\n                // empty predicate means maintain singleton arrays in the output\n                var step = left;\n                while (step && step.type === 'binary' && step.value === '[') {\n                    step = step.lhs;\n                }\n                step.keepArray = true;\n                advance(\"]\");\n                return left;\n            } else {\n                this.lhs = left;\n                this.rhs = expression(operators[']']);\n                this.type = 'binary';\n                advance(\"]\", true);\n                return this;\n            }\n        });\n\n        // order-by\n        infix(\"^\", operators['^'], function (left) {\n            advance(\"(\");\n            var terms = [];\n            for (; ;) {\n                var term = {\n                    descending: false\n                };\n                if (node.id === \"<\") {\n                    // ascending sort\n                    advance(\"<\");\n                } else if (node.id === \">\") {\n                    // descending sort\n                    term.descending = true;\n                    advance(\">\");\n                } else {\n                    //unspecified - default to ascending\n                }\n                term.expression = expression(0);\n                terms.push(term);\n                if (node.id !== \",\") {\n                    break;\n                }\n                advance(\",\");\n            }\n            advance(\")\");\n            this.lhs = left;\n            this.rhs = terms;\n            this.type = 'binary';\n            return this;\n        });\n\n        var objectParser = function (left) {\n            var a = [];\n            if (node.id !== \"}\") {\n                for (; ;) {\n                    var n = expression(0);\n                    advance(\":\");\n                    var v = expression(0);\n                    a.push([n, v]); // holds an array of name/value expression pairs\n                    if (node.id !== \",\") {\n                        break;\n                    }\n                    advance(\",\");\n                }\n            }\n            advance(\"}\", true);\n            if (typeof left === 'undefined') {\n                // NUD - unary prefix form\n                this.lhs = a;\n                this.type = \"unary\";\n            } else {\n                // LED - binary infix form\n                this.lhs = left;\n                this.rhs = a;\n                this.type = 'binary';\n            }\n            return this;\n        };\n\n        // object constructor\n        prefix(\"{\", objectParser);\n\n        // object grouping\n        infix(\"{\", operators['{'], objectParser);\n\n        // bind variable\n        infixr(\":=\", operators[':='], function (left) {\n            if (left.type !== 'variable') {\n                return handleError({\n                    code: \"S0212\",\n                    stack: (new Error()).stack,\n                    position: left.position,\n                    token: left.value\n                });\n            }\n            this.lhs = left;\n            this.rhs = expression(operators[':='] - 1); // subtract 1 from bindingPower for right associative operators\n            this.type = \"binary\";\n            return this;\n        });\n\n        // focus variable bind\n        infix(\"@\", operators['@'], function (left) {\n            this.lhs = left;\n            this.rhs = expression(operators['@']);\n            if(this.rhs.type !== 'variable') {\n                return handleError({\n                    code: \"S0214\",\n                    stack: (new Error()).stack,\n                    position: this.rhs.position,\n                    token: \"@\"\n                });\n            }\n            this.type = \"binary\";\n            return this;\n        });\n\n        // index (position) variable bind\n        infix(\"#\", operators['#'], function (left) {\n            this.lhs = left;\n            this.rhs = expression(operators['#']);\n            if(this.rhs.type !== 'variable') {\n                return handleError({\n                    code: \"S0214\",\n                    stack: (new Error()).stack,\n                    position: this.rhs.position,\n                    token: \"#\"\n                });\n            }\n            this.type = \"binary\";\n            return this;\n        });\n\n        // if/then/else ternary operator ?:\n        infix(\"?\", operators['?'], function (left) {\n            this.type = 'condition';\n            this.condition = left;\n            this.then = expression(0);\n            if (node.id === ':') {\n                // else condition\n                advance(\":\");\n                this.else = expression(0);\n            }\n            return this;\n        });\n\n        // object transformer\n        prefix(\"|\", function () {\n            this.type = 'transform';\n            this.pattern = expression(0);\n            advance('|');\n            this.update = expression(0);\n            if (node.id === ',') {\n                advance(',');\n                this.delete = expression(0);\n            }\n            advance('|');\n            return this;\n        });\n\n        // tail call optimization\n        // this is invoked by the post parser to analyse lambda functions to see\n        // if they make a tail call.  If so, it is replaced by a thunk which will\n        // be invoked by the trampoline loop during function application.\n        // This enables tail-recursive functions to be written without growing the stack\n        var tailCallOptimize = function (expr) {\n            var result;\n            if (expr.type === 'function' && !expr.predicate) {\n                var thunk = {type: 'lambda', thunk: true, arguments: [], position: expr.position};\n                thunk.body = expr;\n                result = thunk;\n            } else if (expr.type === 'condition') {\n                // analyse both branches\n                expr.then = tailCallOptimize(expr.then);\n                if (typeof expr.else !== 'undefined') {\n                    expr.else = tailCallOptimize(expr.else);\n                }\n                result = expr;\n            } else if (expr.type === 'block') {\n                // only the last expression in the block\n                var length = expr.expressions.length;\n                if (length > 0) {\n                    expr.expressions[length - 1] = tailCallOptimize(expr.expressions[length - 1]);\n                }\n                result = expr;\n            } else {\n                result = expr;\n            }\n            return result;\n        };\n\n        var ancestorLabel = 0;\n        var ancestorIndex = 0;\n        var ancestry = [];\n\n        var seekParent = function (node, slot) {\n            switch (node.type) {\n                case 'name':\n                case 'wildcard':\n                    slot.level--;\n                    if(slot.level === 0) {\n                        if (typeof node.ancestor === 'undefined') {\n                            node.ancestor = slot;\n                        } else {\n                            // reuse the existing label\n                            ancestry[slot.index].slot.label = node.ancestor.label;\n                            node.ancestor = slot;\n                        }\n                        node.tuple = true;\n                    }\n                    break;\n                case 'parent':\n                    slot.level++;\n                    break;\n                case 'block':\n                    // look in last expression in the block\n                    if(node.expressions.length > 0) {\n                        node.tuple = true;\n                        slot = seekParent(node.expressions[node.expressions.length - 1], slot);\n                    }\n                    break;\n                case 'path':\n                    // last step in path\n                    node.tuple = true;\n                    var index = node.steps.length - 1;\n                    slot = seekParent(node.steps[index--], slot);\n                    while (slot.level > 0 && index >= 0) {\n                        // check previous steps\n                        slot = seekParent(node.steps[index--], slot);\n                    }\n                    break;\n                default:\n                    // error - can't derive ancestor\n                    throw {\n                        code: \"S0217\",\n                        token: node.type,\n                        position: node.position\n                    };\n            }\n            return slot;\n        };\n\n        var pushAncestry = function(result, value) {\n            if(typeof value.seekingParent !== 'undefined' || value.type === 'parent') {\n                var slots = (typeof value.seekingParent !== 'undefined') ? value.seekingParent : [];\n                if (value.type === 'parent') {\n                    slots.push(value.slot);\n                }\n                if(typeof result.seekingParent === 'undefined') {\n                    result.seekingParent = slots;\n                } else {\n                    Array.prototype.push.apply(result.seekingParent, slots);\n                }\n            }\n        };\n\n        var resolveAncestry = function(path) {\n            var index = path.steps.length - 1;\n            var laststep = path.steps[index];\n            var slots = (typeof laststep.seekingParent !== 'undefined') ? laststep.seekingParent : [];\n            if (laststep.type === 'parent') {\n                slots.push(laststep.slot);\n            }\n            for(var is = 0; is < slots.length; is++) {\n                var slot = slots[is];\n                index = path.steps.length - 2;\n                while (slot.level > 0) {\n                    if (index < 0) {\n                        if(typeof path.seekingParent === 'undefined') {\n                            path.seekingParent = [slot];\n                        } else {\n                            path.seekingParent.push(slot);\n                        }\n                        break;\n                    }\n                    // try previous step\n                    var step = path.steps[index--];\n                    // multiple contiguous steps that bind the focus should be skipped\n                    while(index >= 0 && step.focus && path.steps[index].focus) {\n                        step = path.steps[index--];\n                    }\n                    slot = seekParent(step, slot);\n                }\n            }\n        };\n\n        // post-parse stage\n        // the purpose of this is to add as much semantic value to the parse tree as possible\n        // in order to simplify the work of the evaluator.\n        // This includes flattening the parts of the AST representing location paths,\n        // converting them to arrays of steps which in turn may contain arrays of predicates.\n        // following this, nodes containing '.' and '[' should be eliminated from the AST.\n        var processAST = function (expr) {\n            var result;\n            switch (expr.type) {\n                case 'binary':\n                    switch (expr.value) {\n                        case '.':\n                            var lstep = processAST(expr.lhs);\n\n                            if (lstep.type === 'path') {\n                                result = lstep;\n                            } else {\n                                result = {type: 'path', steps: [lstep]};\n                            }\n                            if(lstep.type === 'parent') {\n                                result.seekingParent = [lstep.slot];\n                            }\n                            var rest = processAST(expr.rhs);\n                            if (rest.type === 'function' &&\n                                rest.procedure.type === 'path' &&\n                                rest.procedure.steps.length === 1 &&\n                                rest.procedure.steps[0].type === 'name' &&\n                                result.steps[result.steps.length - 1].type === 'function') {\n                                // next function in chain of functions - will override a thenable\n                                result.steps[result.steps.length - 1].nextFunction = rest.procedure.steps[0].value;\n                            }\n                            if (rest.type === 'path') {\n                                Array.prototype.push.apply(result.steps, rest.steps);\n                            } else {\n                                if(typeof rest.predicate !== 'undefined') {\n                                    rest.stages = rest.predicate;\n                                    delete rest.predicate;\n                                }\n                                result.steps.push(rest);\n                            }\n                            // any steps within a path that are string literals, should be changed to 'name'\n                            result.steps.filter(function (step) {\n                                if (step.type === 'number' || step.type === 'value') {\n                                    // don't allow steps to be numbers or the values true/false/null\n                                    throw {\n                                        code: \"S0213\",\n                                        stack: (new Error()).stack,\n                                        position: step.position,\n                                        value: step.value\n                                    };\n                                }\n                                return step.type === 'string';\n                            }).forEach(function (lit) {\n                                lit.type = 'name';\n                            });\n                            // any step that signals keeping a singleton array, should be flagged on the path\n                            if (result.steps.filter(function (step) {\n                                return step.keepArray === true;\n                            }).length > 0) {\n                                result.keepSingletonArray = true;\n                            }\n                            // if first step is a path constructor, flag it for special handling\n                            var firststep = result.steps[0];\n                            if (firststep.type === 'unary' && firststep.value === '[') {\n                                firststep.consarray = true;\n                            }\n                            // if the last step is an array constructor, flag it so it doesn't flatten\n                            var laststep = result.steps[result.steps.length - 1];\n                            if (laststep.type === 'unary' && laststep.value === '[') {\n                                laststep.consarray = true;\n                            }\n                            resolveAncestry(result);\n                            break;\n                        case '[':\n                            // predicated step\n                            // LHS is a step or a predicated step\n                            // RHS is the predicate expr\n                            result = processAST(expr.lhs);\n                            var step = result;\n                            var type = 'predicate';\n                            if (result.type === 'path') {\n                                step = result.steps[result.steps.length - 1];\n                                type = 'stages';\n                            }\n                            if (typeof step.group !== 'undefined') {\n                                throw {\n                                    code: \"S0209\",\n                                    stack: (new Error()).stack,\n                                    position: expr.position\n                                };\n                            }\n                            if (typeof step[type] === 'undefined') {\n                                step[type] = [];\n                            }\n                            var predicate = processAST(expr.rhs);\n                            if(typeof predicate.seekingParent !== 'undefined') {\n                                predicate.seekingParent.forEach(slot => {\n                                    if(slot.level === 1) {\n                                        seekParent(step, slot);\n                                    } else {\n                                        slot.level--;\n                                    }\n                                });\n                                pushAncestry(step, predicate);\n                            }\n                            step[type].push({type: 'filter', expr: predicate, position: expr.position});\n                            break;\n                        case '{':\n                            // group-by\n                            // LHS is a step or a predicated step\n                            // RHS is the object constructor expr\n                            result = processAST(expr.lhs);\n                            if (typeof result.group !== 'undefined') {\n                                throw {\n                                    code: \"S0210\",\n                                    stack: (new Error()).stack,\n                                    position: expr.position\n                                };\n                            }\n                            // object constructor - process each pair\n                            result.group = {\n                                lhs: expr.rhs.map(function (pair) {\n                                    return [processAST(pair[0]), processAST(pair[1])];\n                                }),\n                                position: expr.position\n                            };\n                            break;\n                        case '^':\n                            // order-by\n                            // LHS is the array to be ordered\n                            // RHS defines the terms\n                            result = processAST(expr.lhs);\n                            if (result.type !== 'path') {\n                                result = {type: 'path', steps: [result]};\n                            }\n                            var sortStep = {type: 'sort', position: expr.position};\n                            sortStep.terms = expr.rhs.map(function (terms) {\n                                var expression = processAST(terms.expression);\n                                pushAncestry(sortStep, expression);\n                                return {\n                                    descending: terms.descending,\n                                    expression: expression\n                                };\n                            });\n                            result.steps.push(sortStep);\n                            resolveAncestry(result);\n                            break;\n                        case ':=':\n                            result = {type: 'bind', value: expr.value, position: expr.position};\n                            result.lhs = processAST(expr.lhs);\n                            result.rhs = processAST(expr.rhs);\n                            pushAncestry(result, result.rhs);\n                            break;\n                        case '@':\n                            result = processAST(expr.lhs);\n                            step = result;\n                            if (result.type === 'path') {\n                                step = result.steps[result.steps.length - 1];\n                            }\n                            // throw error if there are any predicates defined at this point\n                            // at this point the only type of stages can be predicates\n                            if(typeof step.stages !== 'undefined' || typeof step.predicate !== 'undefined') {\n                                throw {\n                                    code: \"S0215\",\n                                    stack: (new Error()).stack,\n                                    position: expr.position\n                                };\n                            }\n                            // also throw if this is applied after an 'order-by' clause\n                            if(step.type === 'sort') {\n                                throw {\n                                    code: \"S0216\",\n                                    stack: (new Error()).stack,\n                                    position: expr.position\n                                };\n                            }\n                            if(expr.keepArray) {\n                                step.keepArray = true;\n                            }\n                            step.focus = expr.rhs.value;\n                            step.tuple = true;\n                            break;\n                        case '#':\n                            result = processAST(expr.lhs);\n                            step = result;\n                            if (result.type === 'path') {\n                                step = result.steps[result.steps.length - 1];\n                            } else {\n                                result = {type: 'path', steps: [result]};\n                                if (typeof step.predicate !== 'undefined') {\n                                    step.stages = step.predicate;\n                                    delete step.predicate;\n                                }\n                            }\n                            if (typeof step.stages === 'undefined') {\n                                step.index = expr.rhs.value;\n                            } else {\n                                step.stages.push({type: 'index', value: expr.rhs.value, position: expr.position});\n                            }\n                            step.tuple = true;\n                            break;\n                        case '~>':\n                            result = {type: 'apply', value: expr.value, position: expr.position};\n                            result.lhs = processAST(expr.lhs);\n                            result.rhs = processAST(expr.rhs);\n                            break;\n                        default:\n                            result = {type: expr.type, value: expr.value, position: expr.position};\n                            result.lhs = processAST(expr.lhs);\n                            result.rhs = processAST(expr.rhs);\n                            pushAncestry(result, result.lhs);\n                            pushAncestry(result, result.rhs);\n                    }\n                    break;\n                case 'unary':\n                    result = {type: expr.type, value: expr.value, position: expr.position};\n                    if (expr.value === '[') {\n                        // array constructor - process each item\n                        result.expressions = expr.expressions.map(function (item) {\n                            var value = processAST(item);\n                            pushAncestry(result, value);\n                            return value;\n                        });\n                    } else if (expr.value === '{') {\n                        // object constructor - process each pair\n                        result.lhs = expr.lhs.map(function (pair) {\n                            var key = processAST(pair[0]);\n                            pushAncestry(result, key);\n                            var value = processAST(pair[1]);\n                            pushAncestry(result, value);\n                            return [key, value];\n                        });\n                    } else {\n                        // all other unary expressions - just process the expression\n                        result.expression = processAST(expr.expression);\n                        // if unary minus on a number, then pre-process\n                        if (expr.value === '-' && result.expression.type === 'number') {\n                            result = result.expression;\n                            result.value = -result.value;\n                        } else {\n                            pushAncestry(result, result.expression);\n                        }\n                    }\n                    break;\n                case 'function':\n                case 'partial':\n                    result = {type: expr.type, name: expr.name, value: expr.value, position: expr.position};\n                    result.arguments = expr.arguments.map(function (arg) {\n                        var argAST = processAST(arg);\n                        pushAncestry(result, argAST);\n                        return argAST;\n                    });\n                    result.procedure = processAST(expr.procedure);\n                    break;\n                case 'lambda':\n                    result = {\n                        type: expr.type,\n                        arguments: expr.arguments,\n                        signature: expr.signature,\n                        position: expr.position\n                    };\n                    var body = processAST(expr.body);\n                    result.body = tailCallOptimize(body);\n                    break;\n                case 'condition':\n                    result = {type: expr.type, position: expr.position};\n                    result.condition = processAST(expr.condition);\n                    pushAncestry(result, result.condition);\n                    result.then = processAST(expr.then);\n                    pushAncestry(result, result.then);\n                    if (typeof expr.else !== 'undefined') {\n                        result.else = processAST(expr.else);\n                        pushAncestry(result, result.else);\n                    }\n                    break;\n                case 'transform':\n                    result = {type: expr.type, position: expr.position};\n                    result.pattern = processAST(expr.pattern);\n                    result.update = processAST(expr.update);\n                    if (typeof expr.delete !== 'undefined') {\n                        result.delete = processAST(expr.delete);\n                    }\n                    break;\n                case 'block':\n                    result = {type: expr.type, position: expr.position};\n                    // array of expressions - process each one\n                    result.expressions = expr.expressions.map(function (item) {\n                        var part = processAST(item);\n                        pushAncestry(result, part);\n                        if (part.consarray || (part.type === 'path' && part.steps[0].consarray)) {\n                            result.consarray = true;\n                        }\n                        return part;\n                    });\n                    // TODO scan the array of expressions to see if any of them assign variables\n                    // if so, need to mark the block as one that needs to create a new frame\n                    break;\n                case 'name':\n                    result = {type: 'path', steps: [expr]};\n                    if (expr.keepArray) {\n                        result.keepSingletonArray = true;\n                    }\n                    break;\n                case 'parent':\n                    result = {type: 'parent', slot: { label: '!' + ancestorLabel++, level: 1, index: ancestorIndex++ } };\n                    ancestry.push(result);\n                    break;\n                case 'string':\n                case 'number':\n                case 'value':\n                case 'wildcard':\n                case 'descendant':\n                case 'variable':\n                case 'regex':\n                    result = expr;\n                    break;\n                case 'operator':\n                    // the tokens 'and' and 'or' might have been used as a name rather than an operator\n                    if (expr.value === 'and' || expr.value === 'or' || expr.value === 'in') {\n                        expr.type = 'name';\n                        result = processAST(expr);\n                    } else /* istanbul ignore else */ if (expr.value === '?') {\n                        // partial application\n                        result = expr;\n                    } else {\n                        throw {\n                            code: \"S0201\",\n                            stack: (new Error()).stack,\n                            position: expr.position,\n                            token: expr.value\n                        };\n                    }\n                    break;\n                case 'error':\n                    result = expr;\n                    if (expr.lhs) {\n                        result = processAST(expr.lhs);\n                    }\n                    break;\n                default:\n                    var code = \"S0206\";\n                    /* istanbul ignore else */\n                    if (expr.id === '(end)') {\n                        code = \"S0207\";\n                    }\n                    var err = {\n                        code: code,\n                        position: expr.position,\n                        token: expr.value\n                    };\n                    if (recover) {\n                        errors.push(err);\n                        return {type: 'error', error: err};\n                    } else {\n                        err.stack = (new Error()).stack;\n                        throw err;\n                    }\n            }\n            if (expr.keepArray) {\n                result.keepArray = true;\n            }\n            return result;\n        };\n\n        // now invoke the tokenizer and the parser and return the syntax tree\n        lexer = tokenizer(source);\n        advance();\n        // parse the tokens\n        var expr = expression(0);\n        if (node.id !== '(end)') {\n            var err = {\n                code: \"S0201\",\n                position: node.position,\n                token: node.value\n            };\n            handleError(err);\n        }\n        expr = processAST(expr);\n\n        if(expr.type === 'parent' || typeof expr.seekingParent !== 'undefined') {\n            // error - trying to derive ancestor at top level\n            throw {\n                code: \"S0217\",\n                token: expr.type,\n                position: expr.position\n            };\n        }\n\n        if (errors.length > 0) {\n            expr.errors = errors;\n        }\n\n        return expr;\n    };\n\n    return parser;\n})();\n\nmodule.exports = parser;\n\n},{\"./signature\":5}],5:[function(require,module,exports){\n/**\n * Â© Copyright IBM Corp. 2016, 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nvar utils = require('./utils');\n\nconst signature = (() => {\n    'use strict';\n\n    // A mapping between the function signature symbols and the full plural of the type\n    // Expected to be used in error messages\n    var arraySignatureMapping = {\n        \"a\": \"arrays\",\n        \"b\": \"booleans\",\n        \"f\": \"functions\",\n        \"n\": \"numbers\",\n        \"o\": \"objects\",\n        \"s\": \"strings\"\n    };\n\n    /**\n     * Parses a function signature definition and returns a validation function\n     * @param {string} signature - the signature between the <angle brackets>\n     * @returns {Function} validation function\n     */\n    function parseSignature(signature) {\n        // create a Regex that represents this signature and return a function that when invoked,\n        // returns the validated (possibly fixed-up) arguments, or throws a validation error\n        // step through the signature, one symbol at a time\n        var position = 1;\n        var params = [];\n        var param = {};\n        var prevParam = param;\n        while (position < signature.length) {\n            var symbol = signature.charAt(position);\n            if (symbol === ':') {\n                // TODO figure out what to do with the return type\n                // ignore it for now\n                break;\n            }\n\n            var next = function () {\n                params.push(param);\n                prevParam = param;\n                param = {};\n            };\n\n            var findClosingBracket = function (str, start, openSymbol, closeSymbol) {\n                // returns the position of the closing symbol (e.g. bracket) in a string\n                // that balances the opening symbol at position start\n                var depth = 1;\n                var position = start;\n                while (position < str.length) {\n                    position++;\n                    symbol = str.charAt(position);\n                    if (symbol === closeSymbol) {\n                        depth--;\n                        if (depth === 0) {\n                            // we're done\n                            break; // out of while loop\n                        }\n                    } else if (symbol === openSymbol) {\n                        depth++;\n                    }\n                }\n                return position;\n            };\n\n            switch (symbol) {\n                case 's': // string\n                case 'n': // number\n                case 'b': // boolean\n                case 'l': // not so sure about expecting null?\n                case 'o': // object\n                    param.regex = '[' + symbol + 'm]';\n                    param.type = symbol;\n                    next();\n                    break;\n                case 'a': // array\n                    //  normally treat any value as singleton array\n                    param.regex = '[asnblfom]';\n                    param.type = symbol;\n                    param.array = true;\n                    next();\n                    break;\n                case 'f': // function\n                    param.regex = 'f';\n                    param.type = symbol;\n                    next();\n                    break;\n                case 'j': // any JSON type\n                    param.regex = '[asnblom]';\n                    param.type = symbol;\n                    next();\n                    break;\n                case 'x': // any type\n                    param.regex = '[asnblfom]';\n                    param.type = symbol;\n                    next();\n                    break;\n                case '-': // use context if param not supplied\n                    prevParam.context = true;\n                    prevParam.contextRegex = new RegExp(prevParam.regex); // pre-compiled to test the context type at runtime\n                    prevParam.regex += '?';\n                    break;\n                case '?': // optional param\n                case '+': // one or more\n                    prevParam.regex += symbol;\n                    break;\n                case '(': // choice of types\n                    // search forward for matching ')'\n                    var endParen = findClosingBracket(signature, position, '(', ')');\n                    var choice = signature.substring(position + 1, endParen);\n                    if (choice.indexOf('<') === -1) {\n                        // no parameterized types, simple regex\n                        param.regex = '[' + choice + 'm]';\n                    } else {\n                        // TODO harder\n                        throw {\n                            code: \"S0402\",\n                            stack: (new Error()).stack,\n                            value: choice,\n                            offset: position\n                        };\n                    }\n                    param.type = '(' + choice + ')';\n                    position = endParen;\n                    next();\n                    break;\n                case '<': // type parameter - can only be applied to 'a' and 'f'\n                    if (prevParam.type === 'a' || prevParam.type === 'f') {\n                        // search forward for matching '>'\n                        var endPos = findClosingBracket(signature, position, '<', '>');\n                        prevParam.subtype = signature.substring(position + 1, endPos);\n                        position = endPos;\n                    } else {\n                        throw {\n                            code: \"S0401\",\n                            stack: (new Error()).stack,\n                            value: prevParam.type,\n                            offset: position\n                        };\n                    }\n                    break;\n            }\n            position++;\n        }\n        var regexStr = '^' +\n            params.map(function (param) {\n                return '(' + param.regex + ')';\n            }).join('') +\n            '$';\n        var regex = new RegExp(regexStr);\n        var getSymbol = function (value) {\n            var symbol;\n            if (utils.isFunction(value)) {\n                symbol = 'f';\n            } else {\n                var type = typeof value;\n                switch (type) {\n                    case 'string':\n                        symbol = 's';\n                        break;\n                    case 'number':\n                        symbol = 'n';\n                        break;\n                    case 'boolean':\n                        symbol = 'b';\n                        break;\n                    case 'object':\n                        if (value === null) {\n                            symbol = 'l';\n                        } else if (Array.isArray(value)) {\n                            symbol = 'a';\n                        } else {\n                            symbol = 'o';\n                        }\n                        break;\n                    case 'undefined':\n                    default:\n                        // any value can be undefined, but should be allowed to match\n                        symbol = 'm'; // m for missing\n                }\n            }\n            return symbol;\n        };\n\n        var throwValidationError = function (badArgs, badSig) {\n            // to figure out where this went wrong we need apply each component of the\n            // regex to each argument until we get to the one that fails to match\n            var partialPattern = '^';\n            var goodTo = 0;\n            for (var index = 0; index < params.length; index++) {\n                partialPattern += params[index].regex;\n                var match = badSig.match(partialPattern);\n                if (match === null) {\n                    // failed here\n                    throw {\n                        code: \"T0410\",\n                        stack: (new Error()).stack,\n                        value: badArgs[goodTo],\n                        index: goodTo + 1\n                    };\n                }\n                goodTo = match[0].length;\n            }\n            // if it got this far, it's probably because of extraneous arguments (we\n            // haven't added the trailing '$' in the regex yet.\n            throw {\n                code: \"T0410\",\n                stack: (new Error()).stack,\n                value: badArgs[goodTo],\n                index: goodTo + 1\n            };\n        };\n\n        return {\n            definition: signature,\n            validate: function (args, context) {\n                var suppliedSig = '';\n                args.forEach(function (arg) {\n                    suppliedSig += getSymbol(arg);\n                });\n                var isValid = regex.exec(suppliedSig);\n                if (isValid) {\n                    var validatedArgs = [];\n                    var argIndex = 0;\n                    params.forEach(function (param, index) {\n                        var arg = args[argIndex];\n                        var match = isValid[index + 1];\n                        if (match === '') {\n                            if (param.context && param.contextRegex) {\n                                // substitute context value for missing arg\n                                // first check that the context value is the right type\n                                var contextType = getSymbol(context);\n                                // test contextType against the regex for this arg (without the trailing ?)\n                                if (param.contextRegex.test(contextType)) {\n                                    validatedArgs.push(context);\n                                } else {\n                                    // context value not compatible with this argument\n                                    throw {\n                                        code: \"T0411\",\n                                        stack: (new Error()).stack,\n                                        value: context,\n                                        index: argIndex + 1\n                                    };\n                                }\n                            } else {\n                                validatedArgs.push(arg);\n                                argIndex++;\n                            }\n                        } else {\n                            // may have matched multiple args (if the regex ends with a '+'\n                            // split into single tokens\n                            match.split('').forEach(function (single) {\n                                if (param.type === 'a') {\n                                    if (single === 'm') {\n                                        // missing (undefined)\n                                        arg = undefined;\n                                    } else {\n                                        arg = args[argIndex];\n                                        var arrayOK = true;\n                                        // is there type information on the contents of the array?\n                                        if (typeof param.subtype !== 'undefined') {\n                                            if (single !== 'a' && match !== param.subtype) {\n                                                arrayOK = false;\n                                            } else if (single === 'a') {\n                                                if (arg.length > 0) {\n                                                    var itemType = getSymbol(arg[0]);\n                                                    if (itemType !== param.subtype.charAt(0)) { // TODO recurse further\n                                                        arrayOK = false;\n                                                    } else {\n                                                        // make sure every item in the array is this type\n                                                        var differentItems = arg.filter(function (val) {\n                                                            return (getSymbol(val) !== itemType);\n                                                        });\n                                                        arrayOK = (differentItems.length === 0);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        if (!arrayOK) {\n                                            throw {\n                                                code: \"T0412\",\n                                                stack: (new Error()).stack,\n                                                value: arg,\n                                                index: argIndex + 1,\n                                                type: arraySignatureMapping[param.subtype]\n                                            };\n                                        }\n                                        // the function expects an array. If it's not one, make it so\n                                        if (single !== 'a') {\n                                            arg = [arg];\n                                        }\n                                    }\n                                    validatedArgs.push(arg);\n                                    argIndex++;\n                                } else {\n                                    validatedArgs.push(arg);\n                                    argIndex++;\n                                }\n                            });\n                        }\n                    });\n                    return validatedArgs;\n                }\n                throwValidationError(args, suppliedSig);\n            }\n        };\n    }\n\n    return parseSignature;\n})();\n\nmodule.exports = signature;\n\n},{\"./utils\":6}],6:[function(require,module,exports){\n/**\n * Â© Copyright IBM Corp. 2016, 2018 All Rights Reserved\n *   Project name: JSONata\n *   This project is licensed under the MIT License, see LICENSE\n */\n\nconst utils = (() => {\n    'use strict';\n\n    /**\n     * Check if value is a finite number\n     * @param {float} n - number to evaluate\n     * @returns {boolean} True if n is a finite number\n     */\n    function isNumeric(n) {\n        var isNum = false;\n        if(typeof n === 'number') {\n            isNum = !isNaN(n);\n            if (isNum && !isFinite(n)) {\n                throw {\n                    code: \"D1001\",\n                    value: n,\n                    stack: (new Error()).stack\n                };\n            }\n        }\n        return isNum;\n    }\n\n    /**\n     * Returns true if the arg is an array of strings\n     * @param {*} arg - the item to test\n     * @returns {boolean} True if arg is an array of strings\n     */\n    function isArrayOfStrings(arg) {\n        var result = false;\n        /* istanbul ignore else */\n        if(Array.isArray(arg)) {\n            result = (arg.filter(function(item){return typeof item !== 'string';}).length === 0);\n        }\n        return result;\n    }\n\n    /**\n     * Returns true if the arg is an array of numbers\n     * @param {*} arg - the item to test\n     * @returns {boolean} True if arg is an array of numbers\n     */\n    function isArrayOfNumbers(arg) {\n        var result = false;\n        if(Array.isArray(arg)) {\n            result = (arg.filter(function(item){return !isNumeric(item);}).length === 0);\n        }\n        return result;\n    }\n\n    /**\n     * Create an empty sequence to contain query results\n     * @returns {Array} - empty sequence\n     */\n    function createSequence() {\n        var sequence = [];\n        sequence.sequence = true;\n        if (arguments.length === 1) {\n            sequence.push(arguments[0]);\n        }\n        return sequence;\n    }\n\n    /**\n     * Tests if a value is a sequence\n     * @param {*} value the value to test\n     * @returns {boolean} true if it's a sequence\n     */\n    function isSequence(value) {\n        return value.sequence === true && Array.isArray(value);\n    }\n\n    /**\n     *\n     * @param {Object} arg - expression to test\n     * @returns {boolean} - true if it is a function (lambda or built-in)\n     */\n    function isFunction(arg) {\n        return ((arg && (arg._jsonata_function === true || arg._jsonata_lambda === true)) || typeof arg === 'function');\n    }\n\n    /**\n     * Returns the arity (number of arguments) of the function\n     * @param {*} func - the function\n     * @returns {*} - the arity\n     */\n    function getFunctionArity(func) {\n        var arity = typeof func.arity === 'number' ? func.arity :\n            typeof func.implementation === 'function' ? func.implementation.length :\n                typeof func.length === 'number' ? func.length : func.arguments.length;\n        return arity;\n    }\n\n    /**\n     * Tests whether arg is a lambda function\n     * @param {*} arg - the value to test\n     * @returns {boolean} - true if it is a lambda function\n     */\n    function isLambda(arg) {\n        return arg && arg._jsonata_lambda === true;\n    }\n\n    // istanbul ignore next\n    var iteratorSymbol = (typeof Symbol === \"function\" ? Symbol : {}).iterator || \"@@iterator\";\n\n    /**\n     * @param {Object} arg - expression to test\n     * @returns {boolean} - true if it is iterable\n     */\n    function isIterable(arg) {\n        return (\n            typeof arg === 'object' &&\n            arg !== null &&\n            iteratorSymbol in arg &&\n            'next' in arg &&\n            typeof arg.next === 'function'\n        );\n    }\n\n    /**\n     * Compares two values for equality\n     * @param {*} lhs first value\n     * @param {*} rhs second value\n     * @returns {boolean} true if they are deep equal\n     */\n    function isDeepEqual(lhs, rhs) {\n        if (lhs === rhs) {\n            return true;\n        }\n        if(typeof lhs === 'object' && typeof rhs === 'object' && lhs !== null && rhs !== null) {\n            if(Array.isArray(lhs) && Array.isArray(rhs)) {\n                // both arrays (or sequences)\n                // must be the same length\n                if(lhs.length !== rhs.length) {\n                    return false;\n                }\n                // must contain same values in same order\n                for(var ii = 0; ii < lhs.length; ii++) {\n                    if(!isDeepEqual(lhs[ii], rhs[ii])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            // both objects\n            // must have the same set of keys (in any order)\n            var lkeys = Object.getOwnPropertyNames(lhs);\n            var rkeys = Object.getOwnPropertyNames(rhs);\n            if(lkeys.length !== rkeys.length) {\n                return false;\n            }\n            lkeys = lkeys.sort();\n            rkeys = rkeys.sort();\n            for(ii=0; ii < lkeys.length; ii++) {\n                if(lkeys[ii] !== rkeys[ii]) {\n                    return false;\n                }\n            }\n            // must have the same values\n            for(ii=0; ii < lkeys.length; ii++) {\n                var key = lkeys[ii];\n                if(!isDeepEqual(lhs[key], rhs[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @param {Object} arg - expression to test\n     * @returns {boolean} - true if it is a promise\n     */\n    function isPromise(arg) {\n        return (\n            typeof arg === 'object' &&\n                arg !== null &&\n                'then' in arg &&\n                typeof arg.then === 'function'\n        );\n    }\n\n    /**\n     * converts a string to an array of characters\n     * @param {string} str - the input string\n     * @returns {Array} - the array of characters\n     */\n    function stringToArray(str) {\n        var arr = [];\n        for (let char of str) {\n            arr.push(char);\n        }\n        return arr;\n    }\n\n    return {\n        isNumeric,\n        isArrayOfStrings,\n        isArrayOfNumbers,\n        createSequence,\n        isSequence,\n        isFunction,\n        isLambda,\n        isIterable,\n        getFunctionArity,\n        isDeepEqual,\n        stringToArray,\n        isPromise\n    };\n})();\n\nmodule.exports = utils;\n\n},{}]},{},[3])(3)\n});\n","export * from './parseJSONata';\n","import jsonata from 'jsonata';\nimport type {\n  DefaultCombinatorName,\n  DefaultOperatorName,\n  DefaultRuleGroupArray,\n  DefaultRuleGroupICArray,\n  DefaultRuleGroupType,\n  DefaultRuleGroupTypeAny,\n  DefaultRuleGroupTypeIC,\n  DefaultRuleType,\n  ParseJSONataOptions,\n  ValueSource,\n} from '../../types/index.noReact';\nimport { isRuleGroup } from '../isRuleGroup';\nimport { fieldIsValidUtil, getFieldsArray } from '../parserUtils';\nimport type { JSONataExprNode } from './types';\nimport {\n  generateFlatAndOrList,\n  generateMixedAndOrList,\n  getFieldFromPath,\n  getValidValue,\n  isJSONataAnd,\n  isJSONataBlock,\n  isJSONataComparison,\n  isJSONataContains,\n  isJSONataIdentifier,\n  isJSONataIdentifierList,\n  isJSONataIn,\n  isJSONataNot,\n  isJSONataOr,\n  isJSONataRegex,\n  isJSONataString,\n  isJSONataValidValue,\n  negatedLikeOperators,\n  normalizeOperator,\n} from './utils';\n\n/**\n * Converts a JSONata string expression into a query suitable for the\n * {@link QueryBuilder} component's `query` or `defaultQuery` props\n * ({@link DefaultRuleGroupType}).\n */\nfunction parseJSONata(jsonataInput: string): DefaultRuleGroupType;\n/**\n * Converts a JSONata string expression into a query suitable for the\n * {@link QueryBuilder} component's `query` or `defaultQuery` props\n * ({@link DefaultRuleGroupType}).\n */\nfunction parseJSONata(\n  jsonataInput: string,\n  options: Omit<ParseJSONataOptions, 'independentCombinators'> & {\n    independentCombinators?: false;\n  }\n): DefaultRuleGroupType;\n/**\n * Converts a JSONata string expression into a query suitable for the\n * {@link QueryBuilder} component's `query` or `defaultQuery` props\n * ({@link DefaultRuleGroupTypeIC}).\n */\nfunction parseJSONata(\n  jsonataInput: string,\n  options: Omit<ParseJSONataOptions, 'independentCombinators'> & {\n    independentCombinators: true;\n  }\n): DefaultRuleGroupTypeIC;\nfunction parseJSONata(\n  jsonataInput: string,\n  options: ParseJSONataOptions = {}\n): DefaultRuleGroupTypeAny {\n  const { fields, independentCombinators, listsAsArrays: _laa } = options;\n  const ic = !!independentCombinators;\n  const fieldsFlat = getFieldsArray(fields);\n\n  const fieldIsValid = (\n    fieldName: string,\n    operator: DefaultOperatorName,\n    subordinateFieldName?: string\n  ) =>\n    fieldIsValidUtil({\n      fieldName,\n      fieldsFlat,\n      operator,\n      subordinateFieldName,\n      getValueSources: options?.getValueSources,\n    });\n\n  const emptyQuery: DefaultRuleGroupTypeAny = {\n    rules: [],\n    ...(ic ? {} : { combinator: 'and' }),\n  };\n\n  const parseJSONataAST = (\n    expr: JSONataExprNode,\n    processOpts: {\n      groupOnlyIfNecessary?: boolean;\n      forwardNegation?: boolean;\n    } = {}\n  ): DefaultRuleType | DefaultRuleGroupTypeAny | null => {\n    const { forwardNegation: _forwardedNegation, groupOnlyIfNecessary: _g } = processOpts;\n    if (isJSONataBlock(expr)) {\n      if (\n        isJSONataAnd(expr.expressions[0]) ||\n        isJSONataOr(expr.expressions[0]) ||\n        isJSONataBlock(expr.expressions[0])\n      ) {\n        return parseJSONataAST(expr.expressions[0]);\n      }\n      const blockOfExpr = parseJSONataAST(expr.expressions[0]);\n      // istanbul ignore else\n      if (blockOfExpr) {\n        return ic\n          ? ({ rules: [blockOfExpr] } as DefaultRuleGroupTypeIC)\n          : ({\n              combinator: 'and',\n              rules: [blockOfExpr],\n            } as DefaultRuleGroupType);\n      }\n    } else if (isJSONataAnd(expr) || isJSONataOr(expr)) {\n      if (ic) {\n        const andOrList = generateFlatAndOrList(expr);\n        const rules = andOrList.map(v => {\n          if (typeof v === 'string') {\n            return v;\n          }\n          return parseJSONataAST(v);\n        });\n        // Bail out completely if any rules in the list were invalid\n        // so as not to return an incorrect and/or sequence\n        if (!rules.every(Boolean)) {\n          return null;\n        }\n        return {\n          rules: rules as DefaultRuleGroupICArray,\n        };\n      }\n      const andOrList = generateMixedAndOrList(expr);\n      const combinator = andOrList[1] as DefaultCombinatorName;\n      const filteredList = andOrList\n        .filter(v => Array.isArray(v) || (!!v && typeof v !== 'string' && 'type' in v))\n        .map(v =>\n          Array.isArray(v) ? v.filter(vf => !!v && typeof vf !== 'string' && 'type' in vf) : v\n        ) as (JSONataExprNode | JSONataExprNode[])[];\n      const rules = filteredList\n        .map((exp): DefaultRuleGroupType | DefaultRuleType | null => {\n          if (Array.isArray(exp)) {\n            return {\n              combinator: 'and',\n              rules: exp.map(e => parseJSONataAST(e)).filter(Boolean) as DefaultRuleGroupArray,\n            };\n          }\n          return parseJSONataAST(exp) as DefaultRuleType | DefaultRuleGroupType | null;\n        })\n        .filter(Boolean) as DefaultRuleGroupArray;\n      // istanbul ignore else\n      if (rules.length > 0) {\n        return { combinator, rules };\n      }\n    } else if (isJSONataNot(expr)) {\n      const negatedExpr = parseJSONataAST(expr.arguments[0]);\n      // istanbul ignore else\n      if (negatedExpr) {\n        if (\n          !isRuleGroup(negatedExpr) &&\n          (negatedExpr.operator === 'contains' ||\n            negatedExpr.operator === 'beginsWith' ||\n            negatedExpr.operator === 'endsWith')\n        ) {\n          return {\n            ...negatedExpr,\n            operator: negatedLikeOperators[negatedExpr.operator],\n          };\n        }\n        return ic\n          ? ({ rules: [negatedExpr], not: true } as DefaultRuleGroupTypeIC)\n          : ({\n              combinator: 'and',\n              rules: [negatedExpr],\n              not: true,\n            } as DefaultRuleGroupType);\n      }\n    } else if (isJSONataContains(expr)) {\n      const [arg1, arg2] = expr.arguments;\n      let field: string = '';\n      let regex: string | RegExp = '';\n      let valueSource: ValueSource | undefined = undefined;\n      // istanbul ignore else\n      if (isJSONataIdentifier(arg1)) {\n        field = getFieldFromPath(arg1);\n        if (isJSONataIdentifier(arg2)) {\n          regex = getFieldFromPath(arg2);\n          valueSource = 'field';\n        } else {\n          // istanbul ignore else\n          if (isJSONataString(arg2) || isJSONataRegex(arg2)) {\n            regex = getValidValue(arg2);\n          }\n        }\n      }\n\n      // istanbul ignore else\n      if (\n        valueSource === 'field'\n          ? fieldIsValid(field, 'contains', regex as string)\n          : fieldIsValid(field, 'contains')\n      ) {\n        return {\n          field,\n          operator: 'contains',\n          value: regex,\n          ...(valueSource ? { valueSource } : {}),\n        };\n      }\n    } else if (isJSONataIn(expr)) {\n      const field = getFieldFromPath(expr.lhs);\n      let valueSource: ValueSource | undefined = undefined;\n      if (isJSONataIdentifierList(expr.rhs)) {\n        valueSource = 'field';\n      }\n      if (isJSONataValidValue(expr.rhs)) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const value: any[] = getValidValue(expr.rhs);\n        // istanbul ignore else\n        if (\n          field &&\n          value.every(v => fieldIsValid(field, 'in', valueSource === 'field' ? v : undefined))\n        ) {\n          return { field, operator: 'in', value, ...(valueSource ? { valueSource } : {}) };\n        }\n      }\n    } else if (isJSONataComparison(expr)) {\n      let field: string | null = null;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let value: any = undefined;\n      let valueSource: ValueSource | undefined = undefined;\n      let flip = false;\n      const { lhs, rhs } = expr;\n\n      if (isJSONataIdentifier(lhs) && isJSONataValidValue(rhs)) {\n        field = getFieldFromPath(lhs);\n        value = getValidValue(rhs);\n        if (isJSONataIdentifier(rhs)) {\n          valueSource = 'field';\n        }\n      } else {\n        // istanbul ignore else\n        if (isJSONataIdentifier(rhs) && isJSONataValidValue(lhs)) {\n          flip = true;\n          field = getFieldFromPath(rhs);\n          value = getValidValue(lhs);\n        }\n      }\n      let operator = normalizeOperator(expr.value, flip);\n      if (value === null && (operator === '=' || operator === '!=')) {\n        operator = operator === '=' ? 'null' : 'notNull';\n      }\n      if (\n        field &&\n        fieldIsValid(field, operator, valueSource === 'field' ? value : undefined) &&\n        typeof value !== 'undefined'\n      ) {\n        return valueSource ? { field, operator, value, valueSource } : { field, operator, value };\n      }\n    }\n    return null;\n  };\n\n  let jsonataExpr: jsonata.Expression;\n  try {\n    jsonataExpr = jsonata(jsonataInput);\n  } catch (err) {\n    return emptyQuery;\n  }\n  const jsonataAST = jsonataExpr.ast() as JSONataExprNode;\n\n  const result = parseJSONataAST(jsonataAST);\n  if (result) {\n    if (isRuleGroup(result)) {\n      return result;\n    }\n    return { rules: [result], ...(ic ? {} : { combinator: 'and' }) };\n  }\n\n  return emptyQuery;\n}\n\nexport { parseJSONata };\n","import { numericRegex as numericQuantityRegex } from 'numeric-quantity';\n\n/**\n * Regex matching numeric strings. Passes for positive/negative integers, decimals,\n * and E notation, with optional surrounding whitespace.\n */\nexport const numericRegex = new RegExp(\n  numericQuantityRegex.source.replace(/^\\^/, '^\\\\s*').replace(/\\$$/, '\\\\s*$')\n);\n\n/**\n * Determines if a variable is a plain old JavaScript object, aka POJO.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isPojo = (obj: any): obj is Record<string, any> =>\n  obj === null || typeof obj !== 'object' ? false : Object.getPrototypeOf(obj) === Object.prototype;\n","import type { RuleGroupType, RuleGroupTypeAny, RuleGroupTypeIC } from '../types/index.noReact';\nimport { isPojo } from './misc';\n\n/**\n * Determines if an object is a {@link RuleGroupType} or {@link RuleGroupTypeIC}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isRuleGroup = (rg: any): rg is RuleGroupTypeAny =>\n  isPojo(rg) && 'rules' in rg && Array.isArray(rg.rules);\n\n/**\n * Determines if an object is a {@link RuleGroupType}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isRuleGroupType = (rg: any): rg is RuleGroupType =>\n  isRuleGroup(rg) && typeof rg.combinator === 'string';\n\n/**\n * Determines if an object is a {@link RuleGroupTypeIC}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isRuleGroupTypeIC = (rg: any): rg is RuleGroupTypeIC =>\n  isRuleGroup(rg) && typeof rg.combinator === 'undefined';\n","import { produce } from 'immer';\nimport type {\n  BaseOption,\n  BaseOptionMap,\n  FlexibleOption,\n  FlexibleOptionList,\n  FullOptionList,\n  Option,\n  ToFullOption,\n  ValueOption,\n} from '../types';\nimport { isPojo } from './misc';\nimport { isFlexibleOptionGroupArray } from './optGroupUtils';\n\nconst isOptionWithName = (opt: BaseOption): opt is Option =>\n  isPojo(opt) && 'name' in opt && typeof opt.name === 'string';\nconst isOptionWithValue = (opt: BaseOption): opt is ValueOption =>\n  isPojo(opt) && 'value' in opt && typeof opt.value === 'string';\n\n/**\n * Converts an {@link Option} or {@link ValueOption} (i.e., {@link BaseOption})\n * into a {@link FullOption}. Full options are left unchanged.\n */\nfunction toFullOption<Opt extends BaseOption>(\n  opt: Opt,\n  baseProperties?: Record<string, unknown>\n): ToFullOption<Opt> {\n  const recipe: (o: Opt) => ToFullOption<Opt> = produce(draft => {\n    const idObj: { name?: string; value?: string } = {};\n    let needsUpdating = !!baseProperties;\n\n    if (isOptionWithName(draft) && !isOptionWithValue(draft)) {\n      idObj.value = draft.name;\n      needsUpdating = true;\n    } else if (!isOptionWithName(draft) && isOptionWithValue(draft)) {\n      idObj.name = draft.value;\n      needsUpdating = true;\n    }\n\n    if (needsUpdating) {\n      return Object.assign({}, baseProperties, draft, idObj);\n    }\n  });\n  return recipe(opt);\n}\n\n/**\n * Converts an {@link OptionList} or {@link FlexibleOptionList} into a {@link FullOptionList}.\n * Lists of full options are left unchanged.\n */\nfunction toFullOptionList<Opt extends BaseOption, OptList extends FlexibleOptionList<Opt>>(\n  optList: OptList,\n  baseProperties?: Record<string, unknown>\n): FullOptionList<Opt> {\n  if (!Array.isArray(optList)) {\n    return [] as unknown as FullOptionList<Opt>;\n  }\n\n  const recipe: (ol: FlexibleOptionList<Opt>) => FullOptionList<Opt> = produce(draft => {\n    if (isFlexibleOptionGroupArray(draft)) {\n      for (const optGroup of draft) {\n        optGroup.options.forEach(\n          (opt, idx) => (optGroup.options[idx] = toFullOption(opt, baseProperties))\n        );\n      }\n    } else {\n      (draft as Opt[]).forEach((opt, idx) => (draft[idx] = toFullOption(opt, baseProperties)));\n    }\n  });\n\n  return recipe(optList);\n}\n\n/**\n * Converts a {@link FlexibleOptionList} into a {@link FullOptionList}.\n * Lists of full options are left unchanged.\n */\nfunction toFullOptionMap<OptMap extends BaseOptionMap>(\n  optMap: OptMap,\n  baseProperties?: Record<string, unknown>\n): OptMap extends BaseOptionMap<infer V, infer K> ? Partial<Record<K, ToFullOption<V>>> : never {\n  type FullOptMapType =\n    OptMap extends BaseOptionMap<infer VT, infer KT>\n      ? Partial<Record<KT, ToFullOption<VT>>>\n      : never;\n\n  return Object.fromEntries(\n    (Object.entries(optMap) as [string, FlexibleOption][]).map(([k, v]) => [\n      k,\n      toFullOption(v, baseProperties),\n    ])\n  ) as FullOptMapType;\n}\n\nexport { toFullOption, toFullOptionList, toFullOptionMap };\n","import type { RequireAtLeastOne } from 'type-fest';\nimport type {\n  BaseOption,\n  FlexibleOptionGroup,\n  FlexibleOptionList,\n  OptionGroup,\n  ToFullOption,\n  WithUnknownIndex,\n} from '../types/index.noReact';\nimport { isFlexibleOptionGroupArray } from './optGroupUtils';\nimport { toFullOption } from './toFullOption';\n\n/**\n * @deprecated Renamed to {@link uniqByIdentifier}.\n */\nexport const uniqByName = <\n  T extends { name: string; value?: string } | { name?: string; value: string },\n>(\n  originalArray: T[]\n): T[] => uniqByIdentifier(originalArray);\n\n/**\n * Generates a new array of objects with duplicates removed based\n * on the identifying property (`value` or `name`)\n */\nexport const uniqByIdentifier = <\n  T extends RequireAtLeastOne<{ name: string; value: string }, 'name' | 'value'>,\n>(\n  originalArray: T[]\n): T[] => {\n  const names = new Set<string>();\n  const newArray: T[] = [];\n  originalArray.forEach(el => {\n    if (!names.has((el.value ?? el.name)!)) {\n      names.add((el.value ?? el.name)!);\n      newArray.push(el);\n    }\n  });\n  return originalArray.length === newArray.length ? originalArray : newArray;\n};\n\n/**\n * Generates a new {@link OptionGroup} array with duplicates\n * removed based on the identifying property (`value` or `name`).\n */\nexport const uniqOptGroups = <T extends BaseOption>(\n  originalArray: FlexibleOptionGroup<T>[]\n): OptionGroup<ToFullOption<T>>[] => {\n  type K = T extends BaseOption<infer KT> ? KT : never;\n  const labels = new Set<string>();\n  const names = new Set<K>();\n  const newArray: OptionGroup<ToFullOption<T>>[] = [];\n  originalArray.forEach(el => {\n    if (!labels.has(el.label)) {\n      labels.add(el.label);\n      const optionsForThisGroup: WithUnknownIndex<ToFullOption<T>>[] = [];\n      el.options.forEach(opt => {\n        if (!names.has((opt.value ?? opt.name) as K)) {\n          names.add((opt.value ?? opt.name) as K);\n          optionsForThisGroup.push(toFullOption(opt) as WithUnknownIndex<ToFullOption<T>>);\n        }\n      });\n      newArray.push({ ...el, options: optionsForThisGroup });\n    }\n  });\n  return newArray;\n};\n\n/**\n * Generates a new {@link Option} or {@link OptionGroup} array with duplicates\n * removed based on the identifier property (`value` or `name`).\n */\nexport const uniqOptList = <T extends BaseOption>(originalArray: FlexibleOptionList<T>) => {\n  if (isFlexibleOptionGroupArray(originalArray)) {\n    return uniqOptGroups(originalArray) as OptionGroup<ToFullOption<T>>[];\n  }\n  return uniqByIdentifier((originalArray as BaseOption[]).map(o => toFullOption(o)));\n};\n","import type {\n  BaseOption,\n  FlexibleOptionGroup,\n  FullOption,\n  FullOptionList,\n  GetOptionIdentifierType,\n  Option,\n  OptionGroup,\n  OptionList,\n} from '../types/index.noReact';\nimport { isPojo } from './misc';\nimport { uniqByIdentifier } from './uniq';\n\n/**\n * Determines if an {@link OptionList} is an {@link OptionGroup} array.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isOptionGroupArray = (arr: any): arr is OptionGroup<BaseOption>[] =>\n  Array.isArray(arr) && arr.length > 0 && isPojo(arr[0]) && 'options' in arr[0];\n\n/**\n * Determines if a {@link FlexibleOptionList} is a {@link FlexibleOptionGroup} array.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isFlexibleOptionGroupArray = (arr: any): arr is FlexibleOptionGroup[] =>\n  Array.isArray(arr) &&\n  arr.length > 0 &&\n  isPojo(arr[0]) &&\n  'options' in arr[0] &&\n  isPojo(arr[0].options[0]) &&\n  ('name' in arr[0].options[0] || 'value' in arr[0].options[0]);\n\n/**\n * Determines if a {@link FlexibleOptionList} is a {@link OptionGroup} array of\n * {@link FullOption}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isFullOptionGroupArray = (arr: any): arr is OptionGroup<FullOption>[] =>\n  Array.isArray(arr) &&\n  arr.length > 0 &&\n  isPojo(arr[0]) &&\n  'options' in arr[0] &&\n  isPojo(arr[0].options[0]) &&\n  'name' in arr[0].options[0] &&\n  isPojo(arr[0].options[0]) &&\n  'value' in arr[0].options[0];\n\n/**\n * Gets the option from an {@link OptionList} with the given `name`. Handles\n * {@link Option} arrays as well as {@link OptionGroup} arrays.\n */\nexport const getOption = <OptType extends Option = Option>(\n  arr: OptionList<OptType>,\n  name: string\n): OptType | undefined =>\n  (isOptionGroupArray(arr) ? arr.flatMap(og => og.options) : arr).find(op => op.name === name);\n\n/**\n * Gets the first option from an {@link OptionList}.\n */\nexport const getFirstOption = <Opt extends BaseOption>(arr?: FlexibleOptionGroup<Opt>[] | Opt[]) =>\n  (!Array.isArray(arr) || arr.length === 0\n    ? null\n    : isFlexibleOptionGroupArray(arr)\n      ? arr[0].options[0].value ?? arr[0].options[0].name\n      : arr[0].value ?? arr[0].name) as GetOptionIdentifierType<Opt>;\n\n/**\n * Flattens {@link FlexibleOptionGroup} arrays into {@link BaseOption} arrays.\n * If the array is already flat, it is returned as is.\n */\nexport const toFlatOptionArray = <T extends FullOption, OL extends FullOptionList<T>>(arr: OL) =>\n  uniqByIdentifier(isOptionGroupArray(arr) ? arr.flatMap(og => og.options) : arr) as T[];\n","import type { FullField, OptionList } from '../types/index.noReact';\nimport { isFlexibleOptionGroupArray } from './optGroupUtils';\nimport { toFullOption } from './toFullOption';\n\nconst filterByComparator = (field: FullField, operator: string, fieldToCompare: FullField) => {\n  const fullField = toFullOption(field);\n  const fullFieldToCompare = toFullOption(fieldToCompare);\n  if (fullField.value === fullFieldToCompare.value) {\n    return false;\n  }\n  if (typeof fullField.comparator === 'string') {\n    return fullField[fullField.comparator] === fullFieldToCompare[fullField.comparator];\n  }\n  return fullField.comparator?.(fullFieldToCompare, operator) ?? /* istanbul ignore next */ false;\n};\n\n/**\n * For a given {@link FullField}, returns the `fields` list filtered for\n * other fields that match by `comparator`. Only fields *other than the\n * one in question* will ever be included, even if `comparator` is `null`\n * or `undefined`. If `comparator` is a string, fields with the same value\n * for that property will be included. If `comparator` is a function, each\n * field will be passed to the function along with the `operator` and fields\n * for which the function returns `true` will be included.\n */\nexport const filterFieldsByComparator = (\n  /** The field in question. */\n  field: FullField,\n  /** The full {@link FullField} list to be filtered. */\n  fields: OptionList<FullField>,\n  operator: string\n) => {\n  if (!field.comparator) {\n    const filterOutSameField = (f: FullField) =>\n      (f.value ?? /* istanbul ignore next */ f.name) !==\n      (field.value ?? /* istanbul ignore next */ field.name);\n    if (isFlexibleOptionGroupArray(fields)) {\n      return fields.map(og => ({\n        ...og,\n        options: og.options.filter(filterOutSameField),\n      }));\n    }\n    return fields.filter(filterOutSameField);\n  }\n\n  if (isFlexibleOptionGroupArray(fields)) {\n    return fields\n      .map(og => ({\n        ...og,\n        options: og.options.filter(f => filterByComparator(field, operator, f)),\n      }))\n      .filter(og => og.options.length > 0);\n  }\n\n  return fields.filter(f => filterByComparator(field, operator, f));\n};\n","import type { FullField, GetOptionIdentifierType, ValueSources } from '../types/index.noReact';\nimport { toFullOption } from './toFullOption';\n\nconst defaultValueSourcesArray: ValueSources = ['value'];\n\nconst dummyFD = {\n  name: 'name',\n  value: 'name',\n  valueSources: null,\n  label: 'label',\n};\n\n/**\n * Utility function to get the value sources array for the given\n * field and operator. If the field definition does not define a\n * `valueSources` property, the `getValueSources` prop is used.\n * Returns `[\"value\"]` by default.\n */\nexport const getValueSourcesUtil = <F extends FullField, O extends string>(\n  fieldData: F,\n  operator: string,\n  getValueSources?: (\n    field: GetOptionIdentifierType<F>,\n    operator: O,\n    misc: { fieldData: F }\n  ) => ValueSources\n): ValueSources => {\n  // TypeScript doesn't allow it directly, but in practice\n  // `fieldData` can end up being undefined or null. The nullish\n  // coalescing assignment below avoids errors like\n  // \"TypeError: Cannot read properties of undefined (reading 'name')\"\n  const fd = fieldData ? toFullOption(fieldData) : /* istanbul ignore else */ dummyFD;\n\n  if (fd.valueSources) {\n    if (typeof fd.valueSources === 'function') {\n      return fd.valueSources(operator as O);\n    }\n    return fd.valueSources;\n  }\n  if (getValueSources) {\n    const vals = getValueSources(fd.value as GetOptionIdentifierType<F>, operator as O, {\n      fieldData: toFullOption(fd) as F,\n    });\n    /* istanbul ignore else */\n    if (vals) return vals;\n  }\n\n  return defaultValueSourcesArray;\n};\n","import type {\n  DefaultOperatorName,\n  FullField,\n  OptionList,\n  ValueSources,\n} from '../types/index.noReact';\nimport { filterFieldsByComparator } from './filterFieldsByComparator';\nimport { getValueSourcesUtil } from './getValueSourcesUtil';\nimport { toFlatOptionArray } from './optGroupUtils';\nimport { toFullOption } from './toFullOption';\n\nexport const getFieldsArray = (fields?: OptionList<FullField> | Record<string, FullField>) => {\n  const fieldsArray = !fields\n    ? []\n    : Array.isArray(fields)\n      ? fields\n      : Object.keys(fields)\n          .map(fld => ({ ...fields[fld], name: fld }))\n          .sort((a, b) => a.label.localeCompare(b.label));\n  return toFlatOptionArray(fieldsArray);\n};\n\nexport function fieldIsValidUtil(params: {\n  fieldsFlat: FullField[];\n  getValueSources?: (field: string, operator: string) => ValueSources;\n  fieldName: string;\n  operator: DefaultOperatorName;\n  subordinateFieldName?: string;\n}) {\n  const { fieldsFlat, fieldName, operator, subordinateFieldName, getValueSources } = params;\n\n  // If fields option was an empty array or undefined, then all identifiers\n  // are considered valid.\n  if (fieldsFlat.length === 0) return true;\n\n  let valid = false;\n\n  const primaryField = toFullOption(fieldsFlat.find(ff => ff.name === fieldName)!);\n  if (primaryField) {\n    if (\n      !subordinateFieldName &&\n      operator !== 'notNull' &&\n      operator !== 'null' &&\n      !getValueSourcesUtil(primaryField, operator, getValueSources).some(vs => vs === 'value')\n    ) {\n      valid = false;\n    } else {\n      valid = true;\n    }\n\n    if (valid && !!subordinateFieldName) {\n      if (\n        getValueSourcesUtil(primaryField, operator, getValueSources).some(vs => vs === 'field') &&\n        fieldName !== subordinateFieldName\n      ) {\n        const validSubordinateFields = filterFieldsByComparator(\n          primaryField,\n          fieldsFlat,\n          operator\n        ) as FullField[];\n        if (!validSubordinateFields.find(vsf => vsf.name === subordinateFieldName)) {\n          valid = false;\n        }\n      } else {\n        valid = false;\n      }\n    }\n  }\n\n  return valid;\n}\n","import type { DefaultCombinatorName, DefaultOperatorName } from '../../types';\nimport type {\n  JSONataAnd,\n  JSONataBinaryNode,\n  JSONataBlock,\n  JSONataBoolean,\n  JSONataContains,\n  JSONataEqual,\n  JSONataExprNode,\n  JSONataGreaterThan,\n  JSONataGreaterThanOrEqual,\n  JSONataIdentifier,\n  JSONataIn,\n  JSONataLessThan,\n  JSONataLessThanOrEqual,\n  JSONataList,\n  JSONataName,\n  JSONataNot,\n  JSONataNotEqual,\n  JSONataNull,\n  JSONataNumber,\n  JSONataOr,\n  JSONataPath,\n  JSONataRegex,\n  JSONataString,\n  JSONataToMillis,\n} from './types';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Any = any;\n\nexport const isJSONataExprNode = (expr: Any): expr is JSONataExprNode => {\n  return expr && typeof expr === 'object' && typeof expr.type === 'string';\n};\nconst isJSONataBinaryNode = (expr: Any): expr is JSONataBinaryNode =>\n  isJSONataExprNode(expr) && expr.type === 'binary';\n\n// Identifiers\nexport const isJSONataPath = (expr: Any): expr is JSONataPath =>\n  isJSONataExprNode(expr) &&\n  expr.type === 'path' &&\n  Array.isArray(expr.steps) &&\n  expr.steps.length > 0 &&\n  isJSONataExprNode(expr.steps[0]);\nexport const isJSONataName = (expr: Any): expr is JSONataName =>\n  isJSONataExprNode(expr) &&\n  expr.type === 'name' &&\n  typeof expr.value === 'string' &&\n  expr.value.length > 0;\nexport const isJSONataIdentifier = (expr: Any): expr is JSONataIdentifier =>\n  isJSONataPath(expr) && expr.steps.every(isJSONataName);\n\n// Groups\nexport const isJSONataBlock = (expr: Any): expr is JSONataBlock =>\n  isJSONataExprNode(expr) &&\n  expr.type === 'block' &&\n  Array.isArray(expr.expressions) &&\n  expr.expressions.length > 0 &&\n  isJSONataExprNode(expr.expressions[0]);\n\n// Values\nexport const isJSONataString = (expr: Any): expr is JSONataString =>\n  isJSONataExprNode(expr) && expr.type === 'string' && typeof expr.value === 'string';\nexport const isJSONataNumber = (expr: Any): expr is JSONataNumber =>\n  isJSONataExprNode(expr) && expr.type === 'number' && typeof expr.value === 'number';\nexport const isJSONataBoolean = (expr: Any): expr is JSONataBoolean =>\n  isJSONataExprNode(expr) && expr.type === 'value' && typeof expr.value === 'boolean';\nexport const isJSONataNull = (expr: Any): expr is JSONataNull =>\n  isJSONataExprNode(expr) && expr.type === 'value' && expr.value === null;\nexport const isJSONataRegex = (expr: Any): expr is JSONataRegex =>\n  isJSONataExprNode(expr) && expr.type === 'regex' && expr.value instanceof RegExp;\n\n// Combinators\nexport const isJSONataAnd = (expr: Any): expr is JSONataAnd =>\n  isJSONataBinaryNode(expr) && expr.value === 'and';\nexport const isJSONataOr = (expr: Any): expr is JSONataOr =>\n  isJSONataBinaryNode(expr) && expr.value === 'or';\n\n// Operators\nexport const isJSONataEqual = (expr: Any): expr is JSONataEqual =>\n  isJSONataBinaryNode(expr) && expr.value === '=';\nexport const isJSONataNotEqual = (expr: Any): expr is JSONataNotEqual =>\n  isJSONataBinaryNode(expr) && expr.value === '!=';\nexport const isJSONataGreaterThan = (expr: Any): expr is JSONataGreaterThan =>\n  isJSONataBinaryNode(expr) && expr.value === '>';\nexport const isJSONataGreaterThanOrEqual = (expr: Any): expr is JSONataGreaterThanOrEqual =>\n  isJSONataBinaryNode(expr) && expr.value === '>=';\nexport const isJSONataLessThan = (expr: Any): expr is JSONataLessThan =>\n  isJSONataBinaryNode(expr) && expr.value === '<';\nexport const isJSONataLessThanOrEqual = (expr: Any): expr is JSONataLessThanOrEqual =>\n  isJSONataBinaryNode(expr) && expr.value === '<=';\nexport const isJSONataIn = (expr: Any): expr is JSONataIn =>\n  isJSONataBinaryNode(expr) &&\n  expr.value === 'in' &&\n  isJSONataPath(expr.lhs) &&\n  isJSONataList(expr.rhs);\n\n// Functions\nexport const isJSONataNot = (expr: Any): expr is JSONataNot =>\n  isJSONataExprNode(expr) &&\n  expr.type === 'function' &&\n  expr.value === '(' &&\n  Array.isArray(expr.arguments) &&\n  isJSONataExprNode(expr.arguments[0]) &&\n  isJSONataExprNode(expr.procedure) &&\n  expr.procedure.value === 'not' &&\n  expr.procedure.type === 'variable';\nexport const isJSONataContains = (expr: Any): expr is JSONataContains =>\n  isJSONataExprNode(expr) &&\n  expr.type === 'function' &&\n  expr.value === '(' &&\n  Array.isArray(expr.arguments) &&\n  expr.arguments.length >= 2 &&\n  isJSONataExprNode(expr.arguments[0]) &&\n  isJSONataExprNode(expr.procedure) &&\n  expr.procedure.value === 'contains' &&\n  expr.procedure.type === 'variable';\nexport const isJSONataToMillis = (expr: Any): expr is JSONataToMillis =>\n  isJSONataExprNode(expr) &&\n  expr.type === 'function' &&\n  expr.value === '(' &&\n  Array.isArray(expr.arguments) &&\n  expr.arguments.length > 0 &&\n  isJSONataString(expr.arguments[0]) &&\n  isJSONataExprNode(expr.procedure) &&\n  expr.procedure.value === 'toMillis' &&\n  expr.procedure.type === 'variable';\n\n// Miscellaneous\nexport const isJSONataList = (expr: Any): expr is JSONataList =>\n  isJSONataExprNode(expr) &&\n  expr.type === 'unary' &&\n  expr.value === '[' &&\n  Array.isArray(expr.expressions);\nexport const isJSONataPrimitive = (expr: Any): boolean => {\n  return (\n    isJSONataString(expr) ||\n    isJSONataNumber(expr) ||\n    isJSONataBoolean(expr) ||\n    isJSONataNull(expr) ||\n    isJSONataToMillis(expr)\n  );\n};\nexport const isJSONataPrimitiveList = (expr: Any): boolean =>\n  isJSONataList(expr) && expr.expressions.every(isJSONataPrimitive);\nexport const isJSONataIdentifierList = (expr: Any): boolean =>\n  isJSONataList(expr) && expr.expressions.every(isJSONataIdentifier);\nexport const isJSONataValidValue = (expr: Any): boolean =>\n  isJSONataPrimitive(expr) ||\n  isJSONataRegex(expr) ||\n  isJSONataIdentifier(expr) ||\n  isJSONataPrimitiveList(expr) ||\n  isJSONataIdentifierList(expr) ||\n  isJSONataToMillis(expr);\nexport const isJSONataComparison = (\n  expr: Any\n): expr is\n  | JSONataEqual\n  | JSONataNotEqual\n  | JSONataGreaterThan\n  | JSONataGreaterThanOrEqual\n  | JSONataLessThan\n  | JSONataLessThanOrEqual =>\n  isJSONataEqual(expr) ||\n  isJSONataNotEqual(expr) ||\n  isJSONataGreaterThan(expr) ||\n  isJSONataGreaterThanOrEqual(expr) ||\n  isJSONataLessThan(expr) ||\n  isJSONataLessThanOrEqual(expr);\n\nexport const getValidValue = (expr: Any): Any => {\n  if (isJSONataToMillis(expr)) {\n    return getValidValue(expr.arguments[0]);\n  } else if (isJSONataIdentifier(expr)) {\n    return getFieldFromPath(expr);\n  } else if (isJSONataPrimitiveList(expr)) {\n    return expr.expressions.map(getValidValue);\n  } else if (isJSONataIdentifierList(expr)) {\n    return expr.expressions.map(getFieldFromPath);\n  }\n  return expr.value;\n};\n\nexport const getFieldFromPath = (path: JSONataPath): string =>\n  isJSONataIdentifier(path)\n    ? path.steps.map(s => s.value).join('.')\n    : /* istanbul ignore next */ '';\n\nexport const normalizeOperator = (\n  opType: DefaultOperatorName,\n  flip?: boolean\n): DefaultOperatorName => {\n  if (flip) {\n    if (opType === '<') return '>';\n    if (opType === '<=') return '>=';\n    if (opType === '>') return '<';\n    if (opType === '>=') return '<=';\n  }\n  return opType;\n};\n\nexport const negatedLikeOperators = {\n  contains: 'doesNotContain',\n  beginsWith: 'doesNotBeginWith',\n  endsWith: 'doesNotEndWith',\n} satisfies Partial<Record<DefaultOperatorName, DefaultOperatorName>>;\n\nexport const generateFlatAndOrList = (\n  expr: JSONataExprNode\n): (DefaultCombinatorName | JSONataExprNode)[] => {\n  // istanbul ignore else\n  if (isJSONataAnd(expr) || isJSONataOr(expr)) {\n    const { lhs, rhs, value: combinator } = expr;\n    if (isJSONataAnd(lhs) || isJSONataOr(lhs)) {\n      return [...generateFlatAndOrList(lhs), combinator, rhs];\n    }\n    return [lhs, combinator, rhs];\n  }\n  // istanbul ignore next\n  return [];\n};\n\nexport const generateMixedAndOrList = (expr: JSONataAnd | JSONataOr) => {\n  const arr = generateFlatAndOrList(expr);\n  const returnArray: (DefaultCombinatorName | JSONataExprNode | ('and' | JSONataExprNode)[])[] = [];\n  let startIndex = 0;\n  for (let i = 0; i < arr.length; i += 2) {\n    if (arr[i + 1] === 'and') {\n      startIndex = i;\n      let j = 1;\n      while (arr[startIndex + j] === 'and') {\n        i += 2;\n        j += 2;\n      }\n      const tempAndArray = arr.slice(startIndex, i + 1) as ('and' | JSONataExprNode)[];\n      returnArray.push(tempAndArray);\n      i -= 2;\n    } else if (arr[i + 1] === 'or') {\n      if (i === 0 || i === arr.length - 3) {\n        if (i === 0 || arr[i - 1] === 'or') {\n          returnArray.push(arr[i]);\n        }\n        returnArray.push(arr[i + 1]);\n        if (i === arr.length - 3) {\n          returnArray.push(arr[i + 2]);\n        }\n      } else {\n        if (arr[i - 1] === 'and') {\n          returnArray.push(arr[i + 1]);\n        } else {\n          returnArray.push(arr[i]);\n          returnArray.push(arr[i + 1]);\n        }\n      }\n    }\n  }\n  if (returnArray.length === 1 && Array.isArray(returnArray[0])) {\n    // If length is 1, then the only element is an AND array so just return that\n    return returnArray[0];\n  }\n  return returnArray;\n};\n"],"mappings":"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","names":["exports","module","define","i","r","n","require","words","start","dateTime","global","length","count","self","position","index","str","ii","parts","error","decimalPos","value","merge","result","jsonata","res","item","key","entry","env","err","parser","symbol","infix","expr","node","step","expression","signature","param","numericQuantityRegex","andOrList","rules","jsonata"]}