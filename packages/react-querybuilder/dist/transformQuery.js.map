{"version":3,"sources":["../src/utils/transformQuery.ts","../src/utils/misc.ts","../src/utils/isRuleGroup.ts"],"sourcesContent":["import { produce } from 'immer';\nimport type {\n  RuleGroupType,\n  RuleGroupTypeAny,\n  RuleGroupTypeIC,\n  RuleType,\n} from '../types/index.noReact';\nimport { isRuleGroup, isRuleGroupType } from './isRuleGroup';\n\nconst remapProperties = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  obj: Record<string, any>,\n  propertyMap: Record<string, string | false>,\n  deleteRemappedProperties: boolean\n) =>\n  produce(obj, draft => {\n    for (const [k, v] of Object.entries(propertyMap)) {\n      if (v === false) {\n        delete draft[k];\n      } else if (!!v && k !== v && k in draft) {\n        draft[v] = draft[k];\n        if (deleteRemappedProperties) {\n          delete draft[k];\n        }\n      }\n    }\n  });\n\n/**\n * Options object for {@link transformQuery}.\n */\nexport interface TransformQueryOptions<RG extends RuleGroupTypeAny = RuleGroupType> {\n  /**\n   * When a rule is encountered in the hierarchy, it will be replaced\n   * with the result of this function.\n   *\n   * @defaultValue `r => r`\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ruleProcessor?: (rule: RuleType) => any;\n  /**\n   * When a group is encountered in the hierarchy (including the root group, the\n   * query itself), it will be replaced with the result of this function.\n   *\n   * @defaultValue `rg => rg`\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ruleGroupProcessor?: (ruleGroup: RG) => Record<string, any>;\n  /**\n   * For each rule and group in the query, any properties matching a key\n   * in this object will be renamed to the corresponding value. To retain both\n   * the new _and_ the original properties, set `deleteRemappedProperties`\n   * to `false`.\n   *\n   * If a key has a value of `false`, the corresponding property will be removed\n   * without being copied to a new property name. (Warning: `{ rules: false }`\n   * will prevent recursion and only return the processed root group.)\n   *\n   * @defaultValue `{}`\n   *\n   * @example\n   * ```\n   *   transformQuery(\n   *     { combinator: 'and', not: true, rules: [] },\n   *     { propertyMap: { combinator: 'AndOr', not: false } }\n   *   )\n   *   // Returns: { AndOr: 'and', rules: [] }\n   * ```\n   */\n  propertyMap?: Record<string, string | false>;\n  /**\n   * Any combinator values (including independent combinators) will be translated\n   * from the key in this object to the value.\n   *\n   * @defaultValue `{}`\n   *\n   * @example\n   * ```\n   *   transformQuery(\n   *     { combinator: 'and', rules: [] },\n   *     { combinatorMap: { and: '&&', or: '||' } }\n   *   )\n   *   // Returns: { combinator: '&&', rules: [] }\n   * ```\n   */\n  combinatorMap?: Record<string, string>;\n  /**\n   * Any operator values will be translated from the key in this object to the value.\n   *\n   * @defaultValue `{}`\n   *\n   * @example\n   * ```\n   *   transformQuery(\n   *     { combinator: 'and', rules: [{ field: 'name', operator: '=', value: 'Steve Vai' }] },\n   *     { operatorMap: { '=': 'is' } }\n   *   )\n   *   // Returns:\n   *   // {\n   *   //   combinator: 'and',\n   *   //   rules: [{ field: 'name', operator: 'is', value: 'Steve Vai' }]\n   *   // }\n   * ```\n   */\n  operatorMap?: Record<string, string>;\n  /**\n   * Prevents the `path` property (see {@link Path}) from being added to each\n   * rule and group in the hierarchy.\n   *\n   * @defaultValue `false`\n   */\n  omitPath?: boolean;\n  /**\n   * Original properties remapped according to the `propertyMap` option will be removed.\n   *\n   * @defaultValue `true`\n   *\n   * @example\n   * ```\n   *   transformQuery(\n   *     { combinator: 'and', rules: [] },\n   *     { propertyMap: { combinator: 'AndOr' }, deleteRemappedProperties: false }\n   *   )\n   *   // Returns: { combinator: 'and', AndOr: 'and', rules: [] }\n   * ```\n   */\n  deleteRemappedProperties?: boolean;\n}\n\n/**\n * Recursively process a query heirarchy using this versatile utility function.\n *\n * [Documentation](https://react-querybuilder.js.org/docs/utils/misc#transformquery)\n */\nexport function transformQuery(\n  query: RuleGroupType,\n  options?: TransformQueryOptions<RuleGroupType>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): any;\n/**\n * Recursively process a query heirarchy with independent combinators using this\n * versatile utility function.\n *\n * [Documentation](https://react-querybuilder.js.org/docs/utils/misc#transformquery)\n */\nexport function transformQuery(\n  query: RuleGroupTypeIC,\n  options?: TransformQueryOptions<RuleGroupTypeIC>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): any;\nexport function transformQuery<RG extends RuleGroupTypeAny>(\n  query: RG,\n  options: TransformQueryOptions<RG> = {}\n) {\n  const {\n    ruleProcessor = r => r,\n    ruleGroupProcessor = rg => rg,\n    propertyMap = {},\n    combinatorMap = {},\n    operatorMap = {},\n    omitPath = false,\n    deleteRemappedProperties = true,\n  } = options;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const processGroup = (rg: RuleGroupTypeAny): any => ({\n    ...ruleGroupProcessor(\n      remapProperties(\n        {\n          ...rg,\n          ...(isRuleGroupType(rg)\n            ? { combinator: combinatorMap[rg.combinator] ?? rg.combinator }\n            : {}),\n        },\n        propertyMap,\n        deleteRemappedProperties\n      ) as RG\n    ),\n    ...(propertyMap['rules'] === false\n      ? null\n      : {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          [propertyMap['rules'] ?? 'rules']: rg.rules.map((r: any, idx) => {\n            const pathObject = omitPath ? null : { path: [...rg.path!, idx] };\n            if (typeof r === 'string') {\n              // independent combinators\n              return combinatorMap[r] ?? r;\n            } else if (isRuleGroup(r)) {\n              // sub-groups\n              return processGroup({ ...r, ...pathObject });\n            }\n            // rules\n            return ruleProcessor(\n              remapProperties(\n                {\n                  ...{ ...r, ...pathObject },\n                  ...('operator' in r ? { operator: operatorMap[r.operator] ?? r.operator } : {}),\n                },\n                propertyMap,\n                deleteRemappedProperties\n              ) as RuleType\n            );\n          }),\n        }),\n  });\n\n  return processGroup({ ...query, ...(omitPath ? null : { path: [] }) });\n}\n","import { numericRegex as numericQuantityRegex } from 'numeric-quantity';\n\n/**\n * Regex matching numeric strings. Passes for positive/negative integers, decimals,\n * and E notation, with optional surrounding whitespace.\n */\nexport const numericRegex = new RegExp(\n  numericQuantityRegex.source.replace(/^\\^/, '^\\\\s*').replace(/\\$$/, '\\\\s*$')\n);\n\n/**\n * Determines if a variable is a plain old JavaScript object, aka POJO.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isPojo = (obj: any): obj is Record<string, any> =>\n  obj === null || typeof obj !== 'object' ? false : Object.getPrototypeOf(obj) === Object.prototype;\n","import type { RuleGroupType, RuleGroupTypeAny, RuleGroupTypeIC } from '../types/index.noReact';\nimport { isPojo } from './misc';\n\n/**\n * Determines if an object is a {@link RuleGroupType} or {@link RuleGroupTypeIC}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isRuleGroup = (rg: any): rg is RuleGroupTypeAny =>\n  isPojo(rg) && 'rules' in rg && Array.isArray(rg.rules);\n\n/**\n * Determines if an object is a {@link RuleGroupType}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isRuleGroupType = (rg: any): rg is RuleGroupType =>\n  isRuleGroup(rg) && typeof rg.combinator === 'string';\n\n/**\n * Determines if an object is a {@link RuleGroupTypeIC}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isRuleGroupTypeIC = (rg: any): rg is RuleGroupTypeIC =>\n  isRuleGroup(rg) && typeof rg.combinator === 'undefined';\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAwB;;;ACAxB,8BAAqD;AAM9C,IAAM,eAAe,IAAI;AAAA,EAC9B,wBAAAA,aAAqB,OAAO,QAAQ,OAAO,OAAO,EAAE,QAAQ,OAAO,OAAO;AAC5E;AAMO,IAAM,SAAS,CAAC,QACrB,QAAQ,QAAQ,OAAO,QAAQ,WAAW,QAAQ,OAAO,eAAe,GAAG,MAAM,OAAO;;;ACRnF,IAAM,cAAc,CAAC,OAC1B,OAAO,EAAE,KAAK,WAAW,MAAM,MAAM,QAAQ,GAAG,KAAK;AAMhD,IAAM,kBAAkB,CAAC,OAC9B,YAAY,EAAE,KAAK,OAAO,GAAG,eAAe;;;AFN9C,IAAM,kBAAkB,CAEtB,KACA,aACA,iCAEA,sBAAQ,KAAK,WAAS;AACpB,aAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ,WAAW,GAAG;AAChD,QAAI,MAAM,OAAO;AACf,aAAO,MAAM,CAAC;AAAA,IAChB,WAAW,CAAC,CAAC,KAAK,MAAM,KAAK,KAAK,OAAO;AACvC,YAAM,CAAC,IAAI,MAAM,CAAC;AAClB,UAAI,0BAA0B;AAC5B,eAAO,MAAM,CAAC;AAAA,MAChB;AAAA,IACF;AAAA,EACF;AACF,CAAC;AA4HI,SAAS,eACd,OACA,UAAqC,CAAC,GACtC;AACA,QAAM;AAAA,IACJ,gBAAgB,OAAK;AAAA,IACrB,qBAAqB,QAAM;AAAA,IAC3B,cAAc,CAAC;AAAA,IACf,gBAAgB,CAAC;AAAA,IACjB,cAAc,CAAC;AAAA,IACf,WAAW;AAAA,IACX,2BAA2B;AAAA,EAC7B,IAAI;AAGJ,QAAM,eAAe,CAAC,QAA+B;AAAA,IACnD,GAAG;AAAA,MACD;AAAA,QACE;AAAA,UACE,GAAG;AAAA,UACH,GAAI,gBAAgB,EAAE,IAClB,EAAE,YAAY,cAAc,GAAG,UAAU,KAAK,GAAG,WAAW,IAC5D,CAAC;AAAA,QACP;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,IACA,GAAI,YAAY,OAAO,MAAM,QACzB,OACA;AAAA;AAAA,MAEE,CAAC,YAAY,OAAO,KAAK,OAAO,GAAG,GAAG,MAAM,IAAI,CAAC,GAAQ,QAAQ;AAC/D,cAAM,aAAa,WAAW,OAAO,EAAE,MAAM,CAAC,GAAG,GAAG,MAAO,GAAG,EAAE;AAChE,YAAI,OAAO,MAAM,UAAU;AAEzB,iBAAO,cAAc,CAAC,KAAK;AAAA,QAC7B,WAAW,YAAY,CAAC,GAAG;AAEzB,iBAAO,aAAa,EAAE,GAAG,GAAG,GAAG,WAAW,CAAC;AAAA,QAC7C;AAEA,eAAO;AAAA,UACL;AAAA,YACE;AAAA,cACE,GAAG,EAAE,GAAG,GAAG,GAAG,WAAW;AAAA,cACzB,GAAI,cAAc,IAAI,EAAE,UAAU,YAAY,EAAE,QAAQ,KAAK,EAAE,SAAS,IAAI,CAAC;AAAA,YAC/E;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACN;AAEA,SAAO,aAAa,EAAE,GAAG,OAAO,GAAI,WAAW,OAAO,EAAE,MAAM,CAAC,EAAE,EAAG,CAAC;AACvE;","names":["numericQuantityRegex"]}