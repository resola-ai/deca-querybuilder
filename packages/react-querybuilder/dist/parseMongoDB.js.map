{"version":3,"sources":["../src/utils/parseMongoDB/index.ts","../src/defaults.ts","../src/utils/misc.ts","../src/utils/isRuleGroup.ts","../src/utils/convertQuery.ts","../src/utils/objectUtils.ts","../src/utils/toFullOption.ts","../src/utils/uniq.ts","../src/utils/optGroupUtils.ts","../src/utils/filterFieldsByComparator.ts","../src/utils/getValueSourcesUtil.ts","../src/utils/parserUtils.ts","../src/utils/parseMongoDB/utils.ts","../src/utils/parseMongoDB/parseMongoDB.ts"],"sourcesContent":["export * from './parseMongoDB';\n","import type {\n  Classnames,\n  DefaultCombinator,\n  DefaultCombinatorExtended,\n  DefaultOperator,\n  DefaultOperatorName,\n  TranslationsFull,\n} from './types/index.noReact';\n\n// DO NOT ALTER OR REMOVE REGION NAMES. Some of them are used\n// to generate code snippets in the documentation.\n\nconst placeholderName = '~';\nconst placeholderLabel = '------';\n/**\n * Default `name` for placeholder option in the `fields` array.\n */\nexport const defaultPlaceholderFieldName = placeholderName;\n/**\n * Default `label` for placeholder option in the `fields` array.\n */\nexport const defaultPlaceholderFieldLabel = placeholderLabel;\n/**\n * Default `label` for placeholder option group in the `fields` array.\n */\nexport const defaultPlaceholderFieldGroupLabel = placeholderLabel;\n/**\n * Default `name` for placeholder option in the `operators` array.\n */\nexport const defaultPlaceholderOperatorName = placeholderName;\n/**\n * Default `label` for placeholder option in the `operators` array.\n */\nexport const defaultPlaceholderOperatorLabel = placeholderLabel;\n/**\n * Default `label` for placeholder option group in the `operators` array.\n */\nexport const defaultPlaceholderOperatorGroupLabel = placeholderLabel;\n\n/**\n * Default character used to `.join` and `.split` arrays.\n */\nexport const defaultJoinChar = ',';\n\n/**\n * Default configuration of translatable strings.\n */\n// #region docs-translations\nexport const defaultTranslations = {\n  fields: {\n    title: 'Fields',\n    placeholderName: defaultPlaceholderFieldName,\n    placeholderLabel: defaultPlaceholderFieldLabel,\n    placeholderGroupLabel: defaultPlaceholderFieldGroupLabel,\n  } as const,\n  operators: {\n    title: 'Operators',\n    placeholderName: defaultPlaceholderOperatorName,\n    placeholderLabel: defaultPlaceholderOperatorLabel,\n    placeholderGroupLabel: defaultPlaceholderOperatorGroupLabel,\n  } as const,\n  value: {\n    title: 'Value',\n  } as const,\n  removeRule: {\n    label: '‚®Ø',\n    title: 'Remove rule',\n  } as const,\n  removeGroup: {\n    label: '‚®Ø',\n    title: 'Remove group',\n  } as const,\n  addRule: {\n    label: '+ Rule',\n    title: 'Add rule',\n  } as const,\n  addGroup: {\n    label: '+ Group',\n    title: 'Add group',\n  } as const,\n  combinators: {\n    title: 'Combinators',\n  } as const,\n  notToggle: {\n    label: 'Not',\n    title: 'Invert this group',\n  } as const,\n  cloneRule: {\n    label: '‚ßâ',\n    title: 'Clone rule',\n  } as const,\n  cloneRuleGroup: {\n    label: '‚ßâ',\n    title: 'Clone group',\n  } as const,\n  shiftActionUp: {\n    label: 'ÀÑ',\n    title: 'Shift up',\n  } as const,\n  shiftActionDown: {\n    label: 'ÀÖ',\n    title: 'Shift down',\n  } as const,\n  dragHandle: {\n    label: '‚Åû‚Åû',\n    title: 'Drag handle',\n  } as const,\n  lockRule: {\n    label: 'üîì',\n    title: 'Lock rule',\n  } as const,\n  lockGroup: {\n    label: 'üîì',\n    title: 'Lock group',\n  } as const,\n  lockRuleDisabled: {\n    label: 'üîí',\n    title: 'Unlock rule',\n  } as const,\n  lockGroupDisabled: {\n    label: 'üîí',\n    title: 'Unlock group',\n  } as const,\n  valueSourceSelector: {\n    title: 'Value source',\n  } as const,\n} satisfies TranslationsFull;\n// #endregion\n\n/**\n * Default operator list.\n */\n// #region docs-operators\nexport const defaultOperators = [\n  { name: '=', value: '=', label: '=' } as const,\n  { name: '!=', value: '!=', label: '!=' } as const,\n  { name: '<', value: '<', label: '<' } as const,\n  { name: '>', value: '>', label: '>' } as const,\n  { name: '<=', value: '<=', label: '<=' } as const,\n  { name: '>=', value: '>=', label: '>=' } as const,\n  { name: 'contains', value: 'contains', label: 'contains' } as const,\n  { name: 'beginsWith', value: 'beginsWith', label: 'begins with' } as const,\n  { name: 'endsWith', value: 'endsWith', label: 'ends with' } as const,\n  { name: 'doesNotContain', value: 'doesNotContain', label: 'does not contain' } as const,\n  { name: 'doesNotBeginWith', value: 'doesNotBeginWith', label: 'does not begin with' } as const,\n  { name: 'doesNotEndWith', value: 'doesNotEndWith', label: 'does not end with' } as const,\n  { name: 'null', value: 'null', label: 'is null' } as const,\n  { name: 'notNull', value: 'notNull', label: 'is not null' } as const,\n  { name: 'in', value: 'in', label: 'in' } as const,\n  { name: 'notIn', value: 'notIn', label: 'not in' } as const,\n  { name: 'between', value: 'between', label: 'between' } as const,\n  { name: 'notBetween', value: 'notBetween', label: 'not between' } as const,\n] satisfies DefaultOperator[];\n// #endregion\n\n/**\n * Map of default operators to their respective opposite/negating operators.\n */\nexport const defaultOperatorNegationMap = {\n  '=': '!=',\n  '!=': '=',\n  '<': '>=',\n  '<=': '>',\n  '>': '<=',\n  '>=': '<',\n  beginsWith: 'doesNotBeginWith',\n  doesNotBeginWith: 'beginsWith',\n  endsWith: 'doesNotEndWith',\n  doesNotEndWith: 'endsWith',\n  contains: 'doesNotContain',\n  doesNotContain: 'contains',\n  between: 'notBetween',\n  notBetween: 'between',\n  in: 'notIn',\n  notIn: 'in',\n  notNull: 'null',\n  null: 'notNull',\n} satisfies Record<DefaultOperatorName, DefaultOperatorName>;\n\n/**\n * Default combinator list.\n */\n// #region docs-combinators\nexport const defaultCombinators = [\n  { name: 'and', value: 'and', label: 'AND' } as const,\n  { name: 'or', value: 'or', label: 'OR' } as const,\n] satisfies DefaultCombinator[];\n// #endregion\n\n/**\n * Default combinator list, with `XOR` added.\n */\nexport const defaultCombinatorsExtended = [\n  ...defaultCombinators,\n  { name: 'xor', value: 'xor', label: 'XOR' } as const,\n] satisfies DefaultCombinatorExtended[];\n\n/**\n * Standard classnames applied to each component.\n */\n// #region docs-standardclassnames\nexport const standardClassnames = {\n  queryBuilder: 'queryBuilder',\n  ruleGroup: 'ruleGroup',\n  header: 'ruleGroup-header',\n  body: 'ruleGroup-body',\n  combinators: 'ruleGroup-combinators',\n  addRule: 'ruleGroup-addRule',\n  addGroup: 'ruleGroup-addGroup',\n  cloneRule: 'rule-cloneRule',\n  cloneGroup: 'ruleGroup-cloneGroup',\n  removeGroup: 'ruleGroup-remove',\n  notToggle: 'ruleGroup-notToggle',\n  rule: 'rule',\n  fields: 'rule-fields',\n  operators: 'rule-operators',\n  value: 'rule-value',\n  removeRule: 'rule-remove',\n  betweenRules: 'betweenRules',\n  valid: 'queryBuilder-valid',\n  invalid: 'queryBuilder-invalid',\n  shiftActions: 'shiftActions',\n  dndDragging: 'dndDragging',\n  dndOver: 'dndOver',\n  dndCopy: 'dndCopy',\n  dragHandle: 'queryBuilder-dragHandle',\n  disabled: 'queryBuilder-disabled',\n  lockRule: 'rule-lock',\n  lockGroup: 'ruleGroup-lock',\n  valueSource: 'rule-valueSource',\n  valueListItem: 'rule-value-list-item',\n  branches: 'queryBuilder-branches',\n} as const;\n// #endregion\n\n/**\n * Default classnames for each component.\n */\nexport const defaultControlClassnames = {\n  queryBuilder: '',\n  ruleGroup: '',\n  header: '',\n  body: '',\n  combinators: '',\n  addRule: '',\n  addGroup: '',\n  cloneRule: '',\n  cloneGroup: '',\n  removeGroup: '',\n  notToggle: '',\n  rule: '',\n  fields: '',\n  operators: '',\n  value: '',\n  removeRule: '',\n  shiftActions: '',\n  dragHandle: '',\n  lockRule: '',\n  lockGroup: '',\n  valueSource: '',\n  actionElement: '',\n  valueSelector: '',\n} satisfies Classnames;\n\n/**\n * Default reason codes for a group being invalid.\n */\nexport const groupInvalidReasons = {\n  empty: 'empty',\n  invalidCombinator: 'invalid combinator',\n  invalidIndependentCombinators: 'invalid independent combinators',\n} as const;\n\n/**\n * Component identifiers for testing.\n */\nexport const TestID = {\n  rule: 'rule',\n  ruleGroup: 'rule-group',\n  inlineCombinator: 'inline-combinator',\n  addGroup: 'add-group',\n  removeGroup: 'remove-group',\n  cloneGroup: 'clone-group',\n  cloneRule: 'clone-rule',\n  addRule: 'add-rule',\n  removeRule: 'remove-rule',\n  combinators: 'combinators',\n  fields: 'fields',\n  operators: 'operators',\n  valueEditor: 'value-editor',\n  notToggle: 'not-toggle',\n  shiftActions: 'shift-actions',\n  dragHandle: 'drag-handle',\n  lockRule: 'lock-rule',\n  lockGroup: 'lock-group',\n  valueSourceSelector: 'value-source-selector',\n} as const;\n\nexport const LogType = {\n  parentPathDisabled: 'action aborted: parent path disabled',\n  pathDisabled: 'action aborted: path is disabled',\n  queryUpdate: 'query updated',\n  onAddRuleFalse: 'onAddRule callback returned false',\n  onAddGroupFalse: 'onAddGroup callback returned false',\n  onRemoveFalse: 'onRemove callback returned false',\n  add: 'rule or group added',\n  remove: 'rule or group removed',\n  update: 'rule or group updated',\n  move: 'rule or group moved',\n} as const;\n","import { numericRegex as numericQuantityRegex } from 'numeric-quantity';\n\n/**\n * Regex matching numeric strings. Passes for positive/negative integers, decimals,\n * and E notation, with optional surrounding whitespace.\n */\nexport const numericRegex = new RegExp(\n  numericQuantityRegex.source.replace(/^\\^/, '^\\\\s*').replace(/\\$$/, '\\\\s*$')\n);\n\n/**\n * Determines if a variable is a plain old JavaScript object, aka POJO.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isPojo = (obj: any): obj is Record<string, any> =>\n  obj === null || typeof obj !== 'object' ? false : Object.getPrototypeOf(obj) === Object.prototype;\n","import type { RuleGroupType, RuleGroupTypeAny, RuleGroupTypeIC } from '../types/index.noReact';\nimport { isPojo } from './misc';\n\n/**\n * Determines if an object is a {@link RuleGroupType} or {@link RuleGroupTypeIC}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isRuleGroup = (rg: any): rg is RuleGroupTypeAny =>\n  isPojo(rg) && 'rules' in rg && Array.isArray(rg.rules);\n\n/**\n * Determines if an object is a {@link RuleGroupType}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isRuleGroupType = (rg: any): rg is RuleGroupType =>\n  isRuleGroup(rg) && typeof rg.combinator === 'string';\n\n/**\n * Determines if an object is a {@link RuleGroupTypeIC}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isRuleGroupTypeIC = (rg: any): rg is RuleGroupTypeIC =>\n  isRuleGroup(rg) && typeof rg.combinator === 'undefined';\n","import type {\n  RuleGroupArray,\n  RuleGroupICArray,\n  RuleGroupType,\n  RuleGroupTypeIC,\n  RuleType,\n} from '../types/index.noReact';\nimport { isRuleGroup, isRuleGroupType, isRuleGroupTypeIC } from './isRuleGroup';\n\nconst processRuleOrStringOrRuleGroupIC = (r: string | RuleType | RuleGroupTypeIC) =>\n  isRuleGroup(r) ? generateRuleGroupICWithConsistentCombinators(r) : r;\n\nconst generateRuleGroupICWithConsistentCombinators = (rg: RuleGroupTypeIC): RuleGroupTypeIC => {\n  const returnArray: RuleGroupICArray = [];\n  const push = (r: string | RuleType | RuleGroupTypeIC) =>\n    returnArray.push(processRuleOrStringOrRuleGroupIC(r) as RuleType | RuleGroupTypeIC);\n  let startIndex = 0;\n  for (let i = 0; i < rg.rules.length; i += 2) {\n    if (rg.rules.length === 1) {\n      push(rg.rules[0]);\n    } else if (rg.rules[i + 1] === 'and') {\n      startIndex = i;\n      let j = 1;\n      while (rg.rules[startIndex + j] === 'and') {\n        i += 2;\n        j += 2;\n      }\n      returnArray.push({\n        // @ts-expect-error Too complicated to keep track of odd/even indexes in TS\n        rules: rg.rules.slice(startIndex, i + 1).map(processRuleOrStringOrRuleGroupIC),\n      });\n      i -= 2;\n    } else if (rg.rules[i + 1] === 'or') {\n      if (i === 0 || i === rg.rules.length - 3) {\n        if (i === 0 || rg.rules[i - 1] === 'or') {\n          push(rg.rules[i]);\n        }\n        push(rg.rules[i + 1]);\n        if (i === rg.rules.length - 3) {\n          push(rg.rules[i + 2]);\n        }\n      } else {\n        if (rg.rules[i - 1] === 'and') {\n          push(rg.rules[i + 1]);\n        } else {\n          push(rg.rules[i]);\n          push(rg.rules[i + 1]);\n        }\n      }\n    }\n  }\n  if (\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-expect-error TS still thinks returnArray has length 0\n    returnArray.length === 1 &&\n    typeof returnArray[0] === 'object' &&\n    isRuleGroup(returnArray[0])\n  ) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-expect-error TS still thinks returnArray has length 0\n    return { ...rg, ...returnArray[0] };\n  }\n  return { ...rg, rules: returnArray };\n};\n\n/**\n * Converts a {@link RuleGroupTypeIC} to {@link RuleGroupType}.\n *\n * This function is idempotent: {@link RuleGroupType} queries will be\n * returned as-is.\n */\nexport const convertFromIC = <RG extends RuleGroupType = RuleGroupType>(\n  rg: RuleGroupTypeIC\n): RG => {\n  if (isRuleGroupType(rg)) {\n    return rg;\n  }\n  const processedRG = generateRuleGroupICWithConsistentCombinators(rg);\n  const rulesAsMixedList = processedRG.rules.map(r =>\n    typeof r === 'string' || !isRuleGroup(r) ? r : convertFromIC(r)\n  );\n  const combinator = rulesAsMixedList.length < 2 ? 'and' : (rulesAsMixedList[1] as string);\n  const rules = rulesAsMixedList.filter(r => typeof r !== 'string') as RuleGroupArray;\n  return { ...processedRG, combinator, rules } as RG;\n};\n\n/**\n * Converts a {@link RuleGroupType} to {@link RuleGroupTypeIC}.\n *\n * This function is idempotent: {@link RuleGroupTypeIC} queries will be\n * returned as-is.\n */\nexport const convertToIC = <RGIC extends RuleGroupTypeIC = RuleGroupTypeIC>(\n  rg: RuleGroupType\n): RGIC => {\n  if (isRuleGroupTypeIC(rg)) {\n    return rg;\n  }\n  const { combinator, ...queryWithoutCombinator } = rg;\n  const rules: (RuleGroupTypeIC | RuleType | string)[] = [];\n  const { length } = rg.rules;\n  rg.rules.forEach((r, idx) => {\n    if (isRuleGroup(r)) {\n      rules.push(convertToIC(r));\n    } else {\n      rules.push(r);\n    }\n    if (combinator && idx < length - 1) {\n      rules.push(combinator);\n    }\n  });\n  return { ...queryWithoutCombinator, rules } as RGIC;\n};\n\n/**\n * Converts a {@link RuleGroupType} to {@link RuleGroupTypeIC}. For a more explicit\n * operation, use {@link convertToIC}.\n */\nfunction convertQuery(query: RuleGroupType): RuleGroupTypeIC;\n/**\n * Converts a {@link RuleGroupTypeIC} to {@link RuleGroupType}. For a more explicit\n * operation, use {@link convertFromIC}.\n */\nfunction convertQuery(query: RuleGroupTypeIC): RuleGroupType;\nfunction convertQuery(query: RuleGroupType | RuleGroupTypeIC): RuleGroupType | RuleGroupTypeIC {\n  return isRuleGroupTypeIC(query) ? convertFromIC(query) : convertToIC(query);\n}\n\nexport { convertQuery };\n","// All code in this file is adapted from:\n// npm: https://www.npmjs.com/package/ts-extras\n// src: https://github.com/sindresorhus/ts-extras\n\n/**\n * Original looked like this (not sure why template string is used):\n * ```\n * type ObjectKeys<T extends object> = `${Exclude<keyof T, symbol>}`;\n * ```\n */\ntype ObjectKeys<T extends object> = Exclude<keyof T, symbol>;\n\n/**\n * A strongly-typed version of `Object.keys()`.\n *\n * [Original source](https://github.com/sindresorhus/ts-extras/blob/44f57392c5f027268330771996c4fdf9260b22d6/source/object-keys.ts)\n */\nexport const objectKeys = Object.keys as <Type extends object>(\n  value: Type\n) => Array<ObjectKeys<Type>>;\n\n/**\n * A strongly-typed version of `Object.entries()`.\n *\n * [Original source](https://github.com/sindresorhus/ts-extras/blob/44f57392c5f027268330771996c4fdf9260b22d6/source/object-entries.ts)\n */\nexport const objectEntries = Object.entries as <Type extends Record<PropertyKey, unknown>>(\n  value: Type\n) => Array<[ObjectKeys<Type>, Type[ObjectKeys<Type>]]>;\n","import { produce } from 'immer';\nimport type {\n  BaseOption,\n  BaseOptionMap,\n  FlexibleOption,\n  FlexibleOptionList,\n  FullOptionList,\n  Option,\n  ToFullOption,\n  ValueOption,\n} from '../types';\nimport { isPojo } from './misc';\nimport { isFlexibleOptionGroupArray } from './optGroupUtils';\n\nconst isOptionWithName = (opt: BaseOption): opt is Option =>\n  isPojo(opt) && 'name' in opt && typeof opt.name === 'string';\nconst isOptionWithValue = (opt: BaseOption): opt is ValueOption =>\n  isPojo(opt) && 'value' in opt && typeof opt.value === 'string';\n\n/**\n * Converts an {@link Option} or {@link ValueOption} (i.e., {@link BaseOption})\n * into a {@link FullOption}. Full options are left unchanged.\n */\nfunction toFullOption<Opt extends BaseOption>(\n  opt: Opt,\n  baseProperties?: Record<string, unknown>\n): ToFullOption<Opt> {\n  const recipe: (o: Opt) => ToFullOption<Opt> = produce(draft => {\n    const idObj: { name?: string; value?: string } = {};\n    let needsUpdating = !!baseProperties;\n\n    if (isOptionWithName(draft) && !isOptionWithValue(draft)) {\n      idObj.value = draft.name;\n      needsUpdating = true;\n    } else if (!isOptionWithName(draft) && isOptionWithValue(draft)) {\n      idObj.name = draft.value;\n      needsUpdating = true;\n    }\n\n    if (needsUpdating) {\n      return Object.assign({}, baseProperties, draft, idObj);\n    }\n  });\n  return recipe(opt);\n}\n\n/**\n * Converts an {@link OptionList} or {@link FlexibleOptionList} into a {@link FullOptionList}.\n * Lists of full options are left unchanged.\n */\nfunction toFullOptionList<Opt extends BaseOption, OptList extends FlexibleOptionList<Opt>>(\n  optList: OptList,\n  baseProperties?: Record<string, unknown>\n): FullOptionList<Opt> {\n  if (!Array.isArray(optList)) {\n    return [] as unknown as FullOptionList<Opt>;\n  }\n\n  const recipe: (ol: FlexibleOptionList<Opt>) => FullOptionList<Opt> = produce(draft => {\n    if (isFlexibleOptionGroupArray(draft)) {\n      for (const optGroup of draft) {\n        optGroup.options.forEach(\n          (opt, idx) => (optGroup.options[idx] = toFullOption(opt, baseProperties))\n        );\n      }\n    } else {\n      (draft as Opt[]).forEach((opt, idx) => (draft[idx] = toFullOption(opt, baseProperties)));\n    }\n  });\n\n  return recipe(optList);\n}\n\n/**\n * Converts a {@link FlexibleOptionList} into a {@link FullOptionList}.\n * Lists of full options are left unchanged.\n */\nfunction toFullOptionMap<OptMap extends BaseOptionMap>(\n  optMap: OptMap,\n  baseProperties?: Record<string, unknown>\n): OptMap extends BaseOptionMap<infer V, infer K> ? Partial<Record<K, ToFullOption<V>>> : never {\n  type FullOptMapType =\n    OptMap extends BaseOptionMap<infer VT, infer KT>\n      ? Partial<Record<KT, ToFullOption<VT>>>\n      : never;\n\n  return Object.fromEntries(\n    (Object.entries(optMap) as [string, FlexibleOption][]).map(([k, v]) => [\n      k,\n      toFullOption(v, baseProperties),\n    ])\n  ) as FullOptMapType;\n}\n\nexport { toFullOption, toFullOptionList, toFullOptionMap };\n","import type { RequireAtLeastOne } from 'type-fest';\nimport type {\n  BaseOption,\n  FlexibleOptionGroup,\n  FlexibleOptionList,\n  OptionGroup,\n  ToFullOption,\n  WithUnknownIndex,\n} from '../types/index.noReact';\nimport { isFlexibleOptionGroupArray } from './optGroupUtils';\nimport { toFullOption } from './toFullOption';\n\n/**\n * @deprecated Renamed to {@link uniqByIdentifier}.\n */\nexport const uniqByName = <\n  T extends { name: string; value?: string } | { name?: string; value: string },\n>(\n  originalArray: T[]\n): T[] => uniqByIdentifier(originalArray);\n\n/**\n * Generates a new array of objects with duplicates removed based\n * on the identifying property (`value` or `name`)\n */\nexport const uniqByIdentifier = <\n  T extends RequireAtLeastOne<{ name: string; value: string }, 'name' | 'value'>,\n>(\n  originalArray: T[]\n): T[] => {\n  const names = new Set<string>();\n  const newArray: T[] = [];\n  originalArray.forEach(el => {\n    if (!names.has((el.value ?? el.name)!)) {\n      names.add((el.value ?? el.name)!);\n      newArray.push(el);\n    }\n  });\n  return originalArray.length === newArray.length ? originalArray : newArray;\n};\n\n/**\n * Generates a new {@link OptionGroup} array with duplicates\n * removed based on the identifying property (`value` or `name`).\n */\nexport const uniqOptGroups = <T extends BaseOption>(\n  originalArray: FlexibleOptionGroup<T>[]\n): OptionGroup<ToFullOption<T>>[] => {\n  type K = T extends BaseOption<infer KT> ? KT : never;\n  const labels = new Set<string>();\n  const names = new Set<K>();\n  const newArray: OptionGroup<ToFullOption<T>>[] = [];\n  originalArray.forEach(el => {\n    if (!labels.has(el.label)) {\n      labels.add(el.label);\n      const optionsForThisGroup: WithUnknownIndex<ToFullOption<T>>[] = [];\n      el.options.forEach(opt => {\n        if (!names.has((opt.value ?? opt.name) as K)) {\n          names.add((opt.value ?? opt.name) as K);\n          optionsForThisGroup.push(toFullOption(opt) as WithUnknownIndex<ToFullOption<T>>);\n        }\n      });\n      newArray.push({ ...el, options: optionsForThisGroup });\n    }\n  });\n  return newArray;\n};\n\n/**\n * Generates a new {@link Option} or {@link OptionGroup} array with duplicates\n * removed based on the identifier property (`value` or `name`).\n */\nexport const uniqOptList = <T extends BaseOption>(originalArray: FlexibleOptionList<T>) => {\n  if (isFlexibleOptionGroupArray(originalArray)) {\n    return uniqOptGroups(originalArray) as OptionGroup<ToFullOption<T>>[];\n  }\n  return uniqByIdentifier((originalArray as BaseOption[]).map(o => toFullOption(o)));\n};\n","import type {\n  BaseOption,\n  FlexibleOptionGroup,\n  FullOption,\n  FullOptionList,\n  GetOptionIdentifierType,\n  Option,\n  OptionGroup,\n  OptionList,\n} from '../types/index.noReact';\nimport { isPojo } from './misc';\nimport { uniqByIdentifier } from './uniq';\n\n/**\n * Determines if an {@link OptionList} is an {@link OptionGroup} array.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isOptionGroupArray = (arr: any): arr is OptionGroup<BaseOption>[] =>\n  Array.isArray(arr) && arr.length > 0 && isPojo(arr[0]) && 'options' in arr[0];\n\n/**\n * Determines if a {@link FlexibleOptionList} is a {@link FlexibleOptionGroup} array.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isFlexibleOptionGroupArray = (arr: any): arr is FlexibleOptionGroup[] =>\n  Array.isArray(arr) &&\n  arr.length > 0 &&\n  isPojo(arr[0]) &&\n  'options' in arr[0] &&\n  isPojo(arr[0].options[0]) &&\n  ('name' in arr[0].options[0] || 'value' in arr[0].options[0]);\n\n/**\n * Determines if a {@link FlexibleOptionList} is a {@link OptionGroup} array of\n * {@link FullOption}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isFullOptionGroupArray = (arr: any): arr is OptionGroup<FullOption>[] =>\n  Array.isArray(arr) &&\n  arr.length > 0 &&\n  isPojo(arr[0]) &&\n  'options' in arr[0] &&\n  isPojo(arr[0].options[0]) &&\n  'name' in arr[0].options[0] &&\n  isPojo(arr[0].options[0]) &&\n  'value' in arr[0].options[0];\n\n/**\n * Gets the option from an {@link OptionList} with the given `name`. Handles\n * {@link Option} arrays as well as {@link OptionGroup} arrays.\n */\nexport const getOption = <OptType extends Option = Option>(\n  arr: OptionList<OptType>,\n  name: string\n): OptType | undefined =>\n  (isOptionGroupArray(arr) ? arr.flatMap(og => og.options) : arr).find(op => op.name === name);\n\n/**\n * Gets the first option from an {@link OptionList}.\n */\nexport const getFirstOption = <Opt extends BaseOption>(arr?: FlexibleOptionGroup<Opt>[] | Opt[]) =>\n  (!Array.isArray(arr) || arr.length === 0\n    ? null\n    : isFlexibleOptionGroupArray(arr)\n      ? arr[0].options[0].value ?? arr[0].options[0].name\n      : arr[0].value ?? arr[0].name) as GetOptionIdentifierType<Opt>;\n\n/**\n * Flattens {@link FlexibleOptionGroup} arrays into {@link BaseOption} arrays.\n * If the array is already flat, it is returned as is.\n */\nexport const toFlatOptionArray = <T extends FullOption, OL extends FullOptionList<T>>(arr: OL) =>\n  uniqByIdentifier(isOptionGroupArray(arr) ? arr.flatMap(og => og.options) : arr) as T[];\n","import type { FullField, OptionList } from '../types/index.noReact';\nimport { isFlexibleOptionGroupArray } from './optGroupUtils';\nimport { toFullOption } from './toFullOption';\n\nconst filterByComparator = (field: FullField, operator: string, fieldToCompare: FullField) => {\n  const fullField = toFullOption(field);\n  const fullFieldToCompare = toFullOption(fieldToCompare);\n  if (fullField.value === fullFieldToCompare.value) {\n    return false;\n  }\n  if (typeof fullField.comparator === 'string') {\n    return fullField[fullField.comparator] === fullFieldToCompare[fullField.comparator];\n  }\n  return fullField.comparator?.(fullFieldToCompare, operator) ?? /* istanbul ignore next */ false;\n};\n\n/**\n * For a given {@link FullField}, returns the `fields` list filtered for\n * other fields that match by `comparator`. Only fields *other than the\n * one in question* will ever be included, even if `comparator` is `null`\n * or `undefined`. If `comparator` is a string, fields with the same value\n * for that property will be included. If `comparator` is a function, each\n * field will be passed to the function along with the `operator` and fields\n * for which the function returns `true` will be included.\n */\nexport const filterFieldsByComparator = (\n  /** The field in question. */\n  field: FullField,\n  /** The full {@link FullField} list to be filtered. */\n  fields: OptionList<FullField>,\n  operator: string\n) => {\n  if (!field.comparator) {\n    const filterOutSameField = (f: FullField) =>\n      (f.value ?? /* istanbul ignore next */ f.name) !==\n      (field.value ?? /* istanbul ignore next */ field.name);\n    if (isFlexibleOptionGroupArray(fields)) {\n      return fields.map(og => ({\n        ...og,\n        options: og.options.filter(filterOutSameField),\n      }));\n    }\n    return fields.filter(filterOutSameField);\n  }\n\n  if (isFlexibleOptionGroupArray(fields)) {\n    return fields\n      .map(og => ({\n        ...og,\n        options: og.options.filter(f => filterByComparator(field, operator, f)),\n      }))\n      .filter(og => og.options.length > 0);\n  }\n\n  return fields.filter(f => filterByComparator(field, operator, f));\n};\n","import type { FullField, GetOptionIdentifierType, ValueSources } from '../types/index.noReact';\nimport { toFullOption } from './toFullOption';\n\nconst defaultValueSourcesArray: ValueSources = ['value'];\n\nconst dummyFD = {\n  name: 'name',\n  value: 'name',\n  valueSources: null,\n  label: 'label',\n};\n\n/**\n * Utility function to get the value sources array for the given\n * field and operator. If the field definition does not define a\n * `valueSources` property, the `getValueSources` prop is used.\n * Returns `[\"value\"]` by default.\n */\nexport const getValueSourcesUtil = <F extends FullField, O extends string>(\n  fieldData: F,\n  operator: string,\n  getValueSources?: (\n    field: GetOptionIdentifierType<F>,\n    operator: O,\n    misc: { fieldData: F }\n  ) => ValueSources\n): ValueSources => {\n  // TypeScript doesn't allow it directly, but in practice\n  // `fieldData` can end up being undefined or null. The nullish\n  // coalescing assignment below avoids errors like\n  // \"TypeError: Cannot read properties of undefined (reading 'name')\"\n  const fd = fieldData ? toFullOption(fieldData) : /* istanbul ignore else */ dummyFD;\n\n  if (fd.valueSources) {\n    if (typeof fd.valueSources === 'function') {\n      return fd.valueSources(operator as O);\n    }\n    return fd.valueSources;\n  }\n  if (getValueSources) {\n    const vals = getValueSources(fd.value as GetOptionIdentifierType<F>, operator as O, {\n      fieldData: toFullOption(fd) as F,\n    });\n    /* istanbul ignore else */\n    if (vals) return vals;\n  }\n\n  return defaultValueSourcesArray;\n};\n","import type {\n  DefaultOperatorName,\n  FullField,\n  OptionList,\n  ValueSources,\n} from '../types/index.noReact';\nimport { filterFieldsByComparator } from './filterFieldsByComparator';\nimport { getValueSourcesUtil } from './getValueSourcesUtil';\nimport { toFlatOptionArray } from './optGroupUtils';\nimport { toFullOption } from './toFullOption';\n\nexport const getFieldsArray = (fields?: OptionList<FullField> | Record<string, FullField>) => {\n  const fieldsArray = !fields\n    ? []\n    : Array.isArray(fields)\n      ? fields\n      : Object.keys(fields)\n          .map(fld => ({ ...fields[fld], name: fld }))\n          .sort((a, b) => a.label.localeCompare(b.label));\n  return toFlatOptionArray(fieldsArray);\n};\n\nexport function fieldIsValidUtil(params: {\n  fieldsFlat: FullField[];\n  getValueSources?: (field: string, operator: string) => ValueSources;\n  fieldName: string;\n  operator: DefaultOperatorName;\n  subordinateFieldName?: string;\n}) {\n  const { fieldsFlat, fieldName, operator, subordinateFieldName, getValueSources } = params;\n\n  // If fields option was an empty array or undefined, then all identifiers\n  // are considered valid.\n  if (fieldsFlat.length === 0) return true;\n\n  let valid = false;\n\n  const primaryField = toFullOption(fieldsFlat.find(ff => ff.name === fieldName)!);\n  if (primaryField) {\n    if (\n      !subordinateFieldName &&\n      operator !== 'notNull' &&\n      operator !== 'null' &&\n      !getValueSourcesUtil(primaryField, operator, getValueSources).some(vs => vs === 'value')\n    ) {\n      valid = false;\n    } else {\n      valid = true;\n    }\n\n    if (valid && !!subordinateFieldName) {\n      if (\n        getValueSourcesUtil(primaryField, operator, getValueSources).some(vs => vs === 'field') &&\n        fieldName !== subordinateFieldName\n      ) {\n        const validSubordinateFields = filterFieldsByComparator(\n          primaryField,\n          fieldsFlat,\n          operator\n        ) as FullField[];\n        if (!validSubordinateFields.find(vsf => vsf.name === subordinateFieldName)) {\n          valid = false;\n        }\n      } else {\n        valid = false;\n      }\n    }\n  }\n\n  return valid;\n}\n","import type { DefaultOperatorName } from '../../types';\nimport type { MongoDbSupportedOperators } from './types';\n\nexport const getRegExStr = (re: string | RegExp) => (typeof re === 'string' ? re : re.source);\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isPrimitive = (v: any): v is string | number | boolean =>\n  typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean';\n\nexport const mongoDbToRqbOperatorMap = {\n  $eq: '=',\n  $ne: '!=',\n  $gt: '>',\n  $gte: '>=',\n  $lt: '<',\n  $lte: '<=',\n} satisfies { [o in MongoDbSupportedOperators]?: DefaultOperatorName };\n","import { defaultOperatorNegationMap } from '../../defaults';\nimport type {\n  DefaultOperatorName,\n  DefaultRuleGroupType,\n  DefaultRuleGroupTypeAny,\n  DefaultRuleGroupTypeIC,\n  DefaultRuleType,\n  ParseMongoDbOptions,\n} from '../../types/index.noReact';\nimport { convertToIC } from '../convertQuery';\nimport { isRuleGroupType } from '../isRuleGroup';\nimport { isPojo } from '../misc';\nimport { objectKeys } from '../objectUtils';\nimport { fieldIsValidUtil, getFieldsArray } from '../parserUtils';\nimport type { MongoDbSupportedOperators } from './types';\nimport { getRegExStr, isPrimitive, mongoDbToRqbOperatorMap } from './utils';\n\nconst emptyRuleGroup: DefaultRuleGroupType = { combinator: 'and', rules: [] };\n\n/**\n * Converts a MongoDB query object or parseable string into a query suitable\n * for the {@link QueryBuilder} component's `query` or `defaultQuery` props\n * ({@link DefaultRuleGroupType}).\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction parseMongoDB(mongoDbRules: string | Record<string, any>): DefaultRuleGroupType;\n/**\n * Converts a MongoDB query object or parseable string into a query suitable\n * for the {@link QueryBuilder} component's `query` or `defaultQuery` props\n * ({@link DefaultRuleGroupType}).\n */\nfunction parseMongoDB(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mongoDbRules: string | Record<string, any>,\n  options: Omit<ParseMongoDbOptions, 'independentCombinators'> & {\n    independentCombinators?: false;\n  }\n): DefaultRuleGroupType;\n/**\n * Converts a MongoDB query object or parseable string into a query suitable\n * for the {@link QueryBuilder} component's `query` or `defaultQuery` props\n * ({@link DefaultRuleGroupTypeIC}).\n */\nfunction parseMongoDB(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mongoDbRules: string | Record<string, any>,\n  options: Omit<ParseMongoDbOptions, 'independentCombinators'> & {\n    independentCombinators: true;\n  }\n): DefaultRuleGroupTypeIC;\nfunction parseMongoDB(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mongoDbRules: string | Record<string, any>,\n  options: ParseMongoDbOptions = {}\n): DefaultRuleGroupTypeAny {\n  const listsAsArrays = !!options.listsAsArrays;\n  const fieldsFlat = getFieldsArray(options.fields);\n  const getValueSources = options.getValueSources;\n  const additionalOperators = options.additionalOperators ?? {};\n  const preventOperatorNegation = !!options.preventOperatorNegation;\n  const { additionalOperators: _ao, ...otherOptions } = options;\n\n  const fieldIsValid = (\n    fieldName: string,\n    operator: DefaultOperatorName,\n    subordinateFieldName?: string\n  ) =>\n    fieldIsValidUtil({\n      fieldName,\n      fieldsFlat,\n      operator,\n      subordinateFieldName,\n      getValueSources,\n    });\n\n  function processMongoDbQueryBooleanOperator(\n    field: string,\n    mdbOperator: MongoDbSupportedOperators,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    keyValue: any\n  ): DefaultRuleType | false {\n    let operator: DefaultOperatorName = '=';\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let value: any = '';\n\n    // istanbul ignore else\n    if (\n      mdbOperator === '$eq' ||\n      mdbOperator === '$ne' ||\n      mdbOperator === '$gt' ||\n      mdbOperator === '$gte' ||\n      mdbOperator === '$lt' ||\n      mdbOperator === '$lte'\n    ) {\n      if (mdbOperator === '$ne' && keyValue === null) {\n        if (fieldIsValid(field, 'notNull')) {\n          return { field, operator: 'notNull', value: null };\n        }\n      } else {\n        operator = mongoDbToRqbOperatorMap[mdbOperator]!;\n        if (fieldIsValid(field, operator)) {\n          return { field, operator, value: keyValue };\n        }\n      }\n    } else if (mdbOperator === '$regex' && /^[^^].*[^$]$/.test(getRegExStr(keyValue))) {\n      if (fieldIsValid(field, 'contains')) {\n        return {\n          field,\n          operator: 'contains',\n          value: getRegExStr(keyValue),\n        };\n      }\n    } else if (mdbOperator === '$regex' && /^\\^.*[^$]/.test(getRegExStr(keyValue))) {\n      if (fieldIsValid(field, 'beginsWith')) {\n        return {\n          field,\n          operator: 'beginsWith',\n          value: getRegExStr(keyValue).replace(/^\\^/, ''),\n        };\n      }\n    } else if (mdbOperator === '$regex' && /[^^].*\\$/.test(getRegExStr(keyValue))) {\n      if (fieldIsValid(field, 'endsWith')) {\n        return {\n          field,\n          operator: 'endsWith',\n          value: getRegExStr(keyValue).replace(/\\$$/, ''),\n        };\n      }\n    } else if (mdbOperator === '$in' && Array.isArray(keyValue)) {\n      if (fieldIsValid(field, 'in')) {\n        if (listsAsArrays) {\n          value = keyValue;\n        } else {\n          value = keyValue.map(v => `${v}`).join(',');\n        }\n        return { field, operator: 'in', value };\n      }\n    } else if (mdbOperator === '$nin' && Array.isArray(keyValue)) {\n      if (fieldIsValid(field, 'notIn')) {\n        if (listsAsArrays) {\n          value = keyValue;\n        } else {\n          value = keyValue.map(v => `${v}`).join(',');\n        }\n        return { field, operator: 'notIn', value };\n      }\n    }\n\n    return false;\n  }\n\n  function processMongoDbQueryObjectKey(\n    key: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    keyValue: any\n  ): DefaultRuleType | DefaultRuleGroupType | false {\n    let field = '';\n\n    // istanbul ignore else\n    if (key === '$and') {\n      if (!Array.isArray(keyValue) || keyValue.length === 0 || !keyValue.every(isPojo)) {\n        return false;\n      }\n\n      // Check if this should result in a \"between\" clause\n      if (keyValue.length === 2 && keyValue.every(kv => objectKeys(kv).length === 1)) {\n        const [rule1, rule2] = keyValue;\n        const [ruleKey1, ruleKey2] = keyValue.map(kv => objectKeys(kv)[0]);\n        if (\n          ruleKey1 === ruleKey2 &&\n          isPojo(rule1[ruleKey1]) &&\n          objectKeys(rule1[ruleKey1]).length === 1 &&\n          isPojo(rule2[ruleKey2]) &&\n          objectKeys(rule2[ruleKey2]).length === 1 &&\n          (('$gte' in rule1[ruleKey1] &&\n            '$lte' in rule2[ruleKey2] &&\n            rule2[ruleKey2].$lte >= rule1[ruleKey1].$gte) ||\n            ('$lte' in rule1[ruleKey1] &&\n              '$gte' in rule2[ruleKey2] &&\n              rule1[ruleKey1].$lte >= rule2[ruleKey2].$gte))\n        ) {\n          const [val1, val2] = [\n            rule1[ruleKey1].$gte ?? rule1[ruleKey1].$lte,\n            rule2[ruleKey2].$lte ?? rule2[ruleKey2].$gte,\n          ];\n          let value = listsAsArrays ? [val1, val2] : `${val1},${val2}`;\n          if (val1 > val2) {\n            value = listsAsArrays ? [val2, val1] : `${val2},${val1}`;\n          }\n          return { field: ruleKey1, operator: 'between', value };\n        }\n      }\n\n      const rules = keyValue.map(l => processMongoDbQueryObject(l)).filter(Boolean) as (\n        | DefaultRuleType\n        | DefaultRuleGroupType\n      )[];\n\n      return rules.length > 0 ? { combinator: 'and', rules } : false;\n    } else if (key === '$or') {\n      if (!Array.isArray(keyValue) || keyValue.length === 0 || !keyValue.every(isPojo)) {\n        return false;\n      }\n\n      // Check if this should result in \"notBetween\"\n      if (keyValue.length === 2 && keyValue.every(kv => objectKeys(kv).length === 1)) {\n        const [rule1, rule2] = keyValue;\n        const [ruleKey1, ruleKey2] = keyValue.map(kv => objectKeys(kv)[0]);\n        if (\n          ruleKey1 === ruleKey2 &&\n          isPojo(rule1[ruleKey1]) &&\n          objectKeys(rule1[ruleKey1]).length === 1 &&\n          isPojo(rule2[ruleKey2]) &&\n          objectKeys(rule2[ruleKey2]).length === 1 &&\n          (('$gt' in rule1[ruleKey1] &&\n            '$lt' in rule2[ruleKey2] &&\n            rule1[ruleKey1].$gt >= rule2[ruleKey2].$lt) ||\n            ('$lt' in rule1[ruleKey1] &&\n              '$gt' in rule2[ruleKey2] &&\n              rule2[ruleKey2].$gt >= rule1[ruleKey1].$lt))\n        ) {\n          const [val1, val2] = [\n            rule1[ruleKey1].$gt ?? rule1[ruleKey1].$lt,\n            rule2[ruleKey2].$lt ?? rule2[ruleKey2].$gt,\n          ];\n          let value = listsAsArrays ? [val1, val2] : `${val1},${val2}`;\n          if (val1 > val2) {\n            value = listsAsArrays ? [val2, val1] : `${val2},${val1}`;\n          }\n          return { field: ruleKey1, operator: 'notBetween', value };\n        }\n      }\n\n      const rules = keyValue.map(l => processMongoDbQueryObject(l)).filter(Boolean) as (\n        | DefaultRuleType\n        | DefaultRuleGroupType\n      )[];\n\n      return rules.length > 0 ? { combinator: 'or', rules } : false;\n    } else if (key === '$not' && isPojo(keyValue)) {\n      const ruleOrGroup = processMongoDbQueryObject(keyValue);\n      if (ruleOrGroup) {\n        if (isRuleGroupType(ruleOrGroup)) {\n          return ruleOrGroup.not\n            ? { combinator: 'and', rules: [ruleOrGroup], not: true }\n            : { ...ruleOrGroup, not: true };\n        }\n        return preventOperatorNegation\n          ? { combinator: 'and', rules: [ruleOrGroup], not: true }\n          : { ...ruleOrGroup, operator: defaultOperatorNegationMap[ruleOrGroup.operator] };\n      }\n      return false;\n    } else if (key === '$expr') {\n      const op = objectKeys(keyValue)[0] as MongoDbSupportedOperators;\n      if (/^\\$(eq|gte?|lte?|n?in)$/.test(op)) {\n        if (\n          Array.isArray(keyValue[op]) &&\n          keyValue[op].length === 2 &&\n          typeof keyValue[op][0] === 'string' &&\n          /^\\$/.test(keyValue[op][0])\n        ) {\n          field = keyValue[op][0].replace(/^\\$/, '');\n          const val = keyValue[op][1];\n          if (\n            (typeof val === 'string' && /^\\$/.test(val)) ||\n            (Array.isArray(val) &&\n              val.every(v => typeof v === 'string') &&\n              val.every(v => /^\\$/.test(v)))\n          ) {\n            const valForProcessing = Array.isArray(val)\n              ? val.map(v => v.replace(/^\\$/, ''))\n              : val.replace(/^\\$/, '');\n            const tempRule = processMongoDbQueryBooleanOperator(field, op, valForProcessing);\n            if (tempRule) {\n              if (\n                typeof tempRule.value === 'string' &&\n                !fieldIsValid(field, tempRule.operator, tempRule.value)\n              ) {\n                return false;\n              }\n              return { ...tempRule, valueSource: 'field' };\n            }\n          }\n          return processMongoDbQueryBooleanOperator(field, op, keyValue[op][1]);\n        }\n      }\n    } else if (/^[^$]/.test(key)) {\n      field = key;\n\n      if (isPrimitive(keyValue)) {\n        if (fieldIsValid(field, '=')) {\n          return { field, operator: '=', value: keyValue };\n        }\n      } else if (keyValue === null) {\n        if (fieldIsValid(field, 'null')) {\n          return { field, operator: 'null', value: keyValue };\n        }\n      } else if (isPojo(keyValue)) {\n        let betweenRule: DefaultRuleType | false = false;\n        let notRule: DefaultRuleType | DefaultRuleGroupType | false = false;\n        const additionalOpKeys = objectKeys(additionalOperators).map(o => o.replace(/^\\$/, ''));\n        const allOps = ['eq', 'ne', 'gte?', 'lte?', 'n?in', 'regex', 'not', ...additionalOpKeys];\n        const acceptedOpsRegExp = new RegExp(`^\\\\$(${allOps.join('|')})$`);\n\n        const operators = objectKeys<Record<MongoDbSupportedOperators, unknown>>(keyValue)\n          .filter(o => acceptedOpsRegExp.test(o))\n          .sort();\n\n        if (operators.length === 0) {\n          return false;\n        }\n\n        if ('$not' in keyValue && isPojo(keyValue.$not)) {\n          const invertedNotRule = processMongoDbQueryObject({ [field]: keyValue.$not });\n          if (invertedNotRule) {\n            if (isRuleGroupType(invertedNotRule)) {\n              notRule = { ...invertedNotRule, not: true };\n            } else {\n              notRule = preventOperatorNegation\n                ? { combinator: 'and', rules: [invertedNotRule], not: true }\n                : {\n                    ...invertedNotRule,\n                    operator: defaultOperatorNegationMap[invertedNotRule.operator],\n                  };\n            }\n          }\n        }\n\n        if ('$gte' in keyValue && '$lte' in keyValue) {\n          // This is (at least) a compact \"between\" clause\n          betweenRule = {\n            field,\n            operator: 'between',\n            value: listsAsArrays\n              ? [keyValue.$gte, keyValue.$lte]\n              : `${keyValue.$gte},${keyValue.$lte}`,\n          };\n        }\n\n        const rules = operators\n          // filter out $not\n          .filter(op => !(notRule && op === '$not'))\n          // filter out $gte and $lte if they were both present\n          .filter(op => !(betweenRule && (op === '$gte' || op === '$lte')))\n          .map(op =>\n            op in additionalOperators && typeof additionalOperators[op] === 'function'\n              ? additionalOperators[op](field, op, keyValue[op], otherOptions)\n              : processMongoDbQueryBooleanOperator(field, op, keyValue[op])\n          )\n          .filter(Boolean) as (DefaultRuleGroupType | DefaultRuleType)[];\n\n        if (notRule) {\n          rules.unshift(notRule);\n        }\n\n        if (betweenRule) {\n          rules.unshift(betweenRule);\n        }\n\n        if (rules.length === 0) {\n          return false;\n        }\n        if (rules.length === 1) {\n          return rules[0];\n        }\n        return { combinator: 'and', rules };\n      }\n    }\n\n    return false;\n  }\n\n  function processMongoDbQueryObject(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    mongoDbQueryObject: Record<string, any>\n  ): DefaultRuleGroupType | DefaultRuleType | false {\n    const rules = objectKeys(mongoDbQueryObject)\n      .map(k => processMongoDbQueryObjectKey(k, mongoDbQueryObject[k]))\n      .filter(Boolean) as DefaultRuleGroupType[];\n    return rules.length === 1 ? rules[0] : rules.length > 1 ? { combinator: 'and', rules } : false;\n  }\n\n  let mongoDbPOJO = mongoDbRules;\n  if (typeof mongoDbRules === 'string') {\n    try {\n      mongoDbPOJO = JSON.parse(mongoDbRules);\n    } catch (err) {\n      return emptyRuleGroup;\n    }\n  }\n\n  // Bail if the mongoDbPOJO is not actually a POJO\n  if (!isPojo(mongoDbPOJO)) {\n    return emptyRuleGroup;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const result = processMongoDbQueryObject(mongoDbPOJO as Record<string, any>);\n  const finalQuery: DefaultRuleGroupType = result\n    ? isRuleGroupType(result)\n      ? result\n      : { combinator: 'and', rules: [result] }\n    : emptyRuleGroup;\n  return options.independentCombinators\n    ? convertToIC<DefaultRuleGroupTypeIC>(finalQuery)\n    : finalQuery;\n}\n\nexport { parseMongoDB };\n"],"mappings":"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","names":["numericQuantityRegex"]}