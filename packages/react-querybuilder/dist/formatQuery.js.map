{"version":3,"sources":["../src/utils/formatQuery/index.ts","../src/defaults.ts","../src/utils/arrayUtils.ts","../src/utils/parseNumber.ts","../src/utils/misc.ts","../src/utils/isRuleGroup.ts","../src/utils/formatQuery/utils.ts","../src/utils/formatQuery/defaultRuleProcessorCEL.ts","../src/utils/formatQuery/defaultRuleProcessorMongoDB.ts","../src/utils/formatQuery/defaultRuleProcessorSpEL.ts","../src/utils/formatQuery/defaultValueProcessorByRule.ts","../src/utils/formatQuery/defaultRuleProcessorElasticSearch.ts","../src/utils/formatQuery/defaultRuleProcessorJSONata.ts","../src/utils/formatQuery/defaultRuleProcessorJsonLogic.ts","../src/utils/formatQuery/defaultRuleProcessorParameterized.ts","../src/utils/formatQuery/defaultRuleProcessorSQL.ts","../src/utils/convertQuery.ts","../src/utils/isRuleOrGroupValid.ts","../src/utils/toFullOption.ts","../src/utils/uniq.ts","../src/utils/optGroupUtils.ts","../src/utils/formatQuery/formatQuery.ts"],"sourcesContent":["import type { ValueProcessorLegacy } from '../../types/index.noReact';\nimport { defaultRuleProcessorCEL } from './defaultRuleProcessorCEL';\nimport { defaultRuleProcessorMongoDB } from './defaultRuleProcessorMongoDB';\nimport { defaultRuleProcessorSpEL } from './defaultRuleProcessorSpEL';\nimport { defaultValueProcessorByRule } from './defaultValueProcessorByRule';\n\nconst internalValueProcessors = {\n  default: defaultValueProcessorByRule,\n  mongodb: defaultRuleProcessorMongoDB,\n  cel: defaultRuleProcessorCEL,\n  spel: defaultRuleProcessorSpEL,\n} as const;\n\nconst generateValueProcessor =\n  (format: 'default' | 'mongodb' | 'cel' | 'spel'): ValueProcessorLegacy =>\n  (field, operator, value, valueSource) =>\n    internalValueProcessors[format](\n      { field, operator, value, valueSource },\n      { parseNumbers: false }\n    );\n// TODO: Deprecate defaultValueProcessor.\n/**\n * Default value processor used by {@link formatQuery} for \"sql\" format.\n */\nexport const defaultValueProcessor = generateValueProcessor('default');\n/**\n * @deprecated Prefer {@link defaultRuleProcessorMongoDB}.\n */\nexport const defaultMongoDBValueProcessor = generateValueProcessor('mongodb');\n/**\n * @deprecated Prefer {@link defaultRuleProcessorCEL}.\n */\nexport const defaultCELValueProcessor = generateValueProcessor('cel');\n/**\n * @deprecated Prefer {@link defaultRuleProcessorSpEL}.\n */\nexport const defaultSpELValueProcessor = generateValueProcessor('spel');\n\nexport { defaultRuleProcessorElasticSearch } from './defaultRuleProcessorElasticSearch';\nexport { defaultRuleProcessorJSONata } from './defaultRuleProcessorJSONata';\nexport { defaultRuleProcessorJsonLogic } from './defaultRuleProcessorJsonLogic';\nexport { defaultRuleProcessorParameterized } from './defaultRuleProcessorParameterized';\nexport { defaultRuleProcessorSQL } from './defaultRuleProcessorSQL';\nexport * from './formatQuery';\nexport { jsonLogicAdditionalOperators } from './utils';\nexport {\n  defaultRuleProcessorCEL,\n  defaultRuleProcessorMongoDB,\n  defaultRuleProcessorSpEL,\n  defaultValueProcessorByRule,\n};\n/**\n * @deprecated Renamed to {@link defaultRuleProcessorCEL}.\n */\nexport const defaultValueProcessorCELByRule = defaultRuleProcessorCEL;\n/**\n * @deprecated Renamed to {@link defaultRuleProcessorMongoDB}.\n */\nexport const defaultValueProcessorMongoDBByRule = defaultRuleProcessorMongoDB;\n/**\n * @deprecated Renamed to {@link defaultRuleProcessorSpEL}.\n */\nexport const defaultValueProcessorSpELByRule = defaultRuleProcessorSpEL;\n","import type {\n  Classnames,\n  DefaultCombinator,\n  DefaultCombinatorExtended,\n  DefaultOperator,\n  DefaultOperatorName,\n  TranslationsFull,\n} from './types/index.noReact';\n\n// DO NOT ALTER OR REMOVE REGION NAMES. Some of them are used\n// to generate code snippets in the documentation.\n\nconst placeholderName = '~';\nconst placeholderLabel = '------';\n/**\n * Default `name` for placeholder option in the `fields` array.\n */\nexport const defaultPlaceholderFieldName = placeholderName;\n/**\n * Default `label` for placeholder option in the `fields` array.\n */\nexport const defaultPlaceholderFieldLabel = placeholderLabel;\n/**\n * Default `label` for placeholder option group in the `fields` array.\n */\nexport const defaultPlaceholderFieldGroupLabel = placeholderLabel;\n/**\n * Default `name` for placeholder option in the `operators` array.\n */\nexport const defaultPlaceholderOperatorName = placeholderName;\n/**\n * Default `label` for placeholder option in the `operators` array.\n */\nexport const defaultPlaceholderOperatorLabel = placeholderLabel;\n/**\n * Default `label` for placeholder option group in the `operators` array.\n */\nexport const defaultPlaceholderOperatorGroupLabel = placeholderLabel;\n\n/**\n * Default character used to `.join` and `.split` arrays.\n */\nexport const defaultJoinChar = ',';\n\n/**\n * Default configuration of translatable strings.\n */\n// #region docs-translations\nexport const defaultTranslations = {\n  fields: {\n    title: 'Fields',\n    placeholderName: defaultPlaceholderFieldName,\n    placeholderLabel: defaultPlaceholderFieldLabel,\n    placeholderGroupLabel: defaultPlaceholderFieldGroupLabel,\n  } as const,\n  operators: {\n    title: 'Operators',\n    placeholderName: defaultPlaceholderOperatorName,\n    placeholderLabel: defaultPlaceholderOperatorLabel,\n    placeholderGroupLabel: defaultPlaceholderOperatorGroupLabel,\n  } as const,\n  value: {\n    title: 'Value',\n  } as const,\n  removeRule: {\n    label: '‚®Ø',\n    title: 'Remove rule',\n  } as const,\n  removeGroup: {\n    label: '‚®Ø',\n    title: 'Remove group',\n  } as const,\n  addRule: {\n    label: '+ Rule',\n    title: 'Add rule',\n  } as const,\n  addGroup: {\n    label: '+ Group',\n    title: 'Add group',\n  } as const,\n  combinators: {\n    title: 'Combinators',\n  } as const,\n  notToggle: {\n    label: 'Not',\n    title: 'Invert this group',\n  } as const,\n  cloneRule: {\n    label: '‚ßâ',\n    title: 'Clone rule',\n  } as const,\n  cloneRuleGroup: {\n    label: '‚ßâ',\n    title: 'Clone group',\n  } as const,\n  shiftActionUp: {\n    label: 'ÀÑ',\n    title: 'Shift up',\n  } as const,\n  shiftActionDown: {\n    label: 'ÀÖ',\n    title: 'Shift down',\n  } as const,\n  dragHandle: {\n    label: '‚Åû‚Åû',\n    title: 'Drag handle',\n  } as const,\n  lockRule: {\n    label: 'üîì',\n    title: 'Lock rule',\n  } as const,\n  lockGroup: {\n    label: 'üîì',\n    title: 'Lock group',\n  } as const,\n  lockRuleDisabled: {\n    label: 'üîí',\n    title: 'Unlock rule',\n  } as const,\n  lockGroupDisabled: {\n    label: 'üîí',\n    title: 'Unlock group',\n  } as const,\n  valueSourceSelector: {\n    title: 'Value source',\n  } as const,\n} satisfies TranslationsFull;\n// #endregion\n\n/**\n * Default operator list.\n */\n// #region docs-operators\nexport const defaultOperators = [\n  { name: '=', value: '=', label: '=' } as const,\n  { name: '!=', value: '!=', label: '!=' } as const,\n  { name: '<', value: '<', label: '<' } as const,\n  { name: '>', value: '>', label: '>' } as const,\n  { name: '<=', value: '<=', label: '<=' } as const,\n  { name: '>=', value: '>=', label: '>=' } as const,\n  { name: 'contains', value: 'contains', label: 'contains' } as const,\n  { name: 'beginsWith', value: 'beginsWith', label: 'begins with' } as const,\n  { name: 'endsWith', value: 'endsWith', label: 'ends with' } as const,\n  { name: 'doesNotContain', value: 'doesNotContain', label: 'does not contain' } as const,\n  { name: 'doesNotBeginWith', value: 'doesNotBeginWith', label: 'does not begin with' } as const,\n  { name: 'doesNotEndWith', value: 'doesNotEndWith', label: 'does not end with' } as const,\n  { name: 'null', value: 'null', label: 'is null' } as const,\n  { name: 'notNull', value: 'notNull', label: 'is not null' } as const,\n  { name: 'in', value: 'in', label: 'in' } as const,\n  { name: 'notIn', value: 'notIn', label: 'not in' } as const,\n  { name: 'between', value: 'between', label: 'between' } as const,\n  { name: 'notBetween', value: 'notBetween', label: 'not between' } as const,\n] satisfies DefaultOperator[];\n// #endregion\n\n/**\n * Map of default operators to their respective opposite/negating operators.\n */\nexport const defaultOperatorNegationMap = {\n  '=': '!=',\n  '!=': '=',\n  '<': '>=',\n  '<=': '>',\n  '>': '<=',\n  '>=': '<',\n  beginsWith: 'doesNotBeginWith',\n  doesNotBeginWith: 'beginsWith',\n  endsWith: 'doesNotEndWith',\n  doesNotEndWith: 'endsWith',\n  contains: 'doesNotContain',\n  doesNotContain: 'contains',\n  between: 'notBetween',\n  notBetween: 'between',\n  in: 'notIn',\n  notIn: 'in',\n  notNull: 'null',\n  null: 'notNull',\n} satisfies Record<DefaultOperatorName, DefaultOperatorName>;\n\n/**\n * Default combinator list.\n */\n// #region docs-combinators\nexport const defaultCombinators = [\n  { name: 'and', value: 'and', label: 'AND' } as const,\n  { name: 'or', value: 'or', label: 'OR' } as const,\n] satisfies DefaultCombinator[];\n// #endregion\n\n/**\n * Default combinator list, with `XOR` added.\n */\nexport const defaultCombinatorsExtended = [\n  ...defaultCombinators,\n  { name: 'xor', value: 'xor', label: 'XOR' } as const,\n] satisfies DefaultCombinatorExtended[];\n\n/**\n * Standard classnames applied to each component.\n */\n// #region docs-standardclassnames\nexport const standardClassnames = {\n  queryBuilder: 'queryBuilder',\n  ruleGroup: 'ruleGroup',\n  header: 'ruleGroup-header',\n  body: 'ruleGroup-body',\n  combinators: 'ruleGroup-combinators',\n  addRule: 'ruleGroup-addRule',\n  addGroup: 'ruleGroup-addGroup',\n  cloneRule: 'rule-cloneRule',\n  cloneGroup: 'ruleGroup-cloneGroup',\n  removeGroup: 'ruleGroup-remove',\n  notToggle: 'ruleGroup-notToggle',\n  rule: 'rule',\n  fields: 'rule-fields',\n  operators: 'rule-operators',\n  value: 'rule-value',\n  removeRule: 'rule-remove',\n  betweenRules: 'betweenRules',\n  valid: 'queryBuilder-valid',\n  invalid: 'queryBuilder-invalid',\n  shiftActions: 'shiftActions',\n  dndDragging: 'dndDragging',\n  dndOver: 'dndOver',\n  dndCopy: 'dndCopy',\n  dragHandle: 'queryBuilder-dragHandle',\n  disabled: 'queryBuilder-disabled',\n  lockRule: 'rule-lock',\n  lockGroup: 'ruleGroup-lock',\n  valueSource: 'rule-valueSource',\n  valueListItem: 'rule-value-list-item',\n  branches: 'queryBuilder-branches',\n} as const;\n// #endregion\n\n/**\n * Default classnames for each component.\n */\nexport const defaultControlClassnames = {\n  queryBuilder: '',\n  ruleGroup: '',\n  header: '',\n  body: '',\n  combinators: '',\n  addRule: '',\n  addGroup: '',\n  cloneRule: '',\n  cloneGroup: '',\n  removeGroup: '',\n  notToggle: '',\n  rule: '',\n  fields: '',\n  operators: '',\n  value: '',\n  removeRule: '',\n  shiftActions: '',\n  dragHandle: '',\n  lockRule: '',\n  lockGroup: '',\n  valueSource: '',\n  actionElement: '',\n  valueSelector: '',\n} satisfies Classnames;\n\n/**\n * Default reason codes for a group being invalid.\n */\nexport const groupInvalidReasons = {\n  empty: 'empty',\n  invalidCombinator: 'invalid combinator',\n  invalidIndependentCombinators: 'invalid independent combinators',\n} as const;\n\n/**\n * Component identifiers for testing.\n */\nexport const TestID = {\n  rule: 'rule',\n  ruleGroup: 'rule-group',\n  inlineCombinator: 'inline-combinator',\n  addGroup: 'add-group',\n  removeGroup: 'remove-group',\n  cloneGroup: 'clone-group',\n  cloneRule: 'clone-rule',\n  addRule: 'add-rule',\n  removeRule: 'remove-rule',\n  combinators: 'combinators',\n  fields: 'fields',\n  operators: 'operators',\n  valueEditor: 'value-editor',\n  notToggle: 'not-toggle',\n  shiftActions: 'shift-actions',\n  dragHandle: 'drag-handle',\n  lockRule: 'lock-rule',\n  lockGroup: 'lock-group',\n  valueSourceSelector: 'value-source-selector',\n} as const;\n\nexport const LogType = {\n  parentPathDisabled: 'action aborted: parent path disabled',\n  pathDisabled: 'action aborted: path is disabled',\n  queryUpdate: 'query updated',\n  onAddRuleFalse: 'onAddRule callback returned false',\n  onAddGroupFalse: 'onAddGroup callback returned false',\n  onRemoveFalse: 'onRemove callback returned false',\n  add: 'rule or group added',\n  remove: 'rule or group removed',\n  update: 'rule or group updated',\n  move: 'rule or group moved',\n} as const;\n","import { defaultJoinChar } from '../defaults';\n\n/**\n * Splits a string by a given character (see {@link defaultJoinChar}. Escaped characters\n * (characters preceded by a backslash) will not apply to the split, and the backslash will\n * be removed in the array element. Inverse of {@link joinWith}.\n *\n * @example\n * splitBy('this\\\\,\\\\,that,,the other,,,\\\\,')\n * // or\n * splitBy('this\\\\,\\\\,that,,the other,,,\\\\,', ',')\n * // would return\n * ['this,,that', '', 'the other', '', '', ',']\n */\nexport const splitBy = (str?: string, splitChar = defaultJoinChar) =>\n  typeof str === 'string'\n    ? str\n        .split(`\\\\${splitChar}`)\n        .map(c => c.split(splitChar))\n        .reduce((prev, curr, idx) => {\n          if (idx === 0) {\n            return curr;\n          }\n          return [\n            ...prev.slice(0, prev.length - 1),\n            `${prev[prev.length - 1]}${splitChar}${curr[0]}`,\n            ...curr.slice(1),\n          ];\n        }, [])\n    : [];\n\n/**\n * Joins an array of strings using the given character (see {@link defaultJoinChar}. When\n * the given character appears in an array element, a backslash will be added just before it\n * to distinguish it from the join character. Inverse of {@link splitBy}.\n *\n * @example\n * joinWith(['this,,that', '', 'the other', '', '', ','])\n * // would return\n * 'this\\\\,\\\\,that,,the other,,,\\\\,'\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const joinWith = (strArr: any[], joinChar = defaultJoinChar) =>\n  strArr.map(str => `${str ?? ''}`.replaceAll(joinChar, `\\\\${joinChar}`)).join(joinChar);\n\n/**\n * Trims the value if it is a string. Otherwise returns the value as is.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const trimIfString = (val: any) => (typeof val === 'string' ? val.trim() : val);\n\n/**\n * Splits a string by comma then trims each element. Arrays are returned as is except\n * any string elements are trimmed.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const toArray = (v: any) =>\n  Array.isArray(v)\n    ? v.map(trimIfString)\n    : typeof v === 'string'\n      ? splitBy(v, defaultJoinChar)\n          .filter(s => !/^\\s*$/.test(s))\n          .map(s => s.trim())\n      : typeof v === 'number'\n        ? [v]\n        : [];\n\n/**\n * Determines if an array is free of `null`/`undefined`.\n */\nexport const nullFreeArray = <T>(arr: T[]): arr is Exclude<T, null>[] =>\n  arr.every(el => el === false || (el ?? false) !== false);\n","import { numericQuantity } from 'numeric-quantity';\nimport type { ParseNumbersMethod } from '../types/index.noReact';\n\n/**\n * Options object for {@link parseNumber}.\n */\nexport interface ParseNumberOptions {\n  parseNumbers?: ParseNumbersMethod;\n}\n\n/**\n * Converts a string to a number. Uses native `parseFloat` if `parseNumbers` is \"native\",\n * otherwise uses [`numeric-quantity`](https://jakeboone02.github.io/numeric-quantity/).\n * If that returns `NaN`, the string is returned unchanged. Numeric values are returned\n * as-is regardless of the `parseNumbers` option.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const parseNumber = (v: any, pno: ParseNumberOptions = {}) => {\n  if (!pno.parseNumbers || typeof v === 'bigint' || typeof v === 'number') {\n    return v;\n  }\n  if (pno.parseNumbers === 'native') {\n    return parseFloat(v);\n  }\n  const n =\n    // TODO: Should these options be configurable?\n    numericQuantity(v, {\n      allowTrailingInvalid: pno.parseNumbers === 'enhanced',\n      romanNumerals: true,\n      round: false,\n    });\n  return isNaN(n) ? v : n;\n};\n","import { numericRegex as numericQuantityRegex } from 'numeric-quantity';\n\n/**\n * Regex matching numeric strings. Passes for positive/negative integers, decimals,\n * and E notation, with optional surrounding whitespace.\n */\nexport const numericRegex = new RegExp(\n  numericQuantityRegex.source.replace(/^\\^/, '^\\\\s*').replace(/\\$$/, '\\\\s*$')\n);\n\n/**\n * Determines if a variable is a plain old JavaScript object, aka POJO.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isPojo = (obj: any): obj is Record<string, any> =>\n  obj === null || typeof obj !== 'object' ? false : Object.getPrototypeOf(obj) === Object.prototype;\n","import type { RuleGroupType, RuleGroupTypeAny, RuleGroupTypeIC } from '../types/index.noReact';\nimport { isPojo } from './misc';\n\n/**\n * Determines if an object is a {@link RuleGroupType} or {@link RuleGroupTypeIC}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isRuleGroup = (rg: any): rg is RuleGroupTypeAny =>\n  isPojo(rg) && 'rules' in rg && Array.isArray(rg.rules);\n\n/**\n * Determines if an object is a {@link RuleGroupType}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isRuleGroupType = (rg: any): rg is RuleGroupType =>\n  isRuleGroup(rg) && typeof rg.combinator === 'string';\n\n/**\n * Determines if an object is a {@link RuleGroupTypeIC}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isRuleGroupTypeIC = (rg: any): rg is RuleGroupTypeIC =>\n  isRuleGroup(rg) && typeof rg.combinator === 'undefined';\n","import type {\n  DefaultCombinatorName,\n  RuleGroupTypeAny,\n  ValueProcessorByRule,\n  ValueProcessorLegacy,\n} from '../../types/index.noReact';\nimport { isRuleGroup } from '../isRuleGroup';\nimport { numericRegex } from '../misc';\nimport { parseNumber } from '../parseNumber';\n\nexport const mapSQLOperator = (op: string) => {\n  switch (op.toLowerCase()) {\n    case 'null':\n      return 'is null';\n    case 'notnull':\n      return 'is not null';\n    case 'notin':\n      return 'not in';\n    case 'notbetween':\n      return 'not between';\n    case 'contains':\n    case 'beginswith':\n    case 'endswith':\n      return 'like';\n    case 'doesnotcontain':\n    case 'doesnotbeginwith':\n    case 'doesnotendwith':\n      return 'not like';\n    default:\n      return op;\n  }\n};\n\nexport const mongoOperators = {\n  '=': '$eq',\n  '!=': '$ne',\n  '<': '$lt',\n  '<=': '$lte',\n  '>': '$gt',\n  '>=': '$gte',\n  in: '$in',\n  notIn: '$nin',\n};\n\nexport const celCombinatorMap = {\n  and: '&&',\n  or: '||',\n} satisfies Record<DefaultCombinatorName, '&&' | '||'>;\n\n/**\n * Register these operators with `jsonLogic` before applying the result\n * of `formatQuery(query, 'jsonlogic')`.\n *\n * @example\n * ```\n * for (const [op, func] of Object.entries(jsonLogicAdditionalOperators)) {\n *   jsonLogic.add_operation(op, func);\n * }\n * jsonLogic.apply({ \"startsWith\": [{ \"var\": \"firstName\" }, \"Stev\"] }, data);\n * ```\n */\nexport const jsonLogicAdditionalOperators = {\n  startsWith: (a: string, b: string) => typeof a === 'string' && a.startsWith(b),\n  endsWith: (a: string, b: string) => typeof a === 'string' && a.endsWith(b),\n} satisfies Record<'startsWith' | 'endsWith', (a: string, b: string) => boolean>;\n\nexport const numerifyValues = (rg: RuleGroupTypeAny): RuleGroupTypeAny => ({\n  ...rg,\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-expect-error TS doesn't keep track of odd/even indexes here\n  rules: rg.rules.map(r => {\n    if (typeof r === 'string') {\n      return r;\n    }\n\n    if (isRuleGroup(r)) {\n      return numerifyValues(r);\n    }\n\n    let { value } = r;\n    if (typeof value === 'string') {\n      value = parseNumber(value, { parseNumbers: true });\n    }\n\n    return { ...r, value };\n  }),\n});\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isValidValue = (v: any) =>\n  (typeof v === 'string' && v.length > 0) ||\n  (typeof v === 'number' && !isNaN(v)) ||\n  (typeof v !== 'string' && typeof v !== 'number');\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const shouldRenderAsNumber = (v: any, parseNumbers?: boolean) =>\n  parseNumbers &&\n  (typeof v === 'number' ||\n    typeof v === 'bigint' ||\n    (typeof v === 'string' && numericRegex.test(v)));\n\nexport const isValueProcessorLegacy = (\n  vp: ValueProcessorLegacy | ValueProcessorByRule\n): vp is ValueProcessorLegacy => vp.length >= 3;\n\nexport const quoteFieldNamesWithArray = (\n  quoteFieldNamesWith: null | string | [string, string] = ['', '']\n): [string, string] =>\n  Array.isArray(quoteFieldNamesWith)\n    ? quoteFieldNamesWith\n    : typeof quoteFieldNamesWith === 'string'\n      ? [quoteFieldNamesWith, quoteFieldNamesWith]\n      : quoteFieldNamesWith ?? ['', ''];\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const nullOrUndefinedOrEmpty = (v: any) =>\n  v === null || typeof v === 'undefined' || v === '';\n","import type { RuleProcessor } from '../../types/index.noReact';\nimport { toArray, trimIfString } from '../arrayUtils';\nimport { parseNumber } from '../parseNumber';\nimport { nullOrUndefinedOrEmpty, shouldRenderAsNumber } from './utils';\n\nconst shouldNegate = (op: string) => /^(does)?not/i.test(op);\n\nconst escapeDoubleQuotes = (\n  v: string | number | boolean | object | null,\n  escapeQuotes?: boolean\n) => (typeof v !== 'string' || !escapeQuotes ? v : v.replaceAll(`\"`, `\\\\\"`));\n\n/**\n * Default rule processor used by {@link formatQuery} for \"cel\" format.\n */\nexport const defaultRuleProcessorCEL: RuleProcessor = (\n  { field, operator, value, valueSource },\n  // istanbul ignore next\n  { escapeQuotes, parseNumbers } = {}\n) => {\n  const valueIsField = valueSource === 'field';\n  const operatorTL = operator.replace(/^=$/, '==');\n  const useBareValue =\n    typeof value === 'number' ||\n    typeof value === 'boolean' ||\n    typeof value === 'bigint' ||\n    shouldRenderAsNumber(value, parseNumbers);\n\n  switch (operatorTL) {\n    case '<':\n    case '<=':\n    case '==':\n    case '!=':\n    case '>':\n    case '>=':\n      return `${field} ${operatorTL} ${\n        valueIsField || useBareValue\n          ? trimIfString(value)\n          : `\"${escapeDoubleQuotes(value, escapeQuotes)}\"`\n      }`;\n\n    case 'contains':\n    case 'doesNotContain': {\n      const negate = shouldNegate(operatorTL) ? '!' : '';\n      return `${negate}${field}.contains(${\n        valueIsField ? trimIfString(value) : `\"${escapeDoubleQuotes(value, escapeQuotes)}\"`\n      })`;\n    }\n\n    case 'beginsWith':\n    case 'doesNotBeginWith': {\n      const negate = shouldNegate(operatorTL) ? '!' : '';\n      return `${negate}${field}.startsWith(${\n        valueIsField ? trimIfString(value) : `\"${escapeDoubleQuotes(value, escapeQuotes)}\"`\n      })`;\n    }\n\n    case 'endsWith':\n    case 'doesNotEndWith': {\n      const negate = shouldNegate(operatorTL) ? '!' : '';\n      return `${negate}${field}.endsWith(${\n        valueIsField ? trimIfString(value) : `\"${escapeDoubleQuotes(value, escapeQuotes)}\"`\n      })`;\n    }\n\n    case 'null':\n      return `${field} == null`;\n\n    case 'notNull':\n      return `${field} != null`;\n\n    case 'in':\n    case 'notIn': {\n      const negate = shouldNegate(operatorTL);\n      const valueAsArray = toArray(value);\n      return `${negate ? '!(' : ''}${field} in [${valueAsArray\n        .map(val =>\n          valueIsField || shouldRenderAsNumber(val, parseNumbers)\n            ? `${trimIfString(val)}`\n            : `\"${escapeDoubleQuotes(val, escapeQuotes)}\"`\n        )\n        .join(', ')}]${negate ? ')' : ''}`;\n    }\n\n    case 'between':\n    case 'notBetween': {\n      const valueAsArray = toArray(value);\n      if (\n        valueAsArray.length >= 2 &&\n        !nullOrUndefinedOrEmpty(valueAsArray[0]) &&\n        !nullOrUndefinedOrEmpty(valueAsArray[1])\n      ) {\n        const [first, second] = valueAsArray;\n        const firstNum = shouldRenderAsNumber(first, true)\n          ? parseNumber(first, { parseNumbers: true })\n          : NaN;\n        const secondNum = shouldRenderAsNumber(second, true)\n          ? parseNumber(second, { parseNumbers: true })\n          : NaN;\n        let firstValue = isNaN(firstNum)\n          ? valueIsField\n            ? `${first}`\n            : `\"${escapeDoubleQuotes(first, escapeQuotes)}\"`\n          : firstNum;\n        let secondValue = isNaN(secondNum)\n          ? valueIsField\n            ? `${second}`\n            : `\"${escapeDoubleQuotes(second, escapeQuotes)}\"`\n          : secondNum;\n\n        if (firstValue === firstNum && secondValue === secondNum && secondNum < firstNum) {\n          const tempNum = secondNum;\n          secondValue = firstNum;\n          firstValue = tempNum;\n        }\n\n        if (operator === 'between') {\n          return `(${field} >= ${firstValue} && ${field} <= ${secondValue})`;\n        } else {\n          return `(${field} < ${firstValue} || ${field} > ${secondValue})`;\n        }\n      } else {\n        return '';\n      }\n    }\n  }\n  return '';\n};\n","import type { RuleProcessor } from '../../types/index.noReact';\nimport { toArray, trimIfString } from '../arrayUtils';\nimport { parseNumber } from '../parseNumber';\nimport { isValidValue, mongoOperators, shouldRenderAsNumber } from './utils';\n\nconst escapeDoubleQuotes = (v: string | number | boolean | object | null) =>\n  typeof v !== 'string' ? v : v.replaceAll('\\\\', '\\\\\\\\').replaceAll(`\"`, `\\\\\"`);\n\n/**\n * Default rule processor used by {@link formatQuery} for \"mongodb\" format.\n */\nexport const defaultRuleProcessorMongoDB: RuleProcessor = (\n  { field, operator, value, valueSource },\n  // istanbul ignore next\n  { parseNumbers } = {}\n) => {\n  const valueIsField = valueSource === 'field';\n  const useBareValue =\n    typeof value === 'number' ||\n    typeof value === 'boolean' ||\n    typeof value === 'bigint' ||\n    shouldRenderAsNumber(value, parseNumbers);\n\n  if (operator === '=' && !valueIsField) {\n    return `{\"${field}\":${useBareValue ? trimIfString(value) : `\"${escapeDoubleQuotes(value)}\"`}}`;\n  }\n\n  switch (operator) {\n    case '<':\n    case '<=':\n    case '=':\n    case '!=':\n    case '>':\n    case '>=': {\n      const mongoOperator = mongoOperators[operator];\n      return valueIsField\n        ? `{\"$expr\":{\"${mongoOperator}\":[\"$${field}\",\"$${value}\"]}}`\n        : `{\"${field}\":{\"${mongoOperator}\":${\n            useBareValue ? trimIfString(value) : `\"${escapeDoubleQuotes(value)}\"`\n          }}}`;\n    }\n\n    case 'contains':\n      return valueIsField\n        ? `{\"$where\":\"this.${field}.includes(this.${value})\"}`\n        : `{\"${field}\":{\"$regex\":\"${escapeDoubleQuotes(value)}\"}}`;\n\n    case 'beginsWith':\n      return valueIsField\n        ? `{\"$where\":\"this.${field}.startsWith(this.${value})\"}`\n        : `{\"${field}\":{\"$regex\":\"^${escapeDoubleQuotes(value)}\"}}`;\n\n    case 'endsWith':\n      return valueIsField\n        ? `{\"$where\":\"this.${field}.endsWith(this.${value})\"}`\n        : `{\"${field}\":{\"$regex\":\"${escapeDoubleQuotes(value)}$\"}}`;\n\n    case 'doesNotContain':\n      return valueIsField\n        ? `{\"$where\":\"!this.${field}.includes(this.${value})\"}`\n        : `{\"${field}\":{\"$not\":{\"$regex\":\"${escapeDoubleQuotes(value)}\"}}}`;\n\n    case 'doesNotBeginWith':\n      return valueIsField\n        ? `{\"$where\":\"!this.${field}.startsWith(this.${value})\"}`\n        : `{\"${field}\":{\"$not\":{\"$regex\":\"^${escapeDoubleQuotes(value)}\"}}}`;\n\n    case 'doesNotEndWith':\n      return valueIsField\n        ? `{\"$where\":\"!this.${field}.endsWith(this.${value})\"}`\n        : `{\"${field}\":{\"$not\":{\"$regex\":\"${escapeDoubleQuotes(value)}$\"}}}`;\n\n    case 'null':\n      return `{\"${field}\":null}`;\n\n    case 'notNull':\n      return `{\"${field}\":{\"$ne\":null}}`;\n\n    case 'in':\n    case 'notIn': {\n      const valueAsArray = toArray(value);\n      return valueIsField\n        ? `{\"$where\":\"${operator === 'notIn' ? '!' : ''}[${valueAsArray\n            .map(val => `this.${val}`)\n            .join(',')}].includes(this.${field})\"}`\n        : `{\"${field}\":{\"${mongoOperators[operator]}\":[${valueAsArray\n            .map(val =>\n              shouldRenderAsNumber(val, parseNumbers)\n                ? `${trimIfString(val)}`\n                : `\"${escapeDoubleQuotes(val)}\"`\n            )\n            .join(',')}]}}`;\n    }\n\n    case 'between':\n    case 'notBetween': {\n      const valueAsArray = toArray(value);\n      if (\n        valueAsArray.length >= 2 &&\n        isValidValue(valueAsArray[0]) &&\n        isValidValue(valueAsArray[1])\n      ) {\n        const [first, second] = valueAsArray;\n        const firstNum = shouldRenderAsNumber(first, true)\n          ? parseNumber(first, { parseNumbers: true })\n          : NaN;\n        const secondNum = shouldRenderAsNumber(second, true)\n          ? parseNumber(second, { parseNumbers: true })\n          : NaN;\n        const firstValue =\n          valueIsField || !isNaN(firstNum) ? `${first}` : `\"${escapeDoubleQuotes(first)}\"`;\n        const secondValue =\n          valueIsField || !isNaN(secondNum) ? `${second}` : `\"${escapeDoubleQuotes(second)}\"`;\n        if (operator === 'between') {\n          return valueIsField\n            ? `{\"$and\":[{\"$expr\":{\"$gte\":[\"$${field}\",\"$${firstValue}\"]}},{\"$expr\":{\"$lte\":[\"$${field}\",\"$${secondValue}\"]}}]}`\n            : `{\"${field}\":{\"$gte\":${firstValue},\"$lte\":${secondValue}}}`;\n        } else {\n          return valueIsField\n            ? `{\"$or\":[{\"$expr\":{\"$lt\":[\"$${field}\",\"$${firstValue}\"]}},{\"$expr\":{\"$gt\":[\"$${field}\",\"$${secondValue}\"]}}]}`\n            : `{\"$or\":[{\"${field}\":{\"$lt\":${firstValue}}},{\"${field}\":{\"$gt\":${secondValue}}}]}`;\n        }\n      } else {\n        return '';\n      }\n    }\n  }\n  return '';\n};\n","import type { RuleProcessor } from '../../types/index.noReact';\nimport { toArray, trimIfString } from '../arrayUtils';\nimport { parseNumber } from '../parseNumber';\nimport { nullOrUndefinedOrEmpty, shouldRenderAsNumber } from './utils';\n\nconst shouldNegate = (op: string) => /^(does)?not/i.test(op);\n\nconst wrapInNegation = (clause: string, negate: boolean) => (negate ? `!(${clause})` : `${clause}`);\n\nconst escapeSingleQuotes = (\n  v: string | number | boolean | object | null,\n  escapeQuotes?: boolean\n) => (typeof v !== 'string' || !escapeQuotes ? v : v.replaceAll(`'`, `\\\\'`));\n\n/**\n * Default rule processor used by {@link formatQuery} for \"spel\" format.\n */\nexport const defaultRuleProcessorSpEL: RuleProcessor = (\n  { field, operator, value, valueSource },\n  // istanbul ignore next\n  { escapeQuotes, parseNumbers } = {}\n) => {\n  const valueIsField = valueSource === 'field';\n  const operatorTL = operator.replace(/^=$/, '==');\n  const useBareValue =\n    typeof value === 'number' ||\n    typeof value === 'boolean' ||\n    typeof value === 'bigint' ||\n    shouldRenderAsNumber(value, parseNumbers);\n\n  switch (operatorTL) {\n    case '<':\n    case '<=':\n    case '==':\n    case '!=':\n    case '>':\n    case '>=':\n      return `${field} ${operatorTL} ${\n        valueIsField || useBareValue\n          ? trimIfString(value)\n          : `'${escapeSingleQuotes(value, escapeQuotes)}'`\n      }`;\n\n    case 'contains':\n    case 'doesNotContain':\n      return wrapInNegation(\n        `${field} matches ${\n          valueIsField || useBareValue\n            ? trimIfString(value)\n            : `'${escapeSingleQuotes(value, escapeQuotes)}'`\n        }`,\n        shouldNegate(operatorTL)\n      );\n\n    case 'beginsWith':\n    case 'doesNotBeginWith': {\n      const valueTL = valueIsField\n        ? `'^'.concat(${trimIfString(value)})`\n        : `'${\n            (typeof value === 'string' && !value.startsWith('^')) || useBareValue ? '^' : ''\n          }${escapeSingleQuotes(value, escapeQuotes)}'`;\n      return wrapInNegation(`${field} matches ${valueTL}`, shouldNegate(operatorTL));\n    }\n\n    case 'endsWith':\n    case 'doesNotEndWith': {\n      const valueTL = valueIsField\n        ? `${trimIfString(value)}.concat('$')`\n        : `'${escapeSingleQuotes(value, escapeQuotes)}${\n            (typeof value === 'string' && !value.endsWith('$')) || useBareValue ? '$' : ''\n          }'`;\n      return wrapInNegation(`${field} matches ${valueTL}`, shouldNegate(operatorTL));\n    }\n\n    case 'null':\n      return `${field} == null`;\n\n    case 'notNull':\n      return `${field} != null`;\n\n    case 'in':\n    case 'notIn': {\n      const negate = shouldNegate(operatorTL) ? '!' : '';\n      const valueAsArray = toArray(value);\n      if (valueAsArray.length > 0) {\n        return `${negate}(${valueAsArray\n          .map(\n            val =>\n              `${field} == ${\n                valueIsField || shouldRenderAsNumber(val, parseNumbers)\n                  ? `${trimIfString(val)}`\n                  : `'${escapeSingleQuotes(val, escapeQuotes)}'`\n              }`\n          )\n          .join(' or ')})`;\n      } else {\n        return '';\n      }\n    }\n\n    case 'between':\n    case 'notBetween': {\n      const valueAsArray = toArray(value);\n      if (\n        valueAsArray.length >= 2 &&\n        !nullOrUndefinedOrEmpty(valueAsArray[0]) &&\n        !nullOrUndefinedOrEmpty(valueAsArray[1])\n      ) {\n        const [first, second] = valueAsArray;\n        const firstNum = shouldRenderAsNumber(first, true)\n          ? parseNumber(first, { parseNumbers: true })\n          : NaN;\n        const secondNum = shouldRenderAsNumber(second, true)\n          ? parseNumber(second, { parseNumbers: true })\n          : NaN;\n        let firstValue = isNaN(firstNum)\n          ? valueIsField\n            ? `${first}`\n            : `'${escapeSingleQuotes(first, escapeQuotes)}'`\n          : firstNum;\n        let secondValue = isNaN(secondNum)\n          ? valueIsField\n            ? `${second}`\n            : `'${escapeSingleQuotes(second, escapeQuotes)}'`\n          : secondNum;\n        if (firstValue === firstNum && secondValue === secondNum && secondNum < firstNum) {\n          const tempNum = secondNum;\n          secondValue = firstNum;\n          firstValue = tempNum;\n        }\n        if (operator === 'between') {\n          return `(${field} >= ${firstValue} and ${field} <= ${secondValue})`;\n        } else {\n          return `(${field} < ${firstValue} or ${field} > ${secondValue})`;\n        }\n      } else {\n        return '';\n      }\n    }\n  }\n\n  return '';\n};\n","import type { ValueProcessorByRule } from '../../types/index.noReact';\nimport { toArray, trimIfString } from '../arrayUtils';\nimport { isValidValue, quoteFieldNamesWithArray, shouldRenderAsNumber } from './utils';\n\nconst escapeStringValueQuotes = (\n  v: string | number | boolean | object | null,\n  quoteChar: string,\n  escapeQuotes?: boolean\n) =>\n  escapeQuotes && typeof v === 'string'\n    ? v.replaceAll(`${quoteChar}`, `${quoteChar}${quoteChar}`)\n    : v;\n\n/**\n * Default value processor used by {@link formatQuery} for \"sql\" format.\n */\nexport const defaultValueProcessorByRule: ValueProcessorByRule = (\n  { operator, value, valueSource },\n  // istanbul ignore next\n  { escapeQuotes, parseNumbers, quoteFieldNamesWith, quoteValuesWith } = {}\n) => {\n  const valueIsField = valueSource === 'field';\n  const [qfnwPre, qfnwPost] = quoteFieldNamesWithArray(quoteFieldNamesWith);\n  const operatorLowerCase = operator.toLowerCase();\n  const quoteChar = quoteValuesWith || \"'\";\n\n  const escapeValue = (v: string | number | boolean | object | null) =>\n    escapeStringValueQuotes(v, quoteChar, escapeQuotes);\n  const wrapAndEscape = (v: string | number | boolean | object | null) =>\n    `${quoteChar}${escapeValue(v)}${quoteChar}`;\n  const wrapFieldName = (f: string) => `${qfnwPre}${f}${qfnwPost}`;\n\n  switch (operatorLowerCase) {\n    case 'null':\n    case 'notnull': {\n      return '';\n    }\n\n    case 'in':\n    case 'notin': {\n      const valueAsArray = toArray(value);\n      if (valueAsArray.length > 0) {\n        return `(${valueAsArray\n          .map(v =>\n            valueIsField\n              ? wrapFieldName(v)\n              : shouldRenderAsNumber(v, parseNumbers)\n                ? `${trimIfString(v)}`\n                : `${wrapAndEscape(v)}`\n          )\n          .join(', ')})`;\n      }\n      return '';\n    }\n\n    case 'between':\n    case 'notbetween': {\n      const valueAsArray = toArray(value);\n      if (\n        valueAsArray.length >= 2 &&\n        isValidValue(valueAsArray[0]) &&\n        isValidValue(valueAsArray[1])\n      ) {\n        const [first, second] = valueAsArray;\n        return valueIsField\n          ? `${wrapFieldName(first)} and ${wrapFieldName(second)}`\n          : shouldRenderAsNumber(first, parseNumbers) && shouldRenderAsNumber(second, parseNumbers)\n            ? `${trimIfString(first)} and ${trimIfString(second)}`\n            : `${wrapAndEscape(first)} and ${wrapAndEscape(second)}`;\n      }\n      return '';\n    }\n\n    case 'contains':\n    case 'doesnotcontain':\n      return valueIsField\n        ? `${quoteChar}%${quoteChar} || ${wrapFieldName(value)} || ${quoteChar}%${quoteChar}`\n        : `${quoteChar}%${escapeValue(value)}%${quoteChar}`;\n\n    case 'beginswith':\n    case 'doesnotbeginwith':\n      return valueIsField\n        ? `${wrapFieldName(value)} || ${quoteChar}%${quoteChar}`\n        : `${quoteChar}${escapeValue(value)}%${quoteChar}`;\n\n    case 'endswith':\n    case 'doesnotendwith':\n      return valueIsField\n        ? `${quoteChar}%${quoteChar} || ${wrapFieldName(value)}`\n        : `${quoteChar}%${escapeValue(value)}${quoteChar}`;\n  }\n\n  if (typeof value === 'boolean') {\n    return value ? 'TRUE' : 'FALSE';\n  }\n\n  return valueIsField\n    ? wrapFieldName(value)\n    : shouldRenderAsNumber(value, parseNumbers)\n      ? `${trimIfString(value)}`\n      : `${wrapAndEscape(value)}`;\n};\n","import type { DefaultOperatorName, RuleProcessor } from '../../types/index.noReact';\nimport { toArray } from '../arrayUtils';\nimport { parseNumber } from '../parseNumber';\nimport { isValidValue, shouldRenderAsNumber } from './utils';\n\ntype RangeOperator = 'gt' | 'gte' | 'lt' | 'lte';\ntype RangeRule = (\n  | { gt: string | number }\n  | { gte: string | number }\n  | { lt: string | number }\n  | { lte: string | number }\n) & { [k in RangeOperator]?: string | number };\ntype ElasticSearchRule =\n  | { range: Record<string, RangeRule> }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | { term: Record<string, any> }\n  | { exists: { field: string } }\n  | { regexp: { [k: string]: { value: string } } };\ntype ElasticSearchQuery = {\n  bool:\n    | { filter: { script: { script: string } } }\n    | { must: ElasticSearchRule | ElasticSearchQuery | (ElasticSearchRule | ElasticSearchQuery)[] }\n    | {\n        must_not:\n          | ElasticSearchRule\n          | ElasticSearchQuery\n          | (ElasticSearchRule | ElasticSearchQuery)[];\n      }\n    | {\n        should: ElasticSearchRule | ElasticSearchQuery | (ElasticSearchRule | ElasticSearchQuery)[];\n      };\n};\n\nconst rangeOperatorMap = { '<': 'lt', '<=': 'lte', '>': 'gt', '>=': 'gte' } satisfies Record<\n  '<' | '<=' | '>' | '>=',\n  RangeOperator\n>;\n\nconst negateIfNotOp = (\n  op: string,\n  elasticSearchRule: ElasticSearchRule\n): ElasticSearchQuery | ElasticSearchRule =>\n  /^(does)?not/i.test(op) ? { bool: { must_not: elasticSearchRule } } : elasticSearchRule;\n\nconst escapeSQ = (s: string) => s?.replace(/('|\\\\)/g, `\\\\$1`);\n\nconst textFunctionMap: Partial<Record<DefaultOperatorName, string>> = {\n  beginsWith: 'startsWith',\n  doesNotContain: 'contains',\n  doesNotBeginWith: 'startsWith',\n  doesNotEndWith: 'endsWith',\n};\nconst getTextScript = (f: string, o: DefaultOperatorName, v: string) => {\n  const script = `doc['${f}'].${textFunctionMap[o] ?? o}(doc['${v}'])`;\n  return o.startsWith('d') ? `!${script}` : script;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst valueRenderer = (v: any, parseNumbers?: boolean) =>\n  typeof v === 'boolean'\n    ? v\n    : shouldRenderAsNumber(v, parseNumbers)\n      ? parseNumber(v, { parseNumbers })\n      : v;\n\n/**\n * Default rule processor used by {@link formatQuery} for \"elasticsearch\" format.\n */\nexport const defaultRuleProcessorElasticSearch: RuleProcessor = (\n  { field, operator, value, valueSource },\n  { parseNumbers } = {}\n): ElasticSearchQuery | ElasticSearchRule | false => {\n  if (valueSource === 'field') {\n    // Bail out if not all values are strings\n    if (toArray(value).some(v => typeof v !== 'string')) return false;\n\n    const fieldForScript = escapeSQ(field);\n\n    switch (operator) {\n      case '=':\n      case '!=':\n      case '>':\n      case '>=':\n      case '<':\n      case '<=': {\n        const operatorForScript = operator === '=' ? '==' : operator;\n        const valueForScript = escapeSQ(value);\n        return !valueForScript\n          ? false\n          : {\n              bool: {\n                filter: {\n                  script: {\n                    script: `doc['${fieldForScript}'] ${operatorForScript} doc['${valueForScript}']`,\n                  },\n                },\n              },\n            };\n      }\n\n      case 'in':\n      case 'notIn': {\n        const valueAsArray = toArray(value);\n        if (valueAsArray.length > 0) {\n          const arr = valueAsArray.map(v => ({\n            bool: { filter: { script: { script: `doc['${fieldForScript}'] == doc['${v}']` } } },\n          }));\n          return { bool: operator === 'in' ? { should: arr } : { must_not: arr } };\n        }\n        return false;\n      }\n\n      case 'between':\n      case 'notBetween': {\n        const valueAsArray = toArray(value);\n        if (valueAsArray.length >= 2 && valueAsArray[0] && valueAsArray[1]) {\n          const script = `doc['${fieldForScript}'] >= doc['${valueAsArray[0]}'] && doc['${fieldForScript}'] <= doc['${valueAsArray[1]}']`;\n          return {\n            bool: {\n              filter: { script: { script: operator === 'notBetween' ? `!(${script})` : script } },\n            },\n          };\n        }\n        return false;\n      }\n\n      case 'contains':\n      case 'doesNotContain':\n      case 'beginsWith':\n      case 'doesNotBeginWith':\n      case 'endsWith':\n      case 'doesNotEndWith': {\n        const valueForScript = escapeSQ(value);\n        if (!valueForScript) return false;\n        const script = getTextScript(fieldForScript, operator, valueForScript);\n        return {\n          bool: {\n            filter: {\n              script: {\n                script,\n              },\n            },\n          },\n        };\n      }\n    }\n  }\n\n  switch (operator) {\n    case '<':\n    case '<=':\n    case '>':\n    case '>=':\n      return {\n        range: {\n          [field]: {\n            [rangeOperatorMap[operator]]: valueRenderer(value, parseNumbers),\n          } as RangeRule,\n        },\n      };\n\n    case '=':\n      return { term: { [field]: valueRenderer(value, parseNumbers) } };\n\n    case '!=':\n      return { bool: { must_not: { term: { [field]: valueRenderer(value, parseNumbers) } } } };\n\n    case 'null':\n      return { bool: { must_not: { exists: { field } } } };\n\n    case 'notNull':\n      return { exists: { field } };\n\n    case 'in':\n    case 'notIn': {\n      const valueAsArray = toArray(value).map(v => valueRenderer(v, parseNumbers));\n      if (valueAsArray.length > 0) {\n        const arr = valueAsArray.map(v => ({ term: { [field]: valueRenderer(v, parseNumbers) } }));\n        return { bool: operator === 'in' ? { should: arr } : { must_not: arr } };\n      }\n      return false;\n    }\n\n    case 'between':\n    case 'notBetween': {\n      const valueAsArray = toArray(value);\n      if (\n        valueAsArray.length >= 2 &&\n        isValidValue(valueAsArray[0]) &&\n        isValidValue(valueAsArray[1])\n      ) {\n        let [first, second] = valueAsArray;\n        if (shouldRenderAsNumber(first, true) && shouldRenderAsNumber(second, true)) {\n          const firstNum = parseNumber(first, { parseNumbers: true });\n          const secondNum = parseNumber(second, { parseNumbers: true });\n          if (secondNum < firstNum) {\n            const tempNum = secondNum;\n            second = firstNum;\n            first = tempNum;\n          } else {\n            first = firstNum;\n            second = secondNum;\n          }\n        }\n        return negateIfNotOp(operator, { range: { [field]: { gte: first, lte: second } } });\n      }\n      return false;\n    }\n\n    case 'contains':\n    case 'doesNotContain':\n      return negateIfNotOp(operator, { regexp: { [field]: { value } } });\n\n    case 'beginsWith':\n    case 'doesNotBeginWith':\n      return negateIfNotOp(operator, { regexp: { [field]: { value: `^${value}` } } });\n\n    case 'endsWith':\n    case 'doesNotEndWith':\n      return negateIfNotOp(operator, { regexp: { [field]: { value: `${value}$` } } });\n  }\n  return false;\n};\n","import type { RuleProcessor } from '../../types/index.noReact';\nimport { toArray, trimIfString } from '../arrayUtils';\nimport { parseNumber } from '../parseNumber';\nimport { nullOrUndefinedOrEmpty, quoteFieldNamesWithArray, shouldRenderAsNumber } from './utils';\n\nconst shouldNegate = (op: string) => /^(does)?not/i.test(op);\n\nconst quote = (v: string | number | boolean | object | null, escapeQuotes?: boolean) =>\n  `\"${typeof v !== 'string' || !escapeQuotes ? v : v.replaceAll(`\"`, `\\\\\"`)}\"`;\n\nconst negate = (clause: string, negate: boolean) => (negate ? `$not(${clause})` : `${clause}`);\n\nconst escapeStringRegex = (s: string) =>\n  `${s}`.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n\n/**\n * Default rule processor used by {@link formatQuery} for \"jsonata\" format.\n */\nexport const defaultRuleProcessorJSONata: RuleProcessor = (\n  { field, operator, value, valueSource },\n  // istanbul ignore next\n  { escapeQuotes, parseNumbers = true, quoteFieldNamesWith = ['', ''] as [string, string] } = {}\n) => {\n  const valueIsField = valueSource === 'field';\n  const useBareValue =\n    typeof value === 'number' ||\n    typeof value === 'boolean' ||\n    typeof value === 'bigint' ||\n    shouldRenderAsNumber(value, parseNumbers);\n\n  const [qPre, qPost] = quoteFieldNamesWithArray(quoteFieldNamesWith);\n  const qfn = (f: string) => `${qPre}${f}${qPost}`;\n\n  switch (operator) {\n    case '<':\n    case '<=':\n    case '=':\n    case '!=':\n    case '>':\n    case '>=':\n      return `${qfn(field)} ${operator} ${\n        valueIsField\n          ? qfn(trimIfString(value))\n          : useBareValue\n            ? trimIfString(value)\n            : quote(value, escapeQuotes)\n      }`;\n\n    case 'contains':\n    case 'doesNotContain':\n      return negate(\n        `$contains(${qfn(field)}, ${valueIsField ? qfn(trimIfString(value)) : quote(value, escapeQuotes)})`,\n        shouldNegate(operator)\n      );\n\n    case 'beginsWith':\n    case 'doesNotBeginWith':\n      return negate(\n        valueIsField\n          ? `$substring(${qfn(field)}, 0, $length(${qfn(trimIfString(value))})) = ${qfn(trimIfString(value))}`\n          : `$contains(${qfn(field)}, /^${escapeStringRegex(value)}/)`,\n        shouldNegate(operator)\n      );\n\n    case 'endsWith':\n    case 'doesNotEndWith':\n      return negate(\n        valueIsField\n          ? `$substring(${qfn(field)}, $length(${qfn(field)}) - $length(${qfn(trimIfString(value))})) = ${qfn(trimIfString(value))}`\n          : `$contains(${qfn(field)}, /${escapeStringRegex(value)}$/)`,\n        shouldNegate(operator)\n      );\n\n    case 'null':\n      return `${qfn(field)} = null`;\n\n    case 'notNull':\n      return `${qfn(field)} != null`;\n\n    case 'in':\n    case 'notIn': {\n      const valueAsArray = toArray(value);\n      return negate(\n        `${qfn(field)} in [${valueAsArray\n          .map(val =>\n            valueIsField\n              ? `${qfn(trimIfString(val))}`\n              : shouldRenderAsNumber(val, parseNumbers)\n                ? `${trimIfString(val)}`\n                : quote(val, escapeQuotes)\n          )\n          .join(', ')}]`,\n        shouldNegate(operator)\n      );\n    }\n\n    case 'between':\n    case 'notBetween': {\n      const valueAsArray = toArray(value);\n      if (\n        valueAsArray.length >= 2 &&\n        !nullOrUndefinedOrEmpty(valueAsArray[0]) &&\n        !nullOrUndefinedOrEmpty(valueAsArray[1])\n      ) {\n        const [first, second] = valueAsArray;\n        const firstNum = shouldRenderAsNumber(first, true)\n          ? parseNumber(first, { parseNumbers: true })\n          : NaN;\n        const secondNum = shouldRenderAsNumber(second, true)\n          ? parseNumber(second, { parseNumbers: true })\n          : NaN;\n        let firstValue = isNaN(firstNum) ? (valueIsField ? `${first}` : first) : firstNum;\n        let secondValue = isNaN(secondNum) ? (valueIsField ? `${second}` : second) : secondNum;\n\n        if (firstValue === firstNum && secondValue === secondNum && secondNum < firstNum) {\n          const tempNum = secondNum;\n          secondValue = firstNum;\n          firstValue = tempNum;\n        }\n\n        const renderAsNumbers =\n          shouldRenderAsNumber(first, parseNumbers) && shouldRenderAsNumber(second, parseNumbers);\n\n        const expression = `${qfn(field)} >= ${valueIsField ? qfn(first) : renderAsNumbers ? firstValue : quote(firstValue, escapeQuotes)} and ${qfn(field)} <= ${valueIsField ? qfn(second) : renderAsNumbers ? secondValue : quote(secondValue, escapeQuotes)}`;\n\n        return operator === 'between' ? `(${expression})` : negate(expression, true);\n      } else {\n        return '';\n      }\n    }\n  }\n  return '';\n};\n","import type { JsonLogicVar, RQBJsonLogic, RuleProcessor } from '../../types/index.noReact';\nimport { toArray } from '../arrayUtils';\nimport { parseNumber } from '../parseNumber';\nimport { isValidValue, shouldRenderAsNumber } from './utils';\n\nconst convertOperator = (op: '<' | '<=' | '=' | '!=' | '>' | '>=') =>\n  op\n    .replace(/^(=)$/, '$1=')\n    .replace(/^notNull$/i, '!=')\n    .replace(/^null$/i, '==') as '<' | '<=' | '==' | '!=' | '===' | '!==' | '>' | '>=';\n\nconst negateIfNotOp = (op: string, jsonRule: RQBJsonLogic) =>\n  /^(does)?not/i.test(op) ? { '!': jsonRule } : jsonRule;\n\n/**\n * Default rule processor used by {@link formatQuery} for \"jsonlogic\" format.\n */\nexport const defaultRuleProcessorJsonLogic: RuleProcessor = (\n  { field, operator, value, valueSource },\n  { parseNumbers } = {}\n): RQBJsonLogic => {\n  const valueIsField = valueSource === 'field';\n  const fieldObject: JsonLogicVar = { var: field };\n  const fieldOrNumberRenderer = (v: string) =>\n    valueIsField\n      ? { var: `${v}` }\n      : shouldRenderAsNumber(v, parseNumbers)\n        ? parseNumber(v, { parseNumbers })\n        : v;\n\n  switch (operator) {\n    case '<':\n    case '<=':\n    case '=':\n    case '!=':\n    case '>':\n    case '>=':\n      return {\n        [convertOperator(operator)]: [fieldObject, fieldOrNumberRenderer(value)],\n      } as RQBJsonLogic;\n\n    case 'null':\n    case 'notNull': {\n      return {\n        [`${operator === 'notNull' ? '!' : '='}=`]: [fieldObject, null],\n      } as RQBJsonLogic;\n    }\n\n    case 'in':\n    case 'notIn': {\n      const valueAsArray = toArray(value).map(fieldOrNumberRenderer);\n      return negateIfNotOp(operator, { in: [fieldObject, valueAsArray] });\n    }\n\n    case 'between':\n    case 'notBetween': {\n      const valueAsArray = toArray(value);\n      if (\n        valueAsArray.length >= 2 &&\n        isValidValue(valueAsArray[0]) &&\n        isValidValue(valueAsArray[1])\n      ) {\n        let [first, second] = valueAsArray;\n        if (\n          !valueIsField &&\n          shouldRenderAsNumber(first, true) &&\n          shouldRenderAsNumber(second, true)\n        ) {\n          const firstNum = parseNumber(first, { parseNumbers: true });\n          const secondNum = parseNumber(second, { parseNumbers: true });\n          if (secondNum < firstNum) {\n            const tempNum = secondNum;\n            second = firstNum;\n            first = tempNum;\n          } else {\n            first = firstNum;\n            second = secondNum;\n          }\n        } else if (valueIsField) {\n          first = { var: first };\n          second = { var: second };\n        }\n        const jsonRule: RQBJsonLogic = { '<=': [first, fieldObject, second] };\n        return negateIfNotOp(operator, jsonRule);\n      }\n      return false;\n    }\n\n    case 'contains':\n    case 'doesNotContain': {\n      const jsonRule: RQBJsonLogic = {\n        in: [fieldOrNumberRenderer(value), fieldObject],\n      };\n      return negateIfNotOp(operator, jsonRule);\n    }\n\n    case 'beginsWith':\n    case 'doesNotBeginWith': {\n      const jsonRule: RQBJsonLogic = {\n        startsWith: [fieldObject, fieldOrNumberRenderer(value)],\n      };\n      return negateIfNotOp(operator, jsonRule);\n    }\n\n    case 'endsWith':\n    case 'doesNotEndWith': {\n      const jsonRule: RQBJsonLogic = {\n        endsWith: [fieldObject, fieldOrNumberRenderer(value)],\n      };\n      return negateIfNotOp(operator, jsonRule);\n    }\n  }\n  return false;\n};\n","import type { RuleProcessor } from '../../types/index.noReact';\nimport { toArray } from '../arrayUtils';\nimport { parseNumber } from '../parseNumber';\nimport { defaultValueProcessorByRule } from './defaultValueProcessorByRule';\nimport { mapSQLOperator, shouldRenderAsNumber } from './utils';\n\n/**\n * Default rule processor used by {@link formatQuery} for \"sql\" format.\n */\nexport const defaultRuleProcessorParameterized: RuleProcessor = (rule, opts, meta) => {\n  // TODO: test for this so we don't have to ignore it\n  // istanbul ignore next\n  const {\n    fieldData,\n    format,\n    getNextNamedParam,\n    parseNumbers,\n    paramPrefix,\n    paramsKeepPrefix,\n    numberedParams,\n    quoteFieldNamesWith = ['', ''] as [string, string],\n    valueProcessor = defaultValueProcessorByRule,\n  } = opts ?? {};\n\n  const { processedParams = [] } = meta ?? {};\n\n  const parameterized = format === 'parameterized';\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const params: any[] = [];\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const paramsNamed: Record<string, any> = {};\n\n  const finalize = (sql: string) => {\n    if (parameterized) {\n      return { sql, params };\n    }\n    return { sql, params: paramsNamed };\n  };\n\n  const value = valueProcessor(rule, {\n    parseNumbers,\n    quoteFieldNamesWith,\n    fieldData,\n    format,\n  });\n\n  const sqlOperator = mapSQLOperator(rule.operator);\n  const sqlOperatorLowerCase = sqlOperator.toLowerCase();\n\n  if (\n    (sqlOperatorLowerCase === 'in' ||\n      sqlOperatorLowerCase === 'not in' ||\n      sqlOperatorLowerCase === 'between' ||\n      sqlOperatorLowerCase === 'not between') &&\n    !value\n  ) {\n    return finalize('');\n  } else if (sqlOperatorLowerCase === 'is null' || sqlOperatorLowerCase === 'is not null') {\n    return finalize(\n      `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${sqlOperator}`\n    );\n  } else if (rule.valueSource === 'field') {\n    return finalize(\n      `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${sqlOperator} ${value}`.trim()\n    );\n  }\n\n  if (sqlOperatorLowerCase === 'in' || sqlOperatorLowerCase === 'not in') {\n    const splitValue = toArray(rule.value);\n    if (parameterized) {\n      splitValue.forEach(v =>\n        params.push(shouldRenderAsNumber(v, parseNumbers) ? parseNumber(v, { parseNumbers }) : v)\n      );\n      return finalize(\n        `${quoteFieldNamesWith[0]}${rule.field}${\n          quoteFieldNamesWith[1]\n        } ${sqlOperator} (${splitValue\n          .map((_v, i) =>\n            numberedParams\n              ? `${paramPrefix}${processedParams.length + 1 + splitValue.length - (splitValue.length - i)}`\n              : '?'\n          )\n          .join(', ')})`\n      );\n    }\n    const inParams: string[] = [];\n    splitValue.forEach(v => {\n      const thisParamName = getNextNamedParam!(rule.field);\n      inParams.push(`${paramPrefix}${thisParamName}`);\n      paramsNamed[`${paramsKeepPrefix ? paramPrefix : ''}${thisParamName}`] = shouldRenderAsNumber(\n        v,\n        parseNumbers\n      )\n        ? parseNumber(v, { parseNumbers })\n        : v;\n    });\n    return finalize(\n      `${quoteFieldNamesWith[0]}${rule.field}${\n        quoteFieldNamesWith[1]\n      } ${sqlOperator} (${inParams.join(', ')})`\n    );\n  } else if (sqlOperatorLowerCase === 'between' || sqlOperatorLowerCase === 'not between') {\n    const valueAsArray = toArray(rule.value);\n    const [first, second] = valueAsArray\n      .slice(0, 2)\n      .map(v => (shouldRenderAsNumber(v, parseNumbers) ? parseNumber(v, { parseNumbers }) : v));\n    if (parameterized) {\n      params.push(first);\n      params.push(second);\n      return finalize(\n        `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${sqlOperator} ${\n          numberedParams ? `${paramPrefix}${processedParams.length + 1}` : '?'\n        } and ${numberedParams ? `${paramPrefix}${processedParams.length + 2}` : '?'}`\n      );\n    }\n    const firstParamName = getNextNamedParam!(rule.field);\n    const secondParamName = getNextNamedParam!(rule.field);\n    paramsNamed[`${paramsKeepPrefix ? paramPrefix : ''}${firstParamName}`] = first;\n    paramsNamed[`${paramsKeepPrefix ? paramPrefix : ''}${secondParamName}`] = second;\n    return finalize(\n      `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${sqlOperator} ${paramPrefix}${firstParamName} and ${paramPrefix}${secondParamName}`\n    );\n  }\n  let paramValue = rule.value;\n  if (typeof rule.value === 'string') {\n    if (shouldRenderAsNumber(rule.value, parseNumbers)) {\n      paramValue = parseNumber(rule.value, { parseNumbers });\n    } else {\n      // Note that we're using `value` here, which has been processed through\n      // a `valueProcessor`, as opposed to `rule.value` which has not\n      paramValue = /^'.*'$/g.test(value)\n        ? value.replace(/(^'|'$)/g, '')\n        : /* istanbul ignore next */ value;\n    }\n  }\n  let paramName = '';\n  if (parameterized) {\n    params.push(paramValue);\n  } else {\n    paramName = getNextNamedParam!(rule.field);\n    paramsNamed[`${paramsKeepPrefix ? paramPrefix : ''}${paramName}`] = paramValue;\n  }\n  return finalize(\n    `${quoteFieldNamesWith[0]}${rule.field}${quoteFieldNamesWith[1]} ${sqlOperator} ${\n      parameterized\n        ? numberedParams\n          ? `${paramPrefix}${processedParams.length + 1}`\n          : '?'\n        : `${paramPrefix}${paramName}`\n    }`.trim()\n  );\n};\n","import type { RuleProcessor } from '../../types/index.noReact';\nimport { defaultValueProcessorByRule } from './defaultValueProcessorByRule';\nimport { mapSQLOperator, quoteFieldNamesWithArray } from './utils';\n\n/**\n * Default rule processor used by {@link formatQuery} for \"sql\" format.\n */\nexport const defaultRuleProcessorSQL: RuleProcessor = (rule, opts) => {\n  const {\n    parseNumbers,\n    escapeQuotes,\n    quoteFieldNamesWith = ['', ''] as [string, string],\n    quoteValuesWith = `'`,\n    valueProcessor = defaultValueProcessorByRule,\n  } = opts ?? {};\n  const value = valueProcessor(rule, {\n    parseNumbers,\n    escapeQuotes,\n    quoteFieldNamesWith,\n    quoteValuesWith,\n  });\n  const operator = mapSQLOperator(rule.operator);\n\n  const operatorLowerCase = operator.toLowerCase();\n  if (\n    (operatorLowerCase === 'in' ||\n      operatorLowerCase === 'not in' ||\n      operatorLowerCase === 'between' ||\n      operatorLowerCase === 'not between') &&\n    !value\n  ) {\n    return '';\n  }\n\n  const [qPre, qPost] = quoteFieldNamesWithArray(quoteFieldNamesWith);\n\n  return `${qPre}${rule.field}${qPost} ${operator} ${value}`.trim();\n};\n","import type {\n  RuleGroupArray,\n  RuleGroupICArray,\n  RuleGroupType,\n  RuleGroupTypeIC,\n  RuleType,\n} from '../types/index.noReact';\nimport { isRuleGroup, isRuleGroupType, isRuleGroupTypeIC } from './isRuleGroup';\n\nconst processRuleOrStringOrRuleGroupIC = (r: string | RuleType | RuleGroupTypeIC) =>\n  isRuleGroup(r) ? generateRuleGroupICWithConsistentCombinators(r) : r;\n\nconst generateRuleGroupICWithConsistentCombinators = (rg: RuleGroupTypeIC): RuleGroupTypeIC => {\n  const returnArray: RuleGroupICArray = [];\n  const push = (r: string | RuleType | RuleGroupTypeIC) =>\n    returnArray.push(processRuleOrStringOrRuleGroupIC(r) as RuleType | RuleGroupTypeIC);\n  let startIndex = 0;\n  for (let i = 0; i < rg.rules.length; i += 2) {\n    if (rg.rules.length === 1) {\n      push(rg.rules[0]);\n    } else if (rg.rules[i + 1] === 'and') {\n      startIndex = i;\n      let j = 1;\n      while (rg.rules[startIndex + j] === 'and') {\n        i += 2;\n        j += 2;\n      }\n      returnArray.push({\n        // @ts-expect-error Too complicated to keep track of odd/even indexes in TS\n        rules: rg.rules.slice(startIndex, i + 1).map(processRuleOrStringOrRuleGroupIC),\n      });\n      i -= 2;\n    } else if (rg.rules[i + 1] === 'or') {\n      if (i === 0 || i === rg.rules.length - 3) {\n        if (i === 0 || rg.rules[i - 1] === 'or') {\n          push(rg.rules[i]);\n        }\n        push(rg.rules[i + 1]);\n        if (i === rg.rules.length - 3) {\n          push(rg.rules[i + 2]);\n        }\n      } else {\n        if (rg.rules[i - 1] === 'and') {\n          push(rg.rules[i + 1]);\n        } else {\n          push(rg.rules[i]);\n          push(rg.rules[i + 1]);\n        }\n      }\n    }\n  }\n  if (\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-expect-error TS still thinks returnArray has length 0\n    returnArray.length === 1 &&\n    typeof returnArray[0] === 'object' &&\n    isRuleGroup(returnArray[0])\n  ) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-expect-error TS still thinks returnArray has length 0\n    return { ...rg, ...returnArray[0] };\n  }\n  return { ...rg, rules: returnArray };\n};\n\n/**\n * Converts a {@link RuleGroupTypeIC} to {@link RuleGroupType}.\n *\n * This function is idempotent: {@link RuleGroupType} queries will be\n * returned as-is.\n */\nexport const convertFromIC = <RG extends RuleGroupType = RuleGroupType>(\n  rg: RuleGroupTypeIC\n): RG => {\n  if (isRuleGroupType(rg)) {\n    return rg;\n  }\n  const processedRG = generateRuleGroupICWithConsistentCombinators(rg);\n  const rulesAsMixedList = processedRG.rules.map(r =>\n    typeof r === 'string' || !isRuleGroup(r) ? r : convertFromIC(r)\n  );\n  const combinator = rulesAsMixedList.length < 2 ? 'and' : (rulesAsMixedList[1] as string);\n  const rules = rulesAsMixedList.filter(r => typeof r !== 'string') as RuleGroupArray;\n  return { ...processedRG, combinator, rules } as RG;\n};\n\n/**\n * Converts a {@link RuleGroupType} to {@link RuleGroupTypeIC}.\n *\n * This function is idempotent: {@link RuleGroupTypeIC} queries will be\n * returned as-is.\n */\nexport const convertToIC = <RGIC extends RuleGroupTypeIC = RuleGroupTypeIC>(\n  rg: RuleGroupType\n): RGIC => {\n  if (isRuleGroupTypeIC(rg)) {\n    return rg;\n  }\n  const { combinator, ...queryWithoutCombinator } = rg;\n  const rules: (RuleGroupTypeIC | RuleType | string)[] = [];\n  const { length } = rg.rules;\n  rg.rules.forEach((r, idx) => {\n    if (isRuleGroup(r)) {\n      rules.push(convertToIC(r));\n    } else {\n      rules.push(r);\n    }\n    if (combinator && idx < length - 1) {\n      rules.push(combinator);\n    }\n  });\n  return { ...queryWithoutCombinator, rules } as RGIC;\n};\n\n/**\n * Converts a {@link RuleGroupType} to {@link RuleGroupTypeIC}. For a more explicit\n * operation, use {@link convertToIC}.\n */\nfunction convertQuery(query: RuleGroupType): RuleGroupTypeIC;\n/**\n * Converts a {@link RuleGroupTypeIC} to {@link RuleGroupType}. For a more explicit\n * operation, use {@link convertFromIC}.\n */\nfunction convertQuery(query: RuleGroupTypeIC): RuleGroupType;\nfunction convertQuery(query: RuleGroupType | RuleGroupTypeIC): RuleGroupType | RuleGroupTypeIC {\n  return isRuleGroupTypeIC(query) ? convertFromIC(query) : convertToIC(query);\n}\n\nexport { convertQuery };\n","import type {\n  RuleGroupTypeAny,\n  RuleType,\n  RuleValidator,\n  ValidationResult,\n} from '../types/index.noReact';\nimport { isRuleGroup } from './isRuleGroup';\nimport { isPojo } from './misc';\n\n/**\n * Determines if an object is useful as a validation result.\n */\nexport const isValidationResult = (vr?: ValidationResult): vr is ValidationResult =>\n  isPojo(vr) && typeof vr.valid === 'boolean';\n\n/**\n * Determines if a rule or group is valid based on a validation result (if defined)\n * or a validator function. Returns `true` if neither are defined.\n */\nexport const isRuleOrGroupValid = (\n  rg: RuleType | RuleGroupTypeAny,\n  validationResult?: boolean | ValidationResult,\n  validator?: RuleValidator\n) => {\n  if (typeof validationResult === 'boolean') {\n    return validationResult;\n  }\n  if (isValidationResult(validationResult)) {\n    return validationResult.valid;\n  }\n  if (typeof validator === 'function' && !isRuleGroup(rg)) {\n    const vr = validator(rg);\n    if (typeof vr === 'boolean') {\n      return vr;\n    }\n    // istanbul ignore else\n    if (isValidationResult(vr)) {\n      return vr.valid;\n    }\n  }\n  return true;\n};\n","import { produce } from 'immer';\nimport type {\n  BaseOption,\n  BaseOptionMap,\n  FlexibleOption,\n  FlexibleOptionList,\n  FullOptionList,\n  Option,\n  ToFullOption,\n  ValueOption,\n} from '../types';\nimport { isPojo } from './misc';\nimport { isFlexibleOptionGroupArray } from './optGroupUtils';\n\nconst isOptionWithName = (opt: BaseOption): opt is Option =>\n  isPojo(opt) && 'name' in opt && typeof opt.name === 'string';\nconst isOptionWithValue = (opt: BaseOption): opt is ValueOption =>\n  isPojo(opt) && 'value' in opt && typeof opt.value === 'string';\n\n/**\n * Converts an {@link Option} or {@link ValueOption} (i.e., {@link BaseOption})\n * into a {@link FullOption}. Full options are left unchanged.\n */\nfunction toFullOption<Opt extends BaseOption>(\n  opt: Opt,\n  baseProperties?: Record<string, unknown>\n): ToFullOption<Opt> {\n  const recipe: (o: Opt) => ToFullOption<Opt> = produce(draft => {\n    const idObj: { name?: string; value?: string } = {};\n    let needsUpdating = !!baseProperties;\n\n    if (isOptionWithName(draft) && !isOptionWithValue(draft)) {\n      idObj.value = draft.name;\n      needsUpdating = true;\n    } else if (!isOptionWithName(draft) && isOptionWithValue(draft)) {\n      idObj.name = draft.value;\n      needsUpdating = true;\n    }\n\n    if (needsUpdating) {\n      return Object.assign({}, baseProperties, draft, idObj);\n    }\n  });\n  return recipe(opt);\n}\n\n/**\n * Converts an {@link OptionList} or {@link FlexibleOptionList} into a {@link FullOptionList}.\n * Lists of full options are left unchanged.\n */\nfunction toFullOptionList<Opt extends BaseOption, OptList extends FlexibleOptionList<Opt>>(\n  optList: OptList,\n  baseProperties?: Record<string, unknown>\n): FullOptionList<Opt> {\n  if (!Array.isArray(optList)) {\n    return [] as unknown as FullOptionList<Opt>;\n  }\n\n  const recipe: (ol: FlexibleOptionList<Opt>) => FullOptionList<Opt> = produce(draft => {\n    if (isFlexibleOptionGroupArray(draft)) {\n      for (const optGroup of draft) {\n        optGroup.options.forEach(\n          (opt, idx) => (optGroup.options[idx] = toFullOption(opt, baseProperties))\n        );\n      }\n    } else {\n      (draft as Opt[]).forEach((opt, idx) => (draft[idx] = toFullOption(opt, baseProperties)));\n    }\n  });\n\n  return recipe(optList);\n}\n\n/**\n * Converts a {@link FlexibleOptionList} into a {@link FullOptionList}.\n * Lists of full options are left unchanged.\n */\nfunction toFullOptionMap<OptMap extends BaseOptionMap>(\n  optMap: OptMap,\n  baseProperties?: Record<string, unknown>\n): OptMap extends BaseOptionMap<infer V, infer K> ? Partial<Record<K, ToFullOption<V>>> : never {\n  type FullOptMapType =\n    OptMap extends BaseOptionMap<infer VT, infer KT>\n      ? Partial<Record<KT, ToFullOption<VT>>>\n      : never;\n\n  return Object.fromEntries(\n    (Object.entries(optMap) as [string, FlexibleOption][]).map(([k, v]) => [\n      k,\n      toFullOption(v, baseProperties),\n    ])\n  ) as FullOptMapType;\n}\n\nexport { toFullOption, toFullOptionList, toFullOptionMap };\n","import type { RequireAtLeastOne } from 'type-fest';\nimport type {\n  BaseOption,\n  FlexibleOptionGroup,\n  FlexibleOptionList,\n  OptionGroup,\n  ToFullOption,\n  WithUnknownIndex,\n} from '../types/index.noReact';\nimport { isFlexibleOptionGroupArray } from './optGroupUtils';\nimport { toFullOption } from './toFullOption';\n\n/**\n * @deprecated Renamed to {@link uniqByIdentifier}.\n */\nexport const uniqByName = <\n  T extends { name: string; value?: string } | { name?: string; value: string },\n>(\n  originalArray: T[]\n): T[] => uniqByIdentifier(originalArray);\n\n/**\n * Generates a new array of objects with duplicates removed based\n * on the identifying property (`value` or `name`)\n */\nexport const uniqByIdentifier = <\n  T extends RequireAtLeastOne<{ name: string; value: string }, 'name' | 'value'>,\n>(\n  originalArray: T[]\n): T[] => {\n  const names = new Set<string>();\n  const newArray: T[] = [];\n  originalArray.forEach(el => {\n    if (!names.has((el.value ?? el.name)!)) {\n      names.add((el.value ?? el.name)!);\n      newArray.push(el);\n    }\n  });\n  return originalArray.length === newArray.length ? originalArray : newArray;\n};\n\n/**\n * Generates a new {@link OptionGroup} array with duplicates\n * removed based on the identifying property (`value` or `name`).\n */\nexport const uniqOptGroups = <T extends BaseOption>(\n  originalArray: FlexibleOptionGroup<T>[]\n): OptionGroup<ToFullOption<T>>[] => {\n  type K = T extends BaseOption<infer KT> ? KT : never;\n  const labels = new Set<string>();\n  const names = new Set<K>();\n  const newArray: OptionGroup<ToFullOption<T>>[] = [];\n  originalArray.forEach(el => {\n    if (!labels.has(el.label)) {\n      labels.add(el.label);\n      const optionsForThisGroup: WithUnknownIndex<ToFullOption<T>>[] = [];\n      el.options.forEach(opt => {\n        if (!names.has((opt.value ?? opt.name) as K)) {\n          names.add((opt.value ?? opt.name) as K);\n          optionsForThisGroup.push(toFullOption(opt) as WithUnknownIndex<ToFullOption<T>>);\n        }\n      });\n      newArray.push({ ...el, options: optionsForThisGroup });\n    }\n  });\n  return newArray;\n};\n\n/**\n * Generates a new {@link Option} or {@link OptionGroup} array with duplicates\n * removed based on the identifier property (`value` or `name`).\n */\nexport const uniqOptList = <T extends BaseOption>(originalArray: FlexibleOptionList<T>) => {\n  if (isFlexibleOptionGroupArray(originalArray)) {\n    return uniqOptGroups(originalArray) as OptionGroup<ToFullOption<T>>[];\n  }\n  return uniqByIdentifier((originalArray as BaseOption[]).map(o => toFullOption(o)));\n};\n","import type {\n  BaseOption,\n  FlexibleOptionGroup,\n  FullOption,\n  FullOptionList,\n  GetOptionIdentifierType,\n  Option,\n  OptionGroup,\n  OptionList,\n} from '../types/index.noReact';\nimport { isPojo } from './misc';\nimport { uniqByIdentifier } from './uniq';\n\n/**\n * Determines if an {@link OptionList} is an {@link OptionGroup} array.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isOptionGroupArray = (arr: any): arr is OptionGroup<BaseOption>[] =>\n  Array.isArray(arr) && arr.length > 0 && isPojo(arr[0]) && 'options' in arr[0];\n\n/**\n * Determines if a {@link FlexibleOptionList} is a {@link FlexibleOptionGroup} array.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isFlexibleOptionGroupArray = (arr: any): arr is FlexibleOptionGroup[] =>\n  Array.isArray(arr) &&\n  arr.length > 0 &&\n  isPojo(arr[0]) &&\n  'options' in arr[0] &&\n  isPojo(arr[0].options[0]) &&\n  ('name' in arr[0].options[0] || 'value' in arr[0].options[0]);\n\n/**\n * Determines if a {@link FlexibleOptionList} is a {@link OptionGroup} array of\n * {@link FullOption}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isFullOptionGroupArray = (arr: any): arr is OptionGroup<FullOption>[] =>\n  Array.isArray(arr) &&\n  arr.length > 0 &&\n  isPojo(arr[0]) &&\n  'options' in arr[0] &&\n  isPojo(arr[0].options[0]) &&\n  'name' in arr[0].options[0] &&\n  isPojo(arr[0].options[0]) &&\n  'value' in arr[0].options[0];\n\n/**\n * Gets the option from an {@link OptionList} with the given `name`. Handles\n * {@link Option} arrays as well as {@link OptionGroup} arrays.\n */\nexport const getOption = <OptType extends Option = Option>(\n  arr: OptionList<OptType>,\n  name: string\n): OptType | undefined =>\n  (isOptionGroupArray(arr) ? arr.flatMap(og => og.options) : arr).find(op => op.name === name);\n\n/**\n * Gets the first option from an {@link OptionList}.\n */\nexport const getFirstOption = <Opt extends BaseOption>(arr?: FlexibleOptionGroup<Opt>[] | Opt[]) =>\n  (!Array.isArray(arr) || arr.length === 0\n    ? null\n    : isFlexibleOptionGroupArray(arr)\n      ? arr[0].options[0].value ?? arr[0].options[0].name\n      : arr[0].value ?? arr[0].name) as GetOptionIdentifierType<Opt>;\n\n/**\n * Flattens {@link FlexibleOptionGroup} arrays into {@link BaseOption} arrays.\n * If the array is already flat, it is returned as is.\n */\nexport const toFlatOptionArray = <T extends FullOption, OL extends FullOptionList<T>>(arr: OL) =>\n  uniqByIdentifier(isOptionGroupArray(arr) ? arr.flatMap(og => og.options) : arr) as T[];\n","import { defaultPlaceholderFieldName, defaultPlaceholderOperatorName } from '../../defaults';\nimport type {\n  DefaultCombinatorName,\n  ExportFormat,\n  FormatQueryOptions,\n  FullField,\n  FullOptionList,\n  ParameterizedNamedSQL,\n  ParameterizedSQL,\n  QueryValidator,\n  RQBJsonLogic,\n  RuleGroupType,\n  RuleGroupTypeAny,\n  RuleProcessor,\n  RuleType,\n  RuleValidator,\n  ValidationMap,\n  ValidationResult,\n} from '../../types/index.noReact';\nimport { convertFromIC } from '../convertQuery';\nimport { isRuleGroup, isRuleGroupType } from '../isRuleGroup';\nimport { isRuleOrGroupValid } from '../isRuleOrGroupValid';\nimport { isPojo } from '../misc';\nimport { getOption, toFlatOptionArray } from '../optGroupUtils';\nimport { toFullOptionList } from '../toFullOption';\nimport { defaultRuleProcessorCEL } from './defaultRuleProcessorCEL';\nimport { defaultRuleProcessorElasticSearch } from './defaultRuleProcessorElasticSearch';\nimport { defaultRuleProcessorJSONata } from './defaultRuleProcessorJSONata';\nimport { defaultRuleProcessorJsonLogic } from './defaultRuleProcessorJsonLogic';\nimport { defaultRuleProcessorMongoDB } from './defaultRuleProcessorMongoDB';\nimport { defaultRuleProcessorParameterized } from './defaultRuleProcessorParameterized';\nimport { defaultRuleProcessorSpEL } from './defaultRuleProcessorSpEL';\nimport { defaultRuleProcessorSQL } from './defaultRuleProcessorSQL';\nimport { defaultValueProcessorByRule } from './defaultValueProcessorByRule';\nimport {\n  celCombinatorMap,\n  isValueProcessorLegacy,\n  numerifyValues,\n  quoteFieldNamesWithArray,\n} from './utils';\n\n/**\n * Generates a formatted (indented two spaces) JSON string from a query object.\n */\nfunction formatQuery(ruleGroup: RuleGroupTypeAny): string;\n/**\n * Generates a {@link ParameterizedSQL} object from a query object.\n */\nfunction formatQuery(\n  ruleGroup: RuleGroupTypeAny,\n  options: 'parameterized' | (Omit<FormatQueryOptions, 'format'> & { format: 'parameterized' })\n): ParameterizedSQL;\n/**\n * Generates a {@link ParameterizedNamedSQL} object from a query object.\n */\nfunction formatQuery(\n  ruleGroup: RuleGroupTypeAny,\n  options:\n    | 'parameterized_named'\n    | (Omit<FormatQueryOptions, 'format'> & { format: 'parameterized_named' })\n): ParameterizedNamedSQL;\n/**\n * Generates a {@link JsonLogic} object from a query object.\n */\nfunction formatQuery(\n  ruleGroup: RuleGroupTypeAny,\n  options: 'jsonlogic' | (Omit<FormatQueryOptions, 'format'> & { format: 'jsonlogic' })\n): RQBJsonLogic;\n/**\n * Generates an ElasticSearch query object from an RQB query object.\n *\n * NOTE: Support for the ElasticSearch format is experimental.\n * You may have better results exporting \"sql\" format then using\n * [ElasticSearch SQL](https://www.elastic.co/guide/en/elasticsearch/reference/current/xpack-sql.html).\n */\nfunction formatQuery(\n  ruleGroup: RuleGroupTypeAny,\n  options: 'elasticsearch' | (Omit<FormatQueryOptions, 'format'> & { format: 'elasticsearch' })\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Record<string, any>;\n/**\n * Generates a JSONata query string from an RQB query object.\n *\n * NOTE: The `parseNumbers` option is recommended for this format.\n */\nfunction formatQuery(\n  ruleGroup: RuleGroupTypeAny,\n  options: 'jsonata' | (Omit<FormatQueryOptions, 'format'> & { format: 'jsonata' })\n): string;\n/**\n * Generates a formatted (indented two spaces) JSON string from a query object.\n */\nfunction formatQuery(\n  ruleGroup: RuleGroupTypeAny,\n  options: Omit<FormatQueryOptions, 'format'>\n): string;\n/**\n * Generates a query string in the requested format.\n */\nfunction formatQuery(\n  ruleGroup: RuleGroupTypeAny,\n  options: Exclude<\n    ExportFormat,\n    'parameterized' | 'parameterized_named' | 'jsonlogic' | 'elasticsearch' | 'jsonata'\n  >\n): string;\n/**\n * Generates a query string in the requested format.\n */\nfunction formatQuery(\n  ruleGroup: RuleGroupTypeAny,\n  options: Omit<FormatQueryOptions, 'format'> & {\n    format: Exclude<\n      ExportFormat,\n      'parameterized' | 'parameterized_named' | 'jsonlogic' | 'elasticsearch' | 'jsonata'\n    >;\n  }\n): string;\nfunction formatQuery(ruleGroup: RuleGroupTypeAny, options: FormatQueryOptions | ExportFormat = {}) {\n  let format: ExportFormat = 'json';\n  let valueProcessorInternal = defaultValueProcessorByRule;\n  let ruleProcessorInternal: RuleProcessor | null = null;\n  let quoteFieldNamesWith: [string, string] = ['', ''];\n  let validator: QueryValidator = () => true;\n  let fields: FullOptionList<FullField> = [];\n  let validationMap: ValidationMap = {};\n  let fallbackExpression = '';\n  let paramPrefix = ':';\n  let paramsKeepPrefix = false;\n  let numberedParams = false;\n  let parseNumbers = false;\n  let placeholderFieldName = defaultPlaceholderFieldName;\n  let placeholderOperatorName = defaultPlaceholderOperatorName;\n  let quoteValuesWith = \"'\";\n\n  if (typeof options === 'string') {\n    format = options.toLowerCase() as ExportFormat;\n    if (format === 'mongodb') {\n      ruleProcessorInternal = defaultRuleProcessorMongoDB;\n    } else if (format === 'parameterized') {\n      ruleProcessorInternal = defaultRuleProcessorParameterized;\n    } else if (format === 'parameterized_named') {\n      ruleProcessorInternal = defaultRuleProcessorParameterized;\n    } else if (format === 'cel') {\n      ruleProcessorInternal = defaultRuleProcessorCEL;\n    } else if (format === 'spel') {\n      ruleProcessorInternal = defaultRuleProcessorSpEL;\n    } else if (format === 'jsonlogic') {\n      ruleProcessorInternal = defaultRuleProcessorJsonLogic;\n    } else if (format === 'elasticsearch') {\n      ruleProcessorInternal = defaultRuleProcessorElasticSearch;\n    } else if (format === 'jsonata') {\n      ruleProcessorInternal = defaultRuleProcessorJSONata;\n    }\n  } else {\n    format = (options.format ?? 'json').toLowerCase() as ExportFormat;\n    const { valueProcessor = null, ruleProcessor = null } = options;\n    if (typeof ruleProcessor === 'function') {\n      ruleProcessorInternal = ruleProcessor;\n    }\n    valueProcessorInternal =\n      typeof valueProcessor === 'function'\n        ? (r, opts) =>\n            isValueProcessorLegacy(valueProcessor)\n              ? valueProcessor(r.field, r.operator, r.value, r.valueSource)\n              : valueProcessor(r, opts)\n        : format === 'mongodb'\n          ? ruleProcessorInternal ?? defaultRuleProcessorMongoDB\n          : format === 'cel'\n            ? ruleProcessorInternal ?? defaultRuleProcessorCEL\n            : format === 'spel'\n              ? ruleProcessorInternal ?? defaultRuleProcessorSpEL\n              : format === 'jsonlogic'\n                ? ruleProcessorInternal ?? defaultRuleProcessorJsonLogic\n                : format === 'elasticsearch'\n                  ? ruleProcessorInternal ?? defaultRuleProcessorElasticSearch\n                  : format === 'jsonata'\n                    ? ruleProcessorInternal ?? defaultRuleProcessorJSONata\n                    : defaultValueProcessorByRule;\n    quoteFieldNamesWith = quoteFieldNamesWithArray(options.quoteFieldNamesWith);\n    validator = options.validator ?? (() => true);\n    fields = toFullOptionList(options.fields ?? []);\n    fallbackExpression = options.fallbackExpression ?? '';\n    paramPrefix = options.paramPrefix ?? ':';\n    paramsKeepPrefix = !!options.paramsKeepPrefix;\n    numberedParams = !!options.numberedParams;\n    parseNumbers = !!options.parseNumbers;\n    placeholderFieldName = options.placeholderFieldName ?? defaultPlaceholderFieldName;\n    placeholderOperatorName = options.placeholderOperatorName ?? defaultPlaceholderOperatorName;\n    quoteValuesWith = options.quoteValuesWith ?? \"'\";\n  }\n  if (!fallbackExpression) {\n    fallbackExpression =\n      format === 'mongodb'\n        ? '\"$and\":[{\"$expr\":true}]'\n        : format === 'cel' || format === 'spel'\n          ? '1 == 1'\n          : '(1 = 1)';\n  }\n\n  /**\n   * JSON\n   */\n  if (format === 'json' || format === 'json_without_ids') {\n    const rg = parseNumbers ? numerifyValues(ruleGroup) : ruleGroup;\n    if (format === 'json') {\n      return JSON.stringify(rg, null, 2);\n    }\n    return JSON.stringify(rg, (key, value) =>\n      // Remove `id` and `path` keys; leave everything else unchanged.\n      key === 'id' || key === 'path' ? undefined : value\n    );\n  }\n\n  // istanbul ignore else\n  if (typeof validator === 'function') {\n    const validationResult = validator(ruleGroup);\n    if (typeof validationResult === 'boolean') {\n      if (validationResult === false) {\n        return format === 'parameterized'\n          ? { sql: fallbackExpression, params: [] }\n          : format === 'parameterized_named'\n            ? { sql: fallbackExpression, params: {} }\n            : format === 'mongodb'\n              ? `{${fallbackExpression}}`\n              : format === 'jsonlogic'\n                ? false\n                : format === 'elasticsearch'\n                  ? {}\n                  : fallbackExpression;\n      }\n    } else {\n      validationMap = validationResult;\n    }\n  }\n\n  const validatorMap: Record<string, RuleValidator> = {};\n  const uniqueFields = toFlatOptionArray(fields) satisfies FullField[];\n  uniqueFields.forEach(f => {\n    // istanbul ignore else\n    if (typeof f.validator === 'function') {\n      validatorMap[(f.value ?? /* istanbul ignore next */ f.name)!] = f.validator;\n    }\n  });\n\n  const validateRule = (rule: RuleType) => {\n    let validationResult: boolean | ValidationResult | undefined = undefined;\n    let fieldValidator: RuleValidator | undefined = undefined;\n    if (rule.id) {\n      validationResult = validationMap[rule.id];\n    }\n    if (uniqueFields.length) {\n      const fieldArr = uniqueFields.filter(f => f.name === rule.field);\n      if (fieldArr.length) {\n        const field = fieldArr[0];\n        // istanbul ignore else\n        if (typeof field.validator === 'function') {\n          fieldValidator = field.validator;\n        }\n      }\n    }\n    return [validationResult, fieldValidator] as const;\n  };\n\n  /**\n   * SQL\n   */\n  if (format === 'sql') {\n    const processRuleGroup = (rg: RuleGroupTypeAny, outermostOrLonelyInGroup?: boolean): string => {\n      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */ ''])) {\n        // TODO: test for the last case and remove \"ignore\" comment\n        return outermostOrLonelyInGroup ? fallbackExpression : /* istanbul ignore next */ '';\n      }\n\n      const processedRules = rg.rules.map(rule => {\n        // Independent combinators\n        if (typeof rule === 'string') {\n          return rule;\n        }\n\n        // Groups\n        if (isRuleGroup(rule)) {\n          return processRuleGroup(rule, rg.rules.length === 1);\n        }\n\n        // Basic rule validation\n        const [validationResult, fieldValidator] = validateRule(rule);\n        if (\n          !isRuleOrGroupValid(rule, validationResult, fieldValidator) ||\n          rule.field === placeholderFieldName ||\n          rule.operator === placeholderOperatorName\n        ) {\n          return '';\n        }\n\n        const escapeQuotes = (rule.valueSource ?? 'value') === 'value';\n\n        const fieldData = getOption(fields, rule.field);\n\n        // Use custom rule processor if provided...\n        if (typeof ruleProcessorInternal === 'function') {\n          return ruleProcessorInternal(rule, {\n            parseNumbers,\n            escapeQuotes,\n            quoteFieldNamesWith,\n            fieldData,\n            format,\n            quoteValuesWith,\n          });\n        }\n        // ...otherwise use default rule processor and pass in the value\n        // processor (which may be custom)\n        return defaultRuleProcessorSQL(rule, {\n          parseNumbers,\n          escapeQuotes,\n          valueProcessor: valueProcessorInternal,\n          quoteFieldNamesWith,\n          fieldData,\n          format,\n          quoteValuesWith,\n        });\n      });\n\n      if (processedRules.length === 0) {\n        return fallbackExpression;\n      }\n\n      return `${rg.not ? 'NOT ' : ''}(${processedRules\n        .filter(Boolean)\n        .join(isRuleGroupType(rg) ? ` ${rg.combinator} ` : ' ')})`;\n    };\n\n    return processRuleGroup(ruleGroup, true);\n  }\n\n  /**\n   * Parameterized SQL\n   */\n  if (format === 'parameterized' || format === 'parameterized_named') {\n    const parameterized = format === 'parameterized';\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const params: any[] = [];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const paramsNamed: Record<string, any> = {};\n    const fieldParams: Map<string, Set<string>> = new Map();\n\n    const getNextNamedParam = (field: string) => {\n      if (!fieldParams.has(field)) {\n        fieldParams.set(field, new Set());\n      }\n      const nextNamedParam = `${field}_${fieldParams.get(field)!.size + 1}`;\n      fieldParams.get(field)!.add(nextNamedParam);\n      return nextNamedParam;\n    };\n\n    const processRule = (rule: RuleType) => {\n      const [validationResult, fieldValidator] = validateRule(rule);\n      if (\n        !isRuleOrGroupValid(rule, validationResult, fieldValidator) ||\n        rule.field === placeholderFieldName ||\n        rule.operator === placeholderOperatorName\n      ) {\n        return '';\n      }\n\n      const fieldData = getOption(fields, rule.field);\n\n      const fieldParamNames = Object.fromEntries(\n        (Array.from(fieldParams.entries()) as [string, Set<string>][]).map(([f, s]) => [\n          f,\n          Array.from(s),\n        ])\n      );\n\n      const processedRule = (\n        typeof ruleProcessorInternal === 'function'\n          ? ruleProcessorInternal\n          : defaultRuleProcessorParameterized\n      )(\n        rule,\n        {\n          getNextNamedParam,\n          fieldParamNames,\n          parseNumbers,\n          quoteFieldNamesWith,\n          fieldData,\n          format,\n          paramPrefix,\n          paramsKeepPrefix,\n          numberedParams,\n          fallbackExpression,\n          valueProcessor: valueProcessorInternal,\n          fields,\n          placeholderFieldName,\n          placeholderOperatorName,\n          validator,\n        },\n        {\n          processedParams: params,\n        }\n      );\n\n      if (!isPojo(processedRule)) {\n        return '';\n      }\n\n      const { sql, params: customParams } = processedRule;\n\n      if (typeof sql !== 'string' || !sql) {\n        return '';\n      }\n\n      // istanbul ignore else\n      if (format === 'parameterized' && Array.isArray(customParams)) {\n        params.push(...customParams);\n      } else if (format === 'parameterized_named' && isPojo(customParams)) {\n        Object.assign(paramsNamed, customParams);\n        // `getNextNamedParam` already adds new params to the list, but a custom\n        // rule processor might not call it so we need to make sure we add\n        // any new params here.\n        Object.keys(customParams).forEach(p => fieldParams.get(rule.field)?.add(p));\n      }\n\n      return sql;\n    };\n\n    const processRuleGroup = (rg: RuleGroupTypeAny, outermostOrLonelyInGroup?: boolean): string => {\n      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */ ''])) {\n        // TODO: test for the last case and remove \"ignore\" comment\n        return outermostOrLonelyInGroup ? fallbackExpression : /* istanbul ignore next */ '';\n      }\n\n      const processedRules = rg.rules.map(rule => {\n        if (typeof rule === 'string') {\n          return rule;\n        }\n        if (isRuleGroup(rule)) {\n          return processRuleGroup(rule, rg.rules.length === 1);\n        }\n        return processRule(rule);\n      });\n\n      if (processedRules.length === 0) {\n        return fallbackExpression;\n      }\n\n      return `${rg.not ? 'NOT ' : ''}(${processedRules\n        .filter(Boolean)\n        .join(isRuleGroupType(rg) ? ` ${rg.combinator} ` : ' ')})`;\n    };\n\n    if (parameterized) {\n      return { sql: processRuleGroup(ruleGroup, true), params };\n    }\n    return { sql: processRuleGroup(ruleGroup, true), params: paramsNamed };\n  }\n\n  /**\n   * MongoDB\n   */\n  if (format === 'mongodb') {\n    const processRuleGroup = (rg: RuleGroupType, outermost?: boolean) => {\n      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */ ''])) {\n        return outermost ? fallbackExpression : '';\n      }\n\n      const combinator = `\"$${rg.combinator.toLowerCase()}\"`;\n      let hasChildRules = false;\n\n      const expressions: string[] = rg.rules\n        .map(rule => {\n          if (isRuleGroup(rule)) {\n            const processedRuleGroup = processRuleGroup(rule);\n            if (processedRuleGroup) {\n              hasChildRules = true;\n              // Don't wrap in curly braces if the result already is.\n              return /^\\{.+\\}$/.test(processedRuleGroup)\n                ? processedRuleGroup\n                : `{${processedRuleGroup}}`;\n            }\n            return '';\n          }\n          const [validationResult, fieldValidator] = validateRule(rule);\n          if (\n            !isRuleOrGroupValid(rule, validationResult, fieldValidator) ||\n            rule.field === placeholderFieldName ||\n            rule.operator === placeholderOperatorName\n          ) {\n            return '';\n          }\n          const fieldData = getOption(fields, rule.field);\n          return (ruleProcessorInternal ?? valueProcessorInternal)(rule, {\n            parseNumbers,\n            fieldData,\n            format,\n          });\n        })\n        .filter(Boolean);\n\n      return expressions.length > 0\n        ? expressions.length === 1 && !hasChildRules\n          ? expressions[0]\n          : `${combinator}:[${expressions.join(',')}]`\n        : fallbackExpression;\n    };\n\n    const rgStandard = isRuleGroupType(ruleGroup) ? ruleGroup : convertFromIC(ruleGroup);\n    const processedQuery = processRuleGroup(rgStandard, true);\n    return /^\\{.+\\}$/.test(processedQuery) ? processedQuery : `{${processedQuery}}`;\n  }\n\n  /**\n   * CEL\n   */\n  if (format === 'cel') {\n    const processRuleGroup = (rg: RuleGroupTypeAny, outermost?: boolean) => {\n      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */ ''])) {\n        return outermost ? fallbackExpression : '';\n      }\n\n      const expression: string = rg.rules\n        .map(rule => {\n          if (typeof rule === 'string') {\n            return celCombinatorMap[rule as DefaultCombinatorName];\n          }\n          if (isRuleGroup(rule)) {\n            return processRuleGroup(rule);\n          }\n          const [validationResult, fieldValidator] = validateRule(rule);\n          if (\n            !isRuleOrGroupValid(rule, validationResult, fieldValidator) ||\n            rule.field === placeholderFieldName ||\n            rule.operator === placeholderOperatorName\n          ) {\n            return '';\n          }\n          const fieldData = getOption(fields, rule.field);\n          return (ruleProcessorInternal ?? valueProcessorInternal)(rule, {\n            parseNumbers,\n            escapeQuotes: (rule.valueSource ?? 'value') === 'value',\n            fieldData,\n            format,\n          });\n        })\n        .filter(Boolean)\n        .join(\n          isRuleGroupType(rg)\n            ? ` ${celCombinatorMap[rg.combinator as DefaultCombinatorName]} `\n            : ' '\n        );\n\n      const [prefix, suffix] = rg.not || !outermost ? [`${rg.not ? '!' : ''}(`, ')'] : ['', ''];\n\n      return expression ? `${prefix}${expression}${suffix}` : fallbackExpression;\n    };\n\n    return processRuleGroup(ruleGroup, true);\n  }\n\n  /**\n   * SpEL\n   */\n  if (format === 'spel') {\n    const processRuleGroup = (rg: RuleGroupTypeAny, outermost?: boolean) => {\n      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */ ''])) {\n        return outermost ? fallbackExpression : '';\n      }\n\n      const expression: string = rg.rules\n        .map(rule => {\n          if (typeof rule === 'string') {\n            return rule;\n          }\n          if (isRuleGroup(rule)) {\n            return processRuleGroup(rule);\n          }\n          const [validationResult, fieldValidator] = validateRule(rule);\n          if (\n            !isRuleOrGroupValid(rule, validationResult, fieldValidator) ||\n            rule.field === placeholderFieldName ||\n            rule.operator === placeholderOperatorName\n          ) {\n            return '';\n          }\n          const fieldData = getOption(fields, rule.field);\n          return (ruleProcessorInternal ?? valueProcessorInternal)(rule, {\n            parseNumbers,\n            escapeQuotes: (rule.valueSource ?? 'value') === 'value',\n            fieldData,\n            format,\n          });\n        })\n        .filter(Boolean)\n        .join(isRuleGroupType(rg) ? ` ${rg.combinator} ` : ' ');\n\n      const [prefix, suffix] = rg.not || !outermost ? [`${rg.not ? '!' : ''}(`, ')'] : ['', ''];\n\n      return expression ? `${prefix}${expression}${suffix}` : fallbackExpression;\n    };\n\n    return processRuleGroup(ruleGroup, true);\n  }\n\n  /**\n   * JSONata\n   */\n  if (format === 'jsonata') {\n    const processRuleGroup = (rg: RuleGroupTypeAny, outermost?: boolean) => {\n      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */ ''])) {\n        return outermost ? fallbackExpression : '';\n      }\n\n      const expression: string = rg.rules\n        .map(rule => {\n          if (typeof rule === 'string') {\n            return rule;\n          }\n          if (isRuleGroup(rule)) {\n            return processRuleGroup(rule);\n          }\n          const [validationResult, fieldValidator] = validateRule(rule);\n          if (\n            !isRuleOrGroupValid(rule, validationResult, fieldValidator) ||\n            rule.field === placeholderFieldName ||\n            rule.operator === placeholderOperatorName\n          ) {\n            return '';\n          }\n          const fieldData = getOption(fields, rule.field);\n          return (ruleProcessorInternal ?? valueProcessorInternal)(rule, {\n            parseNumbers,\n            escapeQuotes: (rule.valueSource ?? 'value') === 'value',\n            fieldData,\n            format,\n            quoteFieldNamesWith,\n          });\n        })\n        .filter(Boolean)\n        .join(isRuleGroupType(rg) ? ` ${rg.combinator} ` : ' ');\n\n      const [prefix, suffix] = rg.not || !outermost ? [`${rg.not ? '$not' : ''}(`, ')'] : ['', ''];\n\n      return expression ? `${prefix}${expression}${suffix}` : fallbackExpression;\n    };\n\n    return processRuleGroup(ruleGroup, true);\n  }\n\n  /**\n   * JsonLogic\n   */\n  if (format === 'jsonlogic') {\n    const query = isRuleGroupType(ruleGroup) ? ruleGroup : convertFromIC(ruleGroup);\n\n    const processRuleGroup = (rg: RuleGroupType, _outermost?: boolean): RQBJsonLogic => {\n      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */ ''])) {\n        return false;\n      }\n\n      const processedRules = rg.rules\n        .map(rule => {\n          if (isRuleGroup(rule)) {\n            return processRuleGroup(rule);\n          }\n          const [validationResult, fieldValidator] = validateRule(rule);\n          if (\n            !isRuleOrGroupValid(rule, validationResult, fieldValidator) ||\n            rule.field === placeholderFieldName ||\n            rule.operator === placeholderOperatorName\n          ) {\n            return false;\n          }\n          const fieldData = getOption(fields, rule.field);\n          return (ruleProcessorInternal ?? valueProcessorInternal)(rule, {\n            parseNumbers,\n            fieldData,\n            format,\n          });\n        })\n        .filter(Boolean);\n\n      if (processedRules.length === 0) {\n        return false;\n      }\n\n      const jsonRuleGroup: RQBJsonLogic = { [rg.combinator]: processedRules } as {\n        [k in DefaultCombinatorName]: [RQBJsonLogic, RQBJsonLogic, ...RQBJsonLogic[]];\n      };\n\n      return rg.not ? { '!': jsonRuleGroup } : jsonRuleGroup;\n    };\n\n    return processRuleGroup(query, true);\n  }\n\n  /**\n   * ElasticSearch\n   */\n  if (format === 'elasticsearch') {\n    const query = isRuleGroupType(ruleGroup) ? ruleGroup : convertFromIC(ruleGroup);\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const processRuleGroup = (rg: RuleGroupType): Record<string, any> | false => {\n      if (!isRuleOrGroupValid(rg, validationMap[rg.id ?? /* istanbul ignore next */ ''])) {\n        return false;\n      }\n\n      const processedRules = rg.rules\n        .map(rule => {\n          if (isRuleGroup(rule)) {\n            return processRuleGroup(rule);\n          }\n          const [validationResult, fieldValidator] = validateRule(rule);\n          if (\n            !isRuleOrGroupValid(rule, validationResult, fieldValidator) ||\n            rule.field === placeholderFieldName ||\n            rule.operator === placeholderOperatorName\n          ) {\n            return false;\n          }\n          const fieldData = getOption(fields, rule.field);\n          return (ruleProcessorInternal ?? valueProcessorInternal)(rule, {\n            parseNumbers,\n            fieldData,\n            format,\n          });\n        })\n        .filter(Boolean);\n\n      if (processedRules.length === 0) {\n        return false;\n      }\n\n      return {\n        bool: rg.not\n          ? {\n              must_not:\n                rg.combinator === 'or' ? { bool: { should: processedRules } } : processedRules,\n            }\n          : { [rg.combinator === 'or' ? 'should' : 'must']: processedRules },\n      };\n    };\n\n    const processedRuleGroup = processRuleGroup(query);\n    return processedRuleGroup === false ? {} : processedRuleGroup;\n  }\n\n  return '';\n}\n\nexport { formatQuery };\n"],"mappings":"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","names":["import_numeric_quantity","numericQuantityRegex","negate","escapeDoubleQuotes","shouldNegate","negate","shouldNegate","negate","negateIfNotOp"]}